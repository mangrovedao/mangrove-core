{
  "language": "Solidity",
  "sources": {
    "contracts/AbstractMangrove.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// AbstractMangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML} from \"./MgvLib.sol\";\n\nimport {MgvOfferMaking} from \"./MgvOfferMaking.sol\";\nimport {MgvOfferTakingWithPermit} from \"./MgvOfferTakingWithPermit.sol\";\nimport {MgvGovernable} from \"./MgvGovernable.sol\";\n\n/* `AbstractMangrove` inherits the three contracts that implement generic Mangrove functionality (`MgvGovernable`,`MgvOfferTakingWithPermit` and `MgvOfferMaking`) but does not implement the abstract functions. */\nabstract contract AbstractMangrove is\n  MgvGovernable,\n  MgvOfferTakingWithPermit,\n  MgvOfferMaking\n{\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax,\n    string memory contractName\n  )\n    MgvOfferTakingWithPermit(contractName)\n    MgvGovernable(governance, gasprice, gasmax)\n  {}\n}\n"
    },
    "contracts/MgvLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// MgvLib.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\nimport \"./MgvPack.sol\" as P;\n\n/* # Structs\nThe structs defined in `structs.js` have their counterpart as solidity structs that are easy to manipulate for outside contracts / callers of view functions. */\n\nlibrary MgvLib {\n  /*\n   Some miscellaneous data types useful to `Mangrove` and external contracts */\n  //+clear+\n\n  /* `SingleOrder` holds data about an order-offer match in a struct. Used by `marketOrder` and `internalSnipes` (and some of their nested functions) to avoid stack too deep errors. */\n  struct SingleOrder {\n    address outbound_tkn;\n    address inbound_tkn;\n    uint offerId;\n    P.Offer.t offer;\n    /* `wants`/`gives` mutate over execution. Initially the `wants`/`gives` from the taker's pov, then actual `wants`/`gives` adjusted by offer's price and volume. */\n    uint wants;\n    uint gives;\n    /* `offerDetail` is only populated when necessary. */\n    P.OfferDetail.t offerDetail;\n    P.Global.t global;\n    P.Local.t local;\n  }\n\n  /* <a id=\"MgvLib/OrderResult\"></a> `OrderResult` holds additional data for the maker and is given to them _after_ they fulfilled an offer. It gives them their own returned data from the previous call, and an `mgvData` specifying whether the Mangrove encountered an error. */\n\n  struct OrderResult {\n    /* `makerdata` holds a message that was either returned by the maker or passed as revert message at the end of the trade execution*/\n    bytes32 makerData;\n    /* `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes) code. */\n    bytes32 mgvData;\n  }\n}\n\n/* # Events\nThe events emitted for use by bots are listed here: */\ncontract HasMgvEvents {\n  /* * Emitted at the creation of the new Mangrove contract on the pair (`inbound_tkn`, `outbound_tkn`)*/\n  event NewMgv();\n\n  /* Mangrove adds or removes wei from `maker`'s account */\n  /* * Credit event occurs when an offer is removed from the Mangrove or when the `fund` function is called*/\n  event Credit(address indexed maker, uint amount);\n  /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */\n  event Debit(address indexed maker, uint amount);\n\n  /* * Mangrove reconfiguration */\n  event SetActive(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    bool value\n  );\n  event SetFee(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasbase(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offer_gasbase\n  );\n  event SetGovernance(address value);\n  event SetMonitor(address value);\n  event SetVault(address value);\n  event SetUseOracle(bool value);\n  event SetNotify(bool value);\n  event SetGasmax(uint value);\n  event SetDensity(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasprice(uint value);\n\n  /* Market order execution */\n  event OrderStart();\n  event OrderComplete(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address indexed taker,\n    uint takerGot,\n    uint takerGave,\n    uint penalty\n  );\n\n  /* * Offer execution */\n  event OfferSuccess(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\n    address taker,\n    uint takerWants,\n    uint takerGives\n  );\n\n  /* Log information when a trade execution reverts or returns a non empty bytes32 word */\n  event OfferFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\n    address taker,\n    uint takerWants,\n    uint takerGives,\n    // `mgvData` may only be `\"mgv/makerRevert\"`, `\"mgv/makerAbort\"`, `\"mgv/makerTransferFail\"` or `\"mgv/makerReceiveFail\"`\n    bytes32 mgvData\n  );\n\n  /* Log information when a posthook reverts */\n  event PosthookFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId\n  );\n\n  /* * After `permit` and `approve` */\n  event Approval(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address owner,\n    address spender,\n    uint value\n  );\n\n  /* * Mangrove closure */\n  event Kill();\n\n  /* * An offer was created or updated.\n  A few words about why we include a `prev` field, and why we don't include a\n  `next` field: in theory clients should need neither `prev` nor a `next` field.\n  They could just 1. Read the order book state at a given block `b`.  2. On\n  every event, update a local copy of the orderbook.  But in practice, we do not\n  want to force clients to keep a copy of the *entire* orderbook. There may be a\n  long tail of spam. Now if they only start with the first $N$ offers and\n  receive a new offer that goes to the end of the book, they cannot tell if\n  there are missing offers between the new offer and the end of the local copy\n  of the book.\n  \n  So we add a prev pointer so clients with only a prefix of the book can receive\n  out-of-prefix offers and know what to do with them. The `next` pointer is an\n  optimization useful in Solidity (we traverse fewer memory locations) but\n  useless in client code.\n  */\n  event OfferWrite(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address maker,\n    uint wants,\n    uint gives,\n    uint gasprice,\n    uint gasreq,\n    uint id,\n    uint prev\n  );\n\n  /* * `offerId` was present and is now removed from the book. */\n  event OfferRetract(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id\n  );\n}\n\n/* # IMaker interface */\ninterface IMaker {\n  /* Called upon offer execution. \n  - If the call fails, Mangrove will not try to transfer funds.\n  - If the call succeeds but returndata's first 32 bytes are not 0, Mangrove will not try to transfer funds either.\n  - If the call succeeds and returndata's first 32 bytes are 0, Mangrove will try to transfer funds.\n  In other words, you may declare failure by reverting or by returning nonzero data. In both cases, those 32 first bytes will be passed back to you during the call to `makerPosthook` in the `result.mgvData` field.\n     ```\n     function tradeRevert(bytes32 data) internal pure {\n       bytes memory revData = new bytes(32);\n         assembly {\n           mstore(add(revData, 32), data)\n           revert(add(revData, 32), 32)\n         }\n     }\n     ```\n     */\n  function makerExecute(MgvLib.SingleOrder calldata order)\n    external\n    returns (bytes32);\n\n  /* Called after all offers of an order have been executed. Posthook of the last executed order is called first and full reentrancy into the Mangrove is enabled at this time. `order` recalls key arguments of the order that was processed and `result` recalls important information for updating the current offer. (see [above](#MgvLib/OrderResult))*/\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external;\n}\n\n/* # ITaker interface */\ninterface ITaker {\n  /* Inverted mangrove only: call to taker after loans went through */\n  function takerTrade(\n    address outbound_tkn,\n    address inbound_tkn,\n    // total amount of outbound_tkn token that was flashloaned to the taker\n    uint totalGot,\n    // total amount of inbound_tkn token that should be made available\n    uint totalGives\n  ) external;\n}\n\n/* # Monitor interface\nIf enabled, the monitor receives notification after each offer execution and is read for each pair's `gasprice` and `density`. */\ninterface IMgvMonitor {\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external;\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker) external;\n\n  function read(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint gasprice, uint density);\n}\n"
    },
    "contracts/MgvOfferMaking.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferMaking.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {IMaker, HasMgvEvents, P} from \"./MgvLib.sol\";\nimport {MgvHasOffers} from \"./MgvHasOffers.sol\";\n\n/* `MgvOfferMaking` contains market-making-related functions. */\ncontract MgvOfferMaking is MgvHasOffers {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  /* # Public Maker operations\n     ## New Offer */\n  //+clear+\n  /* In the Mangrove, makers and takers call separate functions. Market makers call `newOffer` to fill the book, and takers call functions such as `marketOrder` to consume it.  */\n\n  //+clear+\n\n  /* The following structs holds offer creation/update parameters in memory. This frees up stack space for local variables. */\n  struct OfferPack {\n    address outbound_tkn;\n    address inbound_tkn;\n    uint wants;\n    uint gives;\n    uint id;\n    uint gasreq;\n    uint gasprice;\n    uint pivotId;\n    P.Global.t global;\n    P.Local.t local;\n    // used on update only\n    P.Offer.t oldOffer;\n  }\n\n  /* The function `newOffer` is for market makers only; no match with the existing book is done. A maker specifies how much `inbound_tkn` it `wants` and how much `outbound_tkn` it `gives`.\n\n     It also specify with `gasreq` how much gas should be given when executing their offer.\n\n     `gasprice` indicates an upper bound on the gasprice at which the maker is ready to be penalised if their offer fails. Any value below the Mangrove's internal `gasprice` configuration value will be ignored.\n\n    `gasreq`, together with `gasprice`, will contribute to determining the penalty provision set aside by the Mangrove from the market maker's `balanceOf` balance.\n\n  Offers are always inserted at the correct place in the book. This requires walking through offers to find the correct insertion point. As in [Oasis](https://github.com/daifoundation/maker-otc/blob/f2060c5fe12fe3da71ac98e8f6acc06bca3698f5/src/matching_market.sol#L493), the maker should find the id of an offer close to its own and provide it as `pivotId`.\n\n  An offer cannot be inserted in a closed market, nor when a reentrancy lock for `outbound_tkn`,`inbound_tkn` is on.\n\n  No more than $2^{32}-1$ offers can ever be created for one `outbound_tkn`,`inbound_tkn` pair.\n\n  The actual contents of the function is in `writeOffer`, which is called by both `newOffer` and `updateOffer`.\n  */\n  function newOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) external payable returns (uint) { unchecked {\n    /* In preparation for calling `writeOffer`, we read the `outbound_tkn`,`inbound_tkn` pair configuration, check for reentrancy and market liveness, fill the `OfferPack` struct and increment the `outbound_tkn`,`inbound_tkn` pair's `last`. */\n    OfferPack memory ofp;\n    (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\n    unlockedMarketOnly(ofp.local);\n    activeMarketOnly(ofp.global, ofp.local);\n    if (msg.value > 0) {\n      creditWei(msg.sender, msg.value);\n    }\n\n    ofp.id = 1 + ofp.local.last();\n    require(uint32(ofp.id) == ofp.id, \"mgv/offerIdOverflow\");\n\n    ofp.local = ofp.local.last(ofp.id);\n\n    ofp.outbound_tkn = outbound_tkn;\n    ofp.inbound_tkn = inbound_tkn;\n    ofp.wants = wants;\n    ofp.gives = gives;\n    ofp.gasreq = gasreq;\n    ofp.gasprice = gasprice;\n    ofp.pivotId = pivotId;\n\n    /* The second parameter to writeOffer indicates that we are creating a new offer, not updating an existing one. */\n    writeOffer(ofp, false);\n\n    /* Since we locally modified a field of the local configuration (`last`), we save the change to storage. Note that `writeOffer` may have further modified the local configuration by updating the current `best` offer. */\n    locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\n    return ofp.id;\n  }}\n\n  /* ## Update Offer */\n  //+clear+\n  /* Very similar to `newOffer`, `updateOffer` prepares an `OfferPack` for `writeOffer`. Makers should use it for updating live offers, but also to save on gas by reusing old, already consumed offers.\n\n     A `pivotId` should still be given to minimise reads in the offer book. It is OK to give the offers' own id as a pivot.\n\n\n     Gas use is minimal when:\n     1. The offer does not move in the book\n     2. The offer does not change its `gasreq`\n     3. The (`outbound_tkn`,`inbound_tkn`)'s `offer_gasbase` has not changed since the offer was last written\n     4. `gasprice` has not changed since the offer was last written\n     5. `gasprice` is greater than the Mangrove's gasprice estimation\n  */\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external payable { unchecked {\n    OfferPack memory ofp;\n    (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\n    unlockedMarketOnly(ofp.local);\n    activeMarketOnly(ofp.global, ofp.local);\n    if (msg.value > 0) {\n      creditWei(msg.sender, msg.value);\n    }\n    ofp.outbound_tkn = outbound_tkn;\n    ofp.inbound_tkn = inbound_tkn;\n    ofp.wants = wants;\n    ofp.gives = gives;\n    ofp.id = offerId;\n    ofp.gasreq = gasreq;\n    ofp.gasprice = gasprice;\n    ofp.pivotId = pivotId;\n    ofp.oldOffer = offers[outbound_tkn][inbound_tkn][offerId];\n    // Save local config\n    P.Local.t oldLocal = ofp.local;\n    /* The second argument indicates that we are updating an existing offer, not creating a new one. */\n    writeOffer(ofp, true);\n    /* We saved the current pair's configuration before calling `writeOffer`, since that function may update the current `best` offer. We now check for any change to the configuration and update it if needed. */\n    if (!oldLocal.eq(ofp.local)) {\n      locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\n    }\n  }}\n\n  /* ## Retract Offer */\n  //+clear+\n  /* `retractOffer` takes the offer `offerId` out of the book. However, `deprovision == true` also refunds the provision associated with the offer. */\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision\n  ) external returns (uint provision) { unchecked {\n    (, P.Local.t local) = config(outbound_tkn, inbound_tkn);\n    unlockedMarketOnly(local);\n    P.Offer.t offer = offers[outbound_tkn][inbound_tkn][offerId];\n    P.OfferDetail.t offerDetail = offerDetails[outbound_tkn][inbound_tkn][offerId];\n    require(\n      msg.sender == offerDetail.maker(),\n      \"mgv/retractOffer/unauthorized\"\n    );\n\n    /* Here, we are about to un-live an offer, so we start by taking it out of the book by stitching together its previous and next offers. Note that unconditionally calling `stitchOffers` would break the book since it would connect offers that may have since moved. */\n    if (isLive(offer)) {\n      P.Local.t oldLocal = local;\n      local = stitchOffers(\n        outbound_tkn,\n        inbound_tkn,\n        offer.prev(),\n        offer.next(),\n        local\n      );\n      /* If calling `stitchOffers` has changed the current `best` offer, we update the storage. */\n      if (!oldLocal.eq(local)) {\n        locals[outbound_tkn][inbound_tkn] = local;\n      }\n    }\n    /* Set `gives` to 0. Moreover, the last argument depends on whether the user wishes to get their provision back (if true, `gasprice` will be set to 0 as well). */\n    dirtyDeleteOffer(\n      outbound_tkn,\n      inbound_tkn,\n      offerId,\n      offer,\n      offerDetail,\n      deprovision\n    );\n\n    /* If the user wants to get their provision back, we compute its provision from the offer's `gasprice`, `offer_gasbase` and `gasreq`. */\n    if (deprovision) {\n      provision =\n        10**9 *\n        offerDetail.gasprice() * //gasprice is 0 if offer was deprovisioned\n        (offerDetail.gasreq() + offerDetail.offer_gasbase());\n      // credit `balanceOf` and log transfer\n      creditWei(msg.sender, provision);\n    }\n    emit OfferRetract(outbound_tkn, inbound_tkn, offerId);\n  }}\n\n  /* ## Provisioning\n  Market makers must have enough provisions for possible penalties. These provisions are in ETH. Every time a new offer is created or an offer is updated, `balanceOf` is adjusted to provision the offer's maximum possible penalty (`gasprice * (gasreq + offer_gasbase)`).\n\n  For instance, if the current `balanceOf` of a maker is 1 ether and they create an offer that requires a provision of 0.01 ethers, their `balanceOf` will be reduced to 0.99 ethers. No ethers will move; this is just an internal accounting movement to make sure the maker cannot `withdraw` the provisioned amounts.\n\n  */\n  //+clear+\n\n  /* Fund should be called with a nonzero value (hence the `payable` modifier). The provision will be given to `maker`, not `msg.sender`. */\n  function fund(address maker) public payable { unchecked {\n    (P.Global.t _global, ) = config(address(0), address(0));\n    liveMgvOnly(_global);\n    creditWei(maker, msg.value);\n  }}\n\n  function fund() external payable { unchecked {\n    fund(msg.sender);\n  }}\n\n  /* A transfer with enough gas to the Mangrove will increase the caller's available `balanceOf` balance. _You should send enough gas to execute this function when sending money to the Mangrove._  */\n  receive() external payable { unchecked {\n    fund(msg.sender);\n  }}\n\n  /* Any provision not currently held to secure an offer's possible penalty is available for withdrawal. */\n  function withdraw(uint amount) external returns (bool noRevert) { unchecked {\n    /* Since we only ever send money to the caller, we do not need to provide any particular amount of gas, the caller should manage this herself. */\n    debitWei(msg.sender, amount);\n    (noRevert, ) = msg.sender.call{value: amount}(\"\");\n  }}\n\n  /* # Low-level Maker functions */\n\n  /* ## Write Offer */\n\n  function writeOffer(OfferPack memory ofp, bool update) internal { unchecked {\n    /* `gasprice`'s floor is Mangrove's own gasprice estimate, `ofp.global.gasprice`. We first check that gasprice fits in 16 bits. Otherwise it could be that `uint16(gasprice) < global_gasprice < gasprice`, and the actual value we store is `uint16(gasprice)`. */\n    require(\n      checkGasprice(ofp.gasprice),\n      \"mgv/writeOffer/gasprice/16bits\"\n    );\n\n    if (ofp.gasprice < ofp.global.gasprice()) {\n      ofp.gasprice = ofp.global.gasprice();\n    }\n\n    /* * Check `gasreq` below limit. Implies `gasreq` at most 24 bits wide, which ensures no overflow in computation of `provision` (see below). */\n    require(\n      ofp.gasreq <= ofp.global.gasmax(),\n      \"mgv/writeOffer/gasreq/tooHigh\"\n    );\n    /* * Make sure `gives > 0` -- division by 0 would throw in several places otherwise, and `isLive` relies on it. */\n    require(ofp.gives > 0, \"mgv/writeOffer/gives/tooLow\");\n    /* * Make sure that the maker is posting a 'dense enough' offer: the ratio of `outbound_tkn` offered per gas consumed must be high enough. The actual gas cost paid by the taker is overapproximated by adding `offer_gasbase` to `gasreq`. */\n    require(\n      ofp.gives >=\n        (ofp.gasreq + ofp.local.offer_gasbase()) * ofp.local.density(),\n      \"mgv/writeOffer/density/tooLow\"\n    );\n\n    /* The following checks are for the maker's convenience only. */\n    require(uint96(ofp.gives) == ofp.gives, \"mgv/writeOffer/gives/96bits\");\n    require(uint96(ofp.wants) == ofp.wants, \"mgv/writeOffer/wants/96bits\");\n\n    /* The position of the new or updated offer is found using `findPosition`. If the offer is the best one, `prev == 0`, and if it's the last in the book, `next == 0`.\n\n       `findPosition` is only ever called here, but exists as a separate function to make the code easier to read.\n\n    **Warning**: `findPosition` will call `better`, which may read the offer's `offerDetails`. So it is important to find the offer position _before_ we update its `offerDetail` in storage. We waste 1 (hot) read in that case but we deem that the code would get too ugly if we passed the old `offerDetail` as argument to `findPosition` and to `better`, just to save 1 hot read in that specific case.  */\n    (uint prev, uint next) = findPosition(ofp);\n\n    /* Log the write offer event. */\n    emit OfferWrite(\n      ofp.outbound_tkn,\n      ofp.inbound_tkn,\n      msg.sender,\n      ofp.wants,\n      ofp.gives,\n      ofp.gasprice,\n      ofp.gasreq,\n      ofp.id,\n      prev\n    );\n\n    /* We now write the new `offerDetails` and remember the previous provision (0 by default, for new offers) to balance out maker's `balanceOf`. */\n    uint oldProvision;\n    {\n      P.OfferDetail.t offerDetail = offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][\n        ofp.id\n      ];\n      if (update) {\n        require(\n          msg.sender == offerDetail.maker(),\n          \"mgv/updateOffer/unauthorized\"\n        );\n        oldProvision =\n          10**9 *\n          offerDetail.gasprice() *\n          (offerDetail.gasreq() + offerDetail.offer_gasbase());\n      }\n\n      /* If the offer is new, has a new `gasprice`, `gasreq`, or if the Mangrove's `offer_gasbase` configuration parameter has changed, we also update `offerDetails`. */\n      if (\n        !update ||\n        offerDetail.gasreq() != ofp.gasreq ||\n        offerDetail.gasprice() != ofp.gasprice ||\n        offerDetail.offer_gasbase() !=\n        ofp.local.offer_gasbase()\n      ) {\n        uint offer_gasbase = ofp.local.offer_gasbase();\n        offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = \n        P.OfferDetail.pack({\n          __maker: msg.sender,\n          __gasreq: ofp.gasreq,\n          __offer_gasbase: offer_gasbase,\n          __gasprice: ofp.gasprice\n        });\n      }\n    }\n\n    /* With every change to an offer, a maker may deduct provisions from its `balanceOf` balance. It may also get provisions back if the updated offer requires fewer provisions than before. */\n    {\n      uint provision = (ofp.gasreq +\n        ofp.local.offer_gasbase()) *\n        ofp.gasprice *\n        10**9;\n      if (provision > oldProvision) {\n        debitWei(msg.sender, provision - oldProvision);\n      } else if (provision < oldProvision) {\n        creditWei(msg.sender, oldProvision - provision);\n      }\n    }\n    /* We now place the offer in the book at the position found by `findPosition`. */\n\n    /* First, we test if the offer has moved in the book or is not currently in the book. If `!isLive(ofp.oldOffer)`, we must update its prev/next. If it is live but its prev has changed, we must also update them. Note that checking both `prev = oldPrev` and `next == oldNext` would be redundant. If either is true, then the updated offer has not changed position and there is nothing to update.\n\n    As a note for future changes, there is a tricky edge case where `prev == oldPrev` yet the prev/next should be changed: a previously-used offer being brought back in the book, and ending with the same prev it had when it was in the book. In that case, the neighbor is currently pointing to _another_ offer, and thus must be updated. With the current code structure, this is taken care of as a side-effect of checking `!isLive`, but should be kept in mind. The same goes in the `next == oldNext` case. */\n    if (!isLive(ofp.oldOffer) || prev != ofp.oldOffer.prev()) {\n      /* * If the offer is not the best one, we update its predecessor; otherwise we update the `best` value. */\n      if (prev != 0) {\n        offers[ofp.outbound_tkn][ofp.inbound_tkn][prev] = offers[ofp.outbound_tkn][ofp.inbound_tkn][prev].next(ofp.id);\n      } else {\n        ofp.local = ofp.local.best(ofp.id);\n      }\n\n      /* * If the offer is not the last one, we update its successor. */\n      if (next != 0) {\n        offers[ofp.outbound_tkn][ofp.inbound_tkn][next] = offers[ofp.outbound_tkn][ofp.inbound_tkn][next].prev(ofp.id);\n      }\n\n      /* * Recall that in this branch, the offer has changed location, or is not currently in the book. If the offer is not new and already in the book, we must remove it from its previous location by stitching its previous prev/next. */\n      if (update && isLive(ofp.oldOffer)) {\n        ofp.local = stitchOffers(\n          ofp.outbound_tkn,\n          ofp.inbound_tkn,\n          ofp.oldOffer.prev(),\n          ofp.oldOffer.next(),\n          ofp.local\n        );\n      }\n    }\n\n    /* With the `prev`/`next` in hand, we finally store the offer in the `offers` map. */\n    P.Offer.t ofr = P.Offer.pack({\n      __prev: prev,\n      __next: next,\n      __wants: ofp.wants,\n      __gives: ofp.gives\n    });\n    offers[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = ofr;\n  }}\n\n  /* ## Find Position */\n  /* `findPosition` takes a price in the form of a (`ofp.wants`,`ofp.gives`) pair, an offer id (`ofp.pivotId`) and walks the book from that offer (backward or forward) until the right position for the price is found. The position is returned as a `(prev,next)` pair, with `prev` or `next` at 0 to mark the beginning/end of the book (no offer ever has id 0).\n\n  If prices are equal, `findPosition` will put the newest offer last. */\n  function findPosition(OfferPack memory ofp)\n    internal\n    view\n    returns (uint, uint)\n  { unchecked {\n    uint prevId;\n    uint nextId;\n    uint pivotId = ofp.pivotId;\n    /* Get `pivot`, optimizing for the case where pivot info is already known */\n    P.Offer.t pivot = pivotId == ofp.id\n      ? ofp.oldOffer\n      : offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\n\n    /* In case pivotId is not an active offer, it is unusable (since it is out of the book). We default to the current best offer. If the book is empty pivot will be 0. That is handled through a test in the `better` comparison function. */\n    if (!isLive(pivot)) {\n      pivotId = ofp.local.best();\n      pivot = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\n    }\n\n    /* * Pivot is better than `wants/gives`, we follow `next`. */\n    if (better(ofp, pivot, pivotId)) {\n      P.Offer.t pivotNext;\n      while (pivot.next() != 0) {\n        uint pivotNextId = pivot.next();\n        pivotNext = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotNextId];\n        if (better(ofp, pivotNext, pivotNextId)) {\n          pivotId = pivotNextId;\n          pivot = pivotNext;\n        } else {\n          break;\n        }\n      }\n      // gets here on empty book\n      (prevId, nextId) = (pivotId, pivot.next());\n\n      /* * Pivot is strictly worse than `wants/gives`, we follow `prev`. */\n    } else {\n      P.Offer.t pivotPrev;\n      while (pivot.prev() != 0) {\n        uint pivotPrevId = pivot.prev();\n        pivotPrev = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotPrevId];\n        if (better(ofp, pivotPrev, pivotPrevId)) {\n          break;\n        } else {\n          pivotId = pivotPrevId;\n          pivot = pivotPrev;\n        }\n      }\n\n      (prevId, nextId) = (pivot.prev(), pivotId);\n    }\n\n    return (\n      prevId == ofp.id ? ofp.oldOffer.prev() : prevId,\n      nextId == ofp.id ? ofp.oldOffer.next() : nextId\n    );\n  }}\n\n  /* ## Better */\n  /* The utility method `better` takes an offer represented by `ofp` and another represented by `offer1`. It returns true iff `offer1` is better or as good as `ofp`.\n    \"better\" is defined on the lexicographic order $\\textrm{price} \\times_{\\textrm{lex}} \\textrm{density}^{-1}$. This means that for the same price, offers that deliver more volume per gas are taken first.\n\n      In addition to `offer1`, we also provide its id, `offerId1` in order to save gas. If necessary (ie. if the prices `wants1/gives1` and `wants2/gives2` are the same), we read storage to get `gasreq1` at `offerDetails[...][offerId1]. */\n  function better(\n    OfferPack memory ofp,\n    P.Offer.t offer1,\n    uint offerId1\n  ) internal view returns (bool) { unchecked {\n    if (offerId1 == 0) {\n      /* Happens on empty book. Returning `false` would work as well due to specifics of `findPosition` but true is more consistent. Here we just want to avoid reading `offerDetail[...][0]` for nothing. */\n      return true;\n    }\n    uint wants1 = offer1.wants();\n    uint gives1 = offer1.gives();\n    uint wants2 = ofp.wants;\n    uint gives2 = ofp.gives;\n    uint weight1 = wants1 * gives2;\n    uint weight2 = wants2 * gives1;\n    if (weight1 == weight2) {\n      uint gasreq1 = \n          offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][offerId1].gasreq();\n      uint gasreq2 = ofp.gasreq;\n      return (gives1 * gasreq2 >= gives2 * gasreq1);\n    } else {\n      return weight1 < weight2;\n    }\n  }}\n}\n"
    },
    "contracts/MgvOfferTakingWithPermit.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferTakingWithPermit.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {HasMgvEvents} from \"./MgvLib.sol\";\n\nimport {MgvOfferTaking} from \"./MgvOfferTaking.sol\";\n\nabstract contract MgvOfferTakingWithPermit is MgvOfferTaking {\n  /* Takers may provide allowances on specific pairs, so other addresses can execute orders in their name. Allowance may be set using the usual `approve` function, or through an [EIP712](https://eips.ethereum.org/EIPS/eip-712) `permit`.\n\n  The mapping is `outbound_tkn => inbound_tkn => owner => spender => allowance` */\n  mapping(address => mapping(address => mapping(address => mapping(address => uint))))\n    public allowances;\n  /* Storing nonces avoids replay attacks. */\n  mapping(address => uint) public nonces;\n  /* Following [EIP712](https://eips.ethereum.org/EIPS/eip-712), structured data signing has `keccak256(\"Permit(address outbound_tkn,address inbound_tkn,address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")` in its prefix. */\n  bytes32 public constant PERMIT_TYPEHASH =\n    0xb7bf278e51ab1478b10530c0300f911d9ed3562fc93ab5e6593368fe23c077a2;\n  /* Initialized in the constructor, `DOMAIN_SEPARATOR` avoids cross-application permit reuse. */\n  bytes32 public immutable DOMAIN_SEPARATOR;\n\n  constructor(string memory contractName) {\n    /* Initialize [EIP712](https://eips.ethereum.org/EIPS/eip-712) `DOMAIN_SEPARATOR`. */\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(contractName)),\n        keccak256(bytes(\"1\")),\n        block.chainid,\n        address(this)\n      )\n    );\n  }\n\n  /* # Delegation public functions */\n\n  /* Adapted from [Uniswap v2 contract](https://github.com/Uniswap/uniswap-v2-core/blob/55ae25109b7918565867e5c39f1e84b7edd19b2a/contracts/UniswapV2ERC20.sol#L81) */\n  function permit(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    unchecked {\n      require(deadline >= block.timestamp, \"mgv/permit/expired\");\n\n      uint nonce = nonces[owner]++;\n      bytes32 digest = keccak256(\n        abi.encodePacked(\n          \"\\x19\\x01\",\n          DOMAIN_SEPARATOR,\n          keccak256(\n            abi.encode(\n              PERMIT_TYPEHASH,\n              outbound_tkn,\n              inbound_tkn,\n              owner,\n              spender,\n              value,\n              nonce,\n              deadline\n            )\n          )\n        )\n      );\n      address recoveredAddress = ecrecover(digest, v, r, s);\n      require(\n        recoveredAddress != address(0) && recoveredAddress == owner,\n        \"mgv/permit/invalidSignature\"\n      );\n\n      allowances[outbound_tkn][inbound_tkn][owner][spender] = value;\n      emit Approval(outbound_tkn, inbound_tkn, owner, spender, value);\n    }\n  }\n\n  function approve(\n    address outbound_tkn,\n    address inbound_tkn,\n    address spender,\n    uint value\n  ) external returns (bool) {\n    unchecked {\n      allowances[outbound_tkn][inbound_tkn][msg.sender][spender] = value;\n      emit Approval(outbound_tkn, inbound_tkn, msg.sender, spender, value);\n      return true;\n    }\n  }\n\n  /* The delegate version of `marketOrder` is `marketOrderFor`, which takes a `taker` address as additional argument. Penalties incurred by failed offers will still be sent to `msg.sender`, but exchanged amounts will be transferred from and to the `taker`. If the `msg.sender`'s allowance for the given `outbound_tkn`,`inbound_tkn` and `taker` are strictly less than the total amount eventually spent by `taker`, the call will fail. */\n\n  /* *Note:* `marketOrderFor` and `snipesFor` may emit ERC20 `Transfer` events of value 0 from `taker`, but that's already the case with common ERC20 implementations. */\n  function marketOrderFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint takerGot,\n      uint takerGave,\n      uint bounty\n    )\n  {\n    unchecked {\n      (takerGot, takerGave, bounty) = generalMarketOrder(\n        outbound_tkn,\n        inbound_tkn,\n        takerWants,\n        takerGives,\n        fillWants,\n        taker\n      );\n      /* The sender's allowance is verified after the order complete so that `takerGave` rather than `takerGives` is checked against the allowance. The former may be lower. */\n      deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\n    }\n  }\n\n  /* The delegate version of `snipes` is `snipesFor`, which takes a `taker` address as additional argument. */\n  function snipesFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint bounty\n    )\n  {\n    unchecked {\n      (successes, takerGot, takerGave, bounty) = generalSnipes(\n        outbound_tkn,\n        inbound_tkn,\n        targets,\n        fillWants,\n        taker\n      );\n      /* The sender's allowance is verified after the order complete so that the actual amounts are checked against the allowance, instead of the declared `takerGives`. The former may be lower.\n    \n    An immediate consequence is that any funds availale to Mangrove through `approve` can be used to clean offers. After a `snipesFor` where all offers have failed, all token transfers have been reverted, so `takerGave=0` and the check will succeed -- but the sender will still have received the bounty of the failing offers. */\n      deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\n    }\n  }\n\n  /* # Misc. low-level functions */\n\n  /* Used by `*For` functions, its both checks that `msg.sender` was allowed to use the taker's funds, and decreases the former's allowance. */\n  function deductSenderAllowance(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    uint amount\n  ) internal {\n    unchecked {\n      uint allowed = allowances[outbound_tkn][inbound_tkn][owner][msg.sender];\n      require(allowed >= amount, \"mgv/lowAllowance\");\n      allowances[outbound_tkn][inbound_tkn][owner][msg.sender] =\n        allowed -\n        amount;\n\n      emit Approval(\n        outbound_tkn,\n        inbound_tkn,\n        owner,\n        msg.sender,\n        allowed - amount\n      );\n    }\n  }\n}\n"
    },
    "contracts/MgvGovernable.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvGovernable.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {HasMgvEvents, P} from \"./MgvLib.sol\";\nimport {MgvRoot} from \"./MgvRoot.sol\";\n\ncontract MgvGovernable is MgvRoot {\n  // using P.Offer for P.Offer.t;\n  // using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  /* The `governance` address. Governance is the only address that can configure parameters. */\n  address public governance;\n\n  constructor(\n    address _governance,\n    uint _gasprice,\n    uint gasmax\n  ) MgvRoot() { unchecked {\n    emit NewMgv();\n\n    /* Initially, governance is open to anyone. */\n\n    /* Initialize vault to governance address, and set initial gasprice and gasmax. */\n    setVault(_governance);\n    setGasprice(_gasprice);\n    setGasmax(gasmax);\n    /* Initialize governance to `_governance` after parameter setting. */\n    setGovernance(_governance);\n  }}\n\n  /* ## `authOnly` check */\n\n  function authOnly() internal view { unchecked {\n    require(\n      msg.sender == governance ||\n        msg.sender == address(this) ||\n        governance == address(0),\n      \"mgv/unauthorized\"\n    );\n  }}\n\n  /* # Set configuration and Mangrove state */\n\n  /* ## Locals */\n  /* ### `active` */\n  function activate(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee,\n    uint density,\n    uint offer_gasbase\n  ) public { unchecked {\n    authOnly();\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].active(true);\n    emit SetActive(outbound_tkn, inbound_tkn, true);\n    setFee(outbound_tkn, inbound_tkn, fee);\n    setDensity(outbound_tkn, inbound_tkn, density);\n    setGasbase(outbound_tkn, inbound_tkn, offer_gasbase);\n  }}\n\n  function deactivate(address outbound_tkn, address inbound_tkn) public {\n    authOnly();\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].active(false);\n    emit SetActive(outbound_tkn, inbound_tkn, false);\n  }\n\n  /* ### `fee` */\n  function setFee(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee\n  ) public { unchecked {\n    authOnly();\n    /* `fee` is in basis points, i.e. in percents of a percent. */\n    require(fee <= 500, \"mgv/config/fee/<=500\"); // at most 5%\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].fee(fee);\n    emit SetFee(outbound_tkn, inbound_tkn, fee);\n  }}\n\n  /* ### `density` */\n  /* Useless if `global.useOracle != 0` */\n  function setDensity(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint density\n  ) public { unchecked {\n    authOnly();\n\n    require(checkDensity(density), \"mgv/config/density/112bits\");\n    //+clear+\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].density(density);\n    emit SetDensity(outbound_tkn, inbound_tkn, density);\n  }}\n\n  /* ### `gasbase` */\n  function setGasbase(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offer_gasbase\n  ) public { unchecked {\n    authOnly();\n    /* Checking the size of `offer_gasbase` is necessary to prevent a) data loss when copied to an `OfferDetail` struct, and b) overflow when used in calculations. */\n    require(\n      uint24(offer_gasbase) == offer_gasbase,\n      \"mgv/config/offer_gasbase/24bits\"\n    );\n    //+clear+\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].offer_gasbase(offer_gasbase);\n    emit SetGasbase(outbound_tkn, inbound_tkn, offer_gasbase);\n  }}\n\n  /* ## Globals */\n  /* ### `kill` */\n  function kill() public { unchecked {\n    authOnly();\n    internal_global = internal_global.dead(true);\n    emit Kill();\n  }}\n\n  /* ### `gasprice` */\n  /* Useless if `global.useOracle is != 0` */\n  function setGasprice(uint gasprice) public { unchecked {\n    authOnly();\n    require(checkGasprice(gasprice), \"mgv/config/gasprice/16bits\");\n\n    //+clear+\n\n    internal_global = internal_global.gasprice(gasprice);\n    emit SetGasprice(gasprice);\n  }}\n\n  /* ### `gasmax` */\n  function setGasmax(uint gasmax) public { unchecked {\n    authOnly();\n    /* Since any new `gasreq` is bounded above by `config.gasmax`, this check implies that all offers' `gasreq` is 24 bits wide at most. */\n    require(uint24(gasmax) == gasmax, \"mgv/config/gasmax/24bits\");\n    //+clear+\n    internal_global = internal_global.gasmax(gasmax);\n    emit SetGasmax(gasmax);\n  }}\n\n  /* ### `governance` */\n  function setGovernance(address governanceAddress) public { unchecked {\n    authOnly();\n    require(governanceAddress != address(0),\"mgv/config/gov/not0\");\n    governance = governanceAddress;\n    emit SetGovernance(governanceAddress);\n  }}\n\n  /* ### `vault` */\n  function setVault(address vaultAddress) public { unchecked {\n    authOnly();\n    vault = vaultAddress;\n    emit SetVault(vaultAddress);\n  }}\n\n  /* ### `monitor` */\n  function setMonitor(address monitor) public { unchecked {\n    authOnly();\n    internal_global = internal_global.monitor(monitor);\n    emit SetMonitor(monitor);\n  }}\n\n  /* ### `useOracle` */\n  function setUseOracle(bool useOracle) public { unchecked {\n    authOnly();\n    internal_global = internal_global.useOracle(useOracle);\n    emit SetUseOracle(useOracle);\n  }}\n\n  /* ### `notify` */\n  function setNotify(bool notify) public { unchecked {\n    authOnly();\n    internal_global = internal_global.notify(notify);\n    emit SetNotify(notify);\n  }}\n}\n"
    },
    "contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// IERC20.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint);\n\n  function approve(address spender, uint amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n  /// for wETH contract\n  function deposit() external payable;\n\n  function withdraw(uint) external;\n\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/MgvPack.sol": {
      "content": "pragma solidity ^0.8.10;\n\n// SPDX-License-Identifier: Unlicense\n\n// MgvPack.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* ************************************************** *\n            GENERATED FILE. DO NOT EDIT.\n * ************************************************** */\n\n/* since you can't convert bool to uint in an expression without conditionals,\n * we add a file-level function and rely on compiler optimization\n */\nfunction uint_of_bool(bool b) pure returns (uint u) {\n  assembly { u := b }\n}\n\n// fields are of the form [name,bits,type]\n\n// Can't put all structs under a 'Structs' library due to bad variable shadowing rules in Solidity\n// (would generate lots of spurious warnings about a nameclash between Structs.Offer and library Offer for instance)\n// struct_defs are of the form [name,obj]\nstruct OfferStruct {\n  uint prev;\n  uint next;\n  uint wants;\n  uint gives;\n}\nstruct OfferDetailStruct {\n  address maker;\n  uint gasreq;\n  uint offer_gasbase;\n  uint gasprice;\n}\nstruct GlobalStruct {\n  address monitor;\n  bool useOracle;\n  bool notify;\n  uint gasprice;\n  uint gasmax;\n  bool dead;\n}\nstruct LocalStruct {\n  bool active;\n  uint fee;\n  uint density;\n  uint offer_gasbase;\n  bool lock;\n  uint best;\n  uint last;\n}\n\nlibrary Offer {\n  //some type safety for each struct\n  type t is uint;\n\n  uint constant prev_bits  = 32;\n  uint constant next_bits  = 32;\n  uint constant wants_bits = 96;\n  uint constant gives_bits = 96;\n\n  uint constant prev_before  = 0;\n  uint constant next_before  = prev_before  + prev_bits ;\n  uint constant wants_before = next_before  + next_bits ;\n  uint constant gives_before = wants_before + wants_bits;\n\n  uint constant prev_mask  = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  uint constant next_mask  = 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff;\n  uint constant wants_mask = 0xffffffffffffffff000000000000000000000000ffffffffffffffffffffffff;\n  uint constant gives_mask = 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000;\n\n  function to_struct(t __packed) internal pure returns (OfferStruct memory __s) { unchecked {\n    __s.prev = (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\n    __s.next = (t.unwrap(__packed) << next_before) >> (256-next_bits);\n    __s.wants = (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\n    __s.gives = (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\n  }}\n\n  function t_of_struct(OfferStruct memory __s) internal pure returns (t) { unchecked {\n    return pack(__s.prev, __s.next, __s.wants, __s.gives);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function pack(uint __prev, uint __next, uint __wants, uint __gives) internal pure returns (t) { unchecked {\n    return t.wrap(((((0\n                  | ((__prev << (256-prev_bits)) >> prev_before))\n                  | ((__next << (256-next_bits)) >> next_before))\n                  | ((__wants << (256-wants_bits)) >> wants_before))\n                  | ((__gives << (256-gives_bits)) >> gives_before)));\n  }}\n\n  function unpack(t __packed) internal pure returns (uint __prev, uint __next, uint __wants, uint __gives) { unchecked {\n    __prev = (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\n    __next = (t.unwrap(__packed) << next_before) >> (256-next_bits);\n    __wants = (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\n    __gives = (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\n  }}\n\n  function prev(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\n  }}\n  function prev(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & prev_mask)\n                  | ((val << (256-prev_bits) >> prev_before)));\n  }}\n  function next(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << next_before) >> (256-next_bits);\n  }}\n  function next(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & next_mask)\n                  | ((val << (256-next_bits) >> next_before)));\n  }}\n  function wants(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\n  }}\n  function wants(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & wants_mask)\n                  | ((val << (256-wants_bits) >> wants_before)));\n  }}\n  function gives(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\n  }}\n  function gives(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gives_mask)\n                  | ((val << (256-gives_bits) >> gives_before)));\n  }}\n}\n\nlibrary OfferDetail {\n  //some type safety for each struct\n  type t is uint;\n\n  uint constant maker_bits         = 160;\n  uint constant gasreq_bits        = 24;\n  uint constant offer_gasbase_bits = 24;\n  uint constant gasprice_bits      = 16;\n\n  uint constant maker_before         = 0;\n  uint constant gasreq_before        = maker_before         + maker_bits        ;\n  uint constant offer_gasbase_before = gasreq_before        + gasreq_bits       ;\n  uint constant gasprice_before      = offer_gasbase_before + offer_gasbase_bits;\n\n  uint constant maker_mask         = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\n  uint constant gasreq_mask        = 0xffffffffffffffffffffffffffffffffffffffff000000ffffffffffffffffff;\n  uint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffffff;\n  uint constant gasprice_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff;\n\n  function to_struct(t __packed) internal pure returns (OfferDetailStruct memory __s) { unchecked {\n    __s.maker = address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\n    __s.gasreq = (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\n    __s.offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __s.gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n\n  function t_of_struct(OfferDetailStruct memory __s) internal pure returns (t) { unchecked {\n    return pack(__s.maker, __s.gasreq, __s.offer_gasbase, __s.gasprice);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function pack(address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) internal pure returns (t) { unchecked {\n    return t.wrap(((((0\n                  | ((uint(uint160(__maker)) << (256-maker_bits)) >> maker_before))\n                  | ((__gasreq << (256-gasreq_bits)) >> gasreq_before))\n                  | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\n                  | ((__gasprice << (256-gasprice_bits)) >> gasprice_before)));\n  }}\n\n  function unpack(t __packed) internal pure returns (address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) { unchecked {\n    __maker = address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\n    __gasreq = (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\n    __offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n\n  function maker(t __packed) internal pure returns(address) { unchecked {\n    return address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\n  }}\n  function maker(t __packed,address val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & maker_mask)\n                  | ((uint(uint160(val)) << (256-maker_bits) >> maker_before)));\n  }}\n  function gasreq(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\n  }}\n  function gasreq(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasreq_mask)\n                  | ((val << (256-gasreq_bits) >> gasreq_before)));\n  }}\n  function offer_gasbase(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n  }}\n  function offer_gasbase(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & offer_gasbase_mask)\n                  | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\n  }}\n  function gasprice(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n  function gasprice(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasprice_mask)\n                  | ((val << (256-gasprice_bits) >> gasprice_before)));\n  }}\n}\n\nlibrary Global {\n  //some type safety for each struct\n  type t is uint;\n\n  uint constant monitor_bits   = 160;\n  uint constant useOracle_bits = 8;\n  uint constant notify_bits    = 8;\n  uint constant gasprice_bits  = 16;\n  uint constant gasmax_bits    = 24;\n  uint constant dead_bits      = 8;\n\n  uint constant monitor_before   = 0;\n  uint constant useOracle_before = monitor_before   + monitor_bits  ;\n  uint constant notify_before    = useOracle_before + useOracle_bits;\n  uint constant gasprice_before  = notify_before    + notify_bits   ;\n  uint constant gasmax_before    = gasprice_before  + gasprice_bits ;\n  uint constant dead_before      = gasmax_before    + gasmax_bits   ;\n\n  uint constant monitor_mask   = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\n  uint constant useOracle_mask = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\n  uint constant notify_mask    = 0xffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff;\n  uint constant gasprice_mask  = 0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff;\n  uint constant gasmax_mask    = 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff;\n  uint constant dead_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffff;\n\n  function to_struct(t __packed) internal pure returns (GlobalStruct memory __s) { unchecked {\n    __s.monitor = address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\n    __s.useOracle = (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\n    __s.notify = (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\n    __s.gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n    __s.gasmax = (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\n    __s.dead = (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\n  }}\n\n  function t_of_struct(GlobalStruct memory __s) internal pure returns (t) { unchecked {\n    return pack(__s.monitor, __s.useOracle, __s.notify, __s.gasprice, __s.gasmax, __s.dead);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function pack(address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) internal pure returns (t) { unchecked {\n    return t.wrap(((((((0\n                  | ((uint(uint160(__monitor)) << (256-monitor_bits)) >> monitor_before))\n                  | ((uint_of_bool(__useOracle) << (256-useOracle_bits)) >> useOracle_before))\n                  | ((uint_of_bool(__notify) << (256-notify_bits)) >> notify_before))\n                  | ((__gasprice << (256-gasprice_bits)) >> gasprice_before))\n                  | ((__gasmax << (256-gasmax_bits)) >> gasmax_before))\n                  | ((uint_of_bool(__dead) << (256-dead_bits)) >> dead_before)));\n  }}\n\n  function unpack(t __packed) internal pure returns (address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) { unchecked {\n    __monitor = address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\n    __useOracle = (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\n    __notify = (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\n    __gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n    __gasmax = (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\n    __dead = (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\n  }}\n\n  function monitor(t __packed) internal pure returns(address) { unchecked {\n    return address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\n  }}\n  function monitor(t __packed,address val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & monitor_mask)\n                  | ((uint(uint160(val)) << (256-monitor_bits) >> monitor_before)));\n  }}\n  function useOracle(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\n  }}\n  function useOracle(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & useOracle_mask)\n                  | ((uint_of_bool(val) << (256-useOracle_bits) >> useOracle_before)));\n  }}\n  function notify(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\n  }}\n  function notify(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & notify_mask)\n                  | ((uint_of_bool(val) << (256-notify_bits) >> notify_before)));\n  }}\n  function gasprice(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n  function gasprice(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasprice_mask)\n                  | ((val << (256-gasprice_bits) >> gasprice_before)));\n  }}\n  function gasmax(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\n  }}\n  function gasmax(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasmax_mask)\n                  | ((val << (256-gasmax_bits) >> gasmax_before)));\n  }}\n  function dead(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\n  }}\n  function dead(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & dead_mask)\n                  | ((uint_of_bool(val) << (256-dead_bits) >> dead_before)));\n  }}\n}\n\nlibrary Local {\n  //some type safety for each struct\n  type t is uint;\n\n  uint constant active_bits        = 8;\n  uint constant fee_bits           = 16;\n  uint constant density_bits       = 112;\n  uint constant offer_gasbase_bits = 24;\n  uint constant lock_bits          = 8;\n  uint constant best_bits          = 32;\n  uint constant last_bits          = 32;\n\n  uint constant active_before        = 0;\n  uint constant fee_before           = active_before        + active_bits       ;\n  uint constant density_before       = fee_before           + fee_bits          ;\n  uint constant offer_gasbase_before = density_before       + density_bits      ;\n  uint constant lock_before          = offer_gasbase_before + offer_gasbase_bits;\n  uint constant best_before          = lock_before          + lock_bits         ;\n  uint constant last_before          = best_before          + best_bits         ;\n\n  uint constant active_mask        = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  uint constant fee_mask           = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  uint constant density_mask       = 0xffffff0000000000000000000000000000ffffffffffffffffffffffffffffff;\n  uint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffff000000ffffffffffffffffffffffff;\n  uint constant lock_mask          = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\n  uint constant best_mask          = 0xffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffffff;\n  uint constant last_mask          = 0xffffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffff;\n\n  function to_struct(t __packed) internal pure returns (LocalStruct memory __s) { unchecked {\n    __s.active = (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\n    __s.fee = (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\n    __s.density = (t.unwrap(__packed) << density_before) >> (256-density_bits);\n    __s.offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __s.lock = (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\n    __s.best = (t.unwrap(__packed) << best_before) >> (256-best_bits);\n    __s.last = (t.unwrap(__packed) << last_before) >> (256-last_bits);\n  }}\n\n  function t_of_struct(LocalStruct memory __s) internal pure returns (t) { unchecked {\n    return pack(__s.active, __s.fee, __s.density, __s.offer_gasbase, __s.lock, __s.best, __s.last);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function pack(bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) internal pure returns (t) { unchecked {\n    return t.wrap((((((((0\n                  | ((uint_of_bool(__active) << (256-active_bits)) >> active_before))\n                  | ((__fee << (256-fee_bits)) >> fee_before))\n                  | ((__density << (256-density_bits)) >> density_before))\n                  | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\n                  | ((uint_of_bool(__lock) << (256-lock_bits)) >> lock_before))\n                  | ((__best << (256-best_bits)) >> best_before))\n                  | ((__last << (256-last_bits)) >> last_before)));\n  }}\n\n  function unpack(t __packed) internal pure returns (bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) { unchecked {\n    __active = (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\n    __fee = (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\n    __density = (t.unwrap(__packed) << density_before) >> (256-density_bits);\n    __offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __lock = (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\n    __best = (t.unwrap(__packed) << best_before) >> (256-best_bits);\n    __last = (t.unwrap(__packed) << last_before) >> (256-last_bits);\n  }}\n\n  function active(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\n  }}\n  function active(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & active_mask)\n                  | ((uint_of_bool(val) << (256-active_bits) >> active_before)));\n  }}\n  function fee(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\n  }}\n  function fee(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & fee_mask)\n                  | ((val << (256-fee_bits) >> fee_before)));\n  }}\n  function density(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << density_before) >> (256-density_bits);\n  }}\n  function density(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & density_mask)\n                  | ((val << (256-density_bits) >> density_before)));\n  }}\n  function offer_gasbase(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n  }}\n  function offer_gasbase(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & offer_gasbase_mask)\n                  | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\n  }}\n  function lock(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\n  }}\n  function lock(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & lock_mask)\n                  | ((uint_of_bool(val) << (256-lock_bits) >> lock_before)));\n  }}\n  function best(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << best_before) >> (256-best_bits);\n  }}\n  function best(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & best_mask)\n                  | ((val << (256-best_bits) >> best_before)));\n  }}\n  function last(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << last_before) >> (256-last_bits);\n  }}\n  function last(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & last_mask)\n                  | ((val << (256-last_bits) >> last_before)));\n  }}\n}\n"
    },
    "contracts/MgvHasOffers.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvHasOffers.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor,P} from \"./MgvLib.sol\";\nimport {MgvRoot} from \"./MgvRoot.sol\";\n\n/* `MgvHasOffers` contains the state variables and functions common to both market-maker operations and market-taker operations. Mostly: storing offers, removing them, updating market makers' provisions. */\ncontract MgvHasOffers is MgvRoot {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Local for P.Local.t;\n  /* # State variables */\n  /* Given a `outbound_tkn`,`inbound_tkn` pair, the mappings `offers` and `offerDetails` associate two 256 bits words to each offer id. Those words encode information detailed in [`structs.js`](#structs.js).\n\n     The mappings are `outbound_tkn => inbound_tkn => offerId => P.Offer.t|P.OfferDetail.t`.\n   */\n  mapping(address => mapping(address => mapping(uint => P.Offer.t)))\n    public offers;\n  mapping(address => mapping(address => mapping(uint => P.OfferDetail.t)))\n    public offerDetails;\n\n  /* Makers provision their possible penalties in the `balanceOf` mapping.\n\n       Offers specify the amount of gas they require for successful execution ([`gasreq`](#structs.js/gasreq)). To minimize book spamming, market makers must provision a *penalty*, which depends on their `gasreq` and on the pair's [`offer_gasbase`](#structs.js/gasbase). This provision is deducted from their `balanceOf`. If an offer fails, part of that provision is given to the taker, as retribution. The exact amount depends on the gas used by the offer before failing.\n\n       The Mangrove keeps track of their available balance in the `balanceOf` map, which is decremented every time a maker creates a new offer, and may be modified on offer updates/cancelations/takings.\n     */\n  mapping(address => uint) public balanceOf;\n\n  /* # Read functions */\n  /* Convenience function to get best offer of the given pair */\n  function best(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint)\n  { unchecked {\n    P.Local.t local = locals[outbound_tkn][inbound_tkn];\n    return local.best();\n  }}\n\n  /* Returns information about an offer in ABI-compatible structs. Do not use internally, would be a huge memory-copying waste. Use `offers[outbound_tkn][inbound_tkn]` and `offerDetails[outbound_tkn][inbound_tkn]` instead. */\n  function offerInfo(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  ) external view returns (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) { unchecked {\n\n    P.Offer.t _offer = offers[outbound_tkn][inbound_tkn][offerId];\n    offer = _offer.to_struct();\n\n    P.OfferDetail.t _offerDetail = offerDetails[outbound_tkn][inbound_tkn][offerId];\n    offerDetail = _offerDetail.to_struct();\n  }}\n\n  /* # Provision debit/credit utility functions */\n  /* `balanceOf` is in wei of ETH. */\n\n  function debitWei(address maker, uint amount) internal { unchecked {\n    uint makerBalance = balanceOf[maker];\n    require(makerBalance >= amount, \"mgv/insufficientProvision\");\n    balanceOf[maker] = makerBalance - amount;\n    emit Debit(maker, amount);\n  }}\n\n  function creditWei(address maker, uint amount) internal { unchecked {\n    balanceOf[maker] += amount;\n    emit Credit(maker, amount);\n  }}\n\n  /* # Misc. low-level functions */\n  /* ## Offer deletion */\n\n  /* When an offer is deleted, it is marked as such by setting `gives` to 0. Note that provision accounting in the Mangrove aims to minimize writes. Each maker `fund`s the Mangrove to increase its balance. When an offer is created/updated, we compute how much should be reserved to pay for possible penalties. That amount can always be recomputed with `offerDetail.gasprice * (offerDetail.gasreq + offerDetail.offer_gasbase)`. The balance is updated to reflect the remaining available ethers.\n\n     Now, when an offer is deleted, the offer can stay provisioned, or be `deprovision`ed. In the latter case, we set `gasprice` to 0, which induces a provision of 0. All code calling `dirtyDeleteOffer` with `deprovision` set to `true` must be careful to correctly account for where that provision is going (back to the maker's `balanceOf`, or sent to a taker as compensation). */\n  function dirtyDeleteOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    P.Offer.t offer,\n    P.OfferDetail.t offerDetail,\n    bool deprovision\n  ) internal { unchecked {\n    offer = offer.gives(0);\n    if (deprovision) {\n      offerDetail = offerDetail.gasprice(0);\n    }\n    offers[outbound_tkn][inbound_tkn][offerId] = offer;\n    offerDetails[outbound_tkn][inbound_tkn][offerId] = offerDetail;\n  }}\n\n  /* ## Stitching the orderbook */\n\n  /* Connect the offers `betterId` and `worseId` through their `next`/`prev` pointers. For more on the book structure, see [`structs.js`](#structs.js). Used after executing an offer (or a segment of offers), after removing an offer, or moving an offer.\n\n  **Warning**: calling with `betterId = 0` will set `worseId` as the best. So with `betterId = 0` and `worseId = 0`, it sets the book to empty and loses track of existing offers.\n\n  **Warning**: may make memory copy of `local.best` stale. Returns new `local`. */\n  function stitchOffers(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint betterId,\n    uint worseId,\n    P.Local.t local\n  ) internal returns (P.Local.t) { unchecked {\n    if (betterId != 0) {\n      offers[outbound_tkn][inbound_tkn][betterId] = offers[outbound_tkn][inbound_tkn][betterId].next(worseId);\n    } else {\n      local = local.best(worseId);\n    }\n\n    if (worseId != 0) {\n      offers[outbound_tkn][inbound_tkn][worseId] = offers[outbound_tkn][inbound_tkn][worseId].prev(betterId);\n    }\n\n    return local;\n  }}\n\n  /* ## Check offer is live */\n  /* Check whether an offer is 'live', that is: inserted in the order book. The Mangrove holds a `outbound_tkn => inbound_tkn => id => P.Offer.t` mapping in storage. Offer ids that are not yet assigned or that point to since-deleted offer will point to an offer with `gives` field at 0. */\n  function isLive(P.Offer.t offer) public pure returns (bool) { unchecked {\n    return offer.gives() > 0;\n  }}\n}\n"
    },
    "contracts/MgvRoot.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvRoot.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* `MgvRoot` and its descendants describe an orderbook-based exchange (\"the Mangrove\") where market makers *do not have to provision their offer*. See `structs.js` for a longer introduction. In a nutshell: each offer created by a maker specifies an address (`maker`) to call upon offer execution by a taker. In the normal mode of operation, the Mangrove transfers the amount to be paid by the taker to the maker, calls the maker, attempts to transfer the amount promised by the maker to the taker, and reverts if it cannot.\n\n   There is one Mangrove contract that manages all tradeable pairs. This reduces deployment costs for new pairs and lets market makers have all their provision for all pairs in the same place.\n\n   The interaction map between the different actors is as follows:\n   <img src=\"./contactMap.png\" width=\"190%\"></img>\n\n   The sequence diagram of a market order is as follows:\n   <img src=\"./sequenceChart.png\" width=\"190%\"></img>\n\n   There is a secondary mode of operation in which the _maker_ flashloans the sold amount to the taker.\n\n   The Mangrove contract is `abstract` and accomodates both modes. Two contracts, `Mangrove` and `InvertedMangrove` inherit from it, one per mode of operation.\n\n   The contract structure is as follows:\n   <img src=\"./modular_mangrove.svg\" width=\"180%\"> </img>\n */\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor, P} from \"./MgvLib.sol\";\n\n/* `MgvRoot` contains state variables used everywhere in the operation of the Mangrove and their related function. */\ncontract MgvRoot is HasMgvEvents {\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n\n\n  /* # State variables */\n  //+clear+\n  /* The `vault` address. If a pair has fees >0, those fees are sent to the vault. */\n  address public vault;\n\n  /* Global mgv configuration, encoded in a 256 bits word. The information encoded is detailed in [`structs.js`](#structs.js). */\n  P.Global.t internal internal_global;\n  /* Configuration mapping for each token pair of the form `outbound_tkn => inbound_tkn => P.Local.t`. The structure of each `P.Local.t` value is detailed in [`structs.js`](#structs.js). It fits in one word. */\n  mapping(address => mapping(address => P.Local.t)) internal locals;\n\n  /* Checking the size of `density` is necessary to prevent overflow when `density` is used in calculations. */\n  function checkDensity(uint density) internal pure returns (bool) { unchecked {\n    return uint112(density) == density;\n  }}\n\n  /* Checking the size of `gasprice` is necessary to prevent a) data loss when `gasprice` is copied to an `OfferDetail` struct, and b) overflow when `gasprice` is used in calculations. */\n  function checkGasprice(uint gasprice) internal pure returns (bool) { unchecked {\n    return uint16(gasprice) == gasprice;\n  }}\n\n  /* # Configuration Reads */\n  /* Reading the configuration for a pair involves reading the config global to all pairs and the local one. In addition, a global parameter (`gasprice`) and a local one (`density`) may be read from the oracle. */\n  function config(address outbound_tkn, address inbound_tkn)\n    public\n    view\n    returns (P.Global.t _global, P.Local.t _local)\n  { unchecked {\n    _global = internal_global;\n    _local = locals[outbound_tkn][inbound_tkn];\n    if (_global.useOracle()) {\n      (uint gasprice, uint density) = IMgvMonitor(_global.monitor())\n        .read(outbound_tkn, inbound_tkn);\n      if (checkGasprice(gasprice)) {\n        _global = _global.gasprice(gasprice);\n      }\n      if (checkDensity(density)) {\n        _local = _local.density(density);\n      }\n    }\n  }}\n\n  /* Returns the configuration in an ABI-compatible struct. Should not be called internally, would be a huge memory copying waste. Use `config` instead. */\n  function configInfo(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (P.GlobalStruct memory global, P.LocalStruct memory local)\n  { unchecked {\n    (P.Global.t _global, P.Local.t _local) = config(outbound_tkn, inbound_tkn);\n    global = _global.to_struct();\n    local = _local.to_struct();\n  }}\n\n  /* Convenience function to check whether given pair is locked */\n  function locked(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (bool)\n  {\n    P.Local.t local = locals[outbound_tkn][inbound_tkn];\n    return local.lock();\n  }\n\n  /*\n  # Gatekeeping\n\n  Gatekeeping functions are safety checks called in various places.\n  */\n\n  /* `unlockedMarketOnly` protects modifying the market while an order is in progress. Since external contracts are called during orders, allowing reentrancy would, for instance, let a market maker replace offers currently on the book with worse ones. Note that the external contracts _will_ be called again after the order is complete, this time without any lock on the market.  */\n  function unlockedMarketOnly(P.Local.t local) internal pure {\n    require(!local.lock(), \"mgv/reentrancyLocked\");\n  }\n\n  /* <a id=\"Mangrove/definition/liveMgvOnly\"></a>\n     In case of emergency, the Mangrove can be `kill`ed. It cannot be resurrected. When a Mangrove is dead, the following operations are disabled :\n       * Executing an offer\n       * Sending ETH to the Mangrove the normal way. Usual [shenanigans](https://medium.com/@alexsherbuck/two-ways-to-force-ether-into-a-contract-1543c1311c56) are possible.\n       * Creating a new offer\n   */\n  function liveMgvOnly(P.Global.t _global) internal pure {\n    require(!_global.dead(), \"mgv/dead\");\n  }\n\n  /* When the Mangrove is deployed, all pairs are inactive by default (since `locals[outbound_tkn][inbound_tkn]` is 0 by default). Offers on inactive pairs cannot be taken or created. They can be updated and retracted. */\n  function activeMarketOnly(P.Global.t _global, P.Local.t _local) internal pure {\n    liveMgvOnly(_global);\n    require(_local.active(), \"mgv/inactive\");\n  }\n}\n"
    },
    "contracts/MgvOfferTaking.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferTaking.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {IERC20, HasMgvEvents, IMaker, IMgvMonitor, MgvLib as ML, P} from \"./MgvLib.sol\";\nimport {MgvHasOffers} from \"./MgvHasOffers.sol\";\n\nabstract contract MgvOfferTaking is MgvHasOffers {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  /* # MultiOrder struct */\n  /* The `MultiOrder` struct is used by market orders and snipes. Some of its fields are only used by market orders (`initialWants, initialGives`). We need a common data structure for both since low-level calls are shared between market orders and snipes. The struct is helpful in decreasing stack use. */\n  struct MultiOrder {\n    uint initialWants; // used globally by market order, not used by snipes\n    uint initialGives; // used globally by market order, not used by snipes\n    uint totalGot; // used globally by market order, per-offer by snipes\n    uint totalGave; // used globally by market order, per-offer by snipes\n    uint totalPenalty; // used globally\n    address taker; // used globally\n    bool fillWants; // used globally\n  }\n\n  /* # Market Orders */\n\n  /* ## Market Order */\n  //+clear+\n\n  /* A market order specifies a (`outbound_tkn`,`inbound_tkn`) pair, a desired total amount of `outbound_tkn` (`takerWants`), and an available total amount of `inbound_tkn` (`takerGives`). It returns two `uint`s: the total amount of `outbound_tkn` received and the total amount of `inbound_tkn` spent.\n\n     The `takerGives/takerWants` ratio induces a maximum average price that the taker is ready to pay across all offers that will be executed during the market order. It is thus possible to execute an offer with a price worse than the initial (`takerGives`/`takerWants`) ratio given as argument to `marketOrder` if some cheaper offers were executed earlier in the market order.\n\n  The market order stops when the price has become too high, or when the end of the book has been reached, or:\n  * If `fillWants` is true, the market order stops when `takerWants` units of `outbound_tkn` have been obtained. With `fillWants` set to true, to buy a specific volume of `outbound_tkn` at any price, set `takerWants` to the amount desired and `takerGives` to $2^{160}-1$.\n  * If `fillWants` is false, the taker is filling `gives` instead: the market order stops when `takerGives` units of `inbound_tkn` have been sold. With `fillWants` set to false, to sell a specific volume of `inbound_tkn` at any price, set `takerGives` to the amount desired and `takerWants` to $0$. */\n  function marketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants\n  )\n    external\n    returns (\n      uint,\n      uint,\n      uint\n    )\n  { unchecked {\n    return\n      generalMarketOrder(\n        outbound_tkn,\n        inbound_tkn,\n        takerWants,\n        takerGives,\n        fillWants,\n        msg.sender\n      );\n  }}\n\n  /* # General Market Order */\n  //+clear+\n  /* General market orders set up the market order with a given `taker` (`msg.sender` in the most common case). Returns `(totalGot, totalGave)`.\n  Note that the `taker` can be anyone. This is safe when `taker == msg.sender`, but `generalMarketOrder` must not be called with `taker != msg.sender` unless a security check is done after (see [`MgvOfferTakingWithPermit`](#mgvoffertakingwithpermit.sol)`. */\n  function generalMarketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  )\n    internal\n    returns (\n      uint,\n      uint,\n      uint\n    )\n  { unchecked {\n    /* Since amounts stored in offers are 96 bits wide, checking that `takerWants` and `takerGives` fit in 160 bits prevents overflow during the main market order loop. */\n    require(uint160(takerWants) == takerWants, \"mgv/mOrder/takerWants/160bits\");\n    require(uint160(takerGives) == takerGives, \"mgv/mOrder/takerGives/160bits\");\n\n    /* `SingleOrder` is defined in `MgvLib.sol` and holds information for ordering the execution of one offer. */\n    ML.SingleOrder memory sor;\n    sor.outbound_tkn = outbound_tkn;\n    sor.inbound_tkn = inbound_tkn;\n    (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\n    /* Throughout the execution of the market order, the `sor`'s offer id and other parameters will change. We start with the current best offer id (0 if the book is empty). */\n    sor.offerId = sor.local.best();\n    sor.offer = offers[outbound_tkn][inbound_tkn][sor.offerId];\n    /* `sor.wants` and `sor.gives` may evolve, but they are initially however much remains in the market order. */\n    sor.wants = takerWants;\n    sor.gives = takerGives;\n\n    /* `MultiOrder` (defined above) maintains information related to the entire market order. During the order, initial `wants`/`gives` values minus the accumulated amounts traded so far give the amounts that remain to be traded. */\n    MultiOrder memory mor;\n    mor.initialWants = takerWants;\n    mor.initialGives = takerGives;\n    mor.taker = taker;\n    mor.fillWants = fillWants;\n\n    /* For the market order to even start, the market needs to be both active, and not currently protected from reentrancy. */\n    activeMarketOnly(sor.global, sor.local);\n    unlockedMarketOnly(sor.local);\n\n    /* ### Initialization */\n    /* The market order will operate as follows : it will go through offers from best to worse, starting from `offerId`, and: */\n    /* * will maintain remaining `takerWants` and `takerGives` values. The initial `takerGives/takerWants` ratio is the average price the taker will accept. Better prices may be found early in the book, and worse ones later.\n     * will not set `prev`/`next` pointers to their correct locations at each offer taken (this is an optimization enabled by forbidding reentrancy).\n     * after consuming a segment of offers, will update the current `best` offer to be the best remaining offer on the book. */\n\n    /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\n    sor.local = sor.local.lock(true);\n    locals[outbound_tkn][inbound_tkn] = sor.local;\n\n    emit OrderStart();\n\n    /* Call recursive `internalMarketOrder` function.*/\n    internalMarketOrder(mor, sor, true);\n\n    /* Over the course of the market order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\n    sendPenalty(mor.totalPenalty);\n\n    emit OrderComplete(\n      outbound_tkn,\n      inbound_tkn,\n      taker,\n      mor.totalGot,\n      mor.totalGave,\n      mor.totalPenalty\n    );\n\n    //+clear+\n    return (mor.totalGot, mor.totalGave, mor.totalPenalty);\n  }}\n\n  /* ## Internal market order */\n  //+clear+\n  /* `internalMarketOrder` works recursively. Going downward, each successive offer is executed until the market order stops (due to: volume exhausted, bad price, or empty book). Then the [reentrancy lock is lifted](#internalMarketOrder/liftReentrancy). Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book.\n\n    The last argument is a boolean named `proceed`. If an offer was not executed, it means the price has become too high. In that case, we notify the next recursive call that the market order should end. In this initial call, no offer has been executed yet so `proceed` is true. */\n  function internalMarketOrder(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    bool proceed\n  ) internal { unchecked {\n    /* #### Case 1 : End of order */\n    /* We execute the offer currently stored in `sor`. */\n    if (\n      proceed &&\n      (mor.fillWants ? sor.wants > 0 : sor.gives > 0) &&\n      sor.offerId > 0\n    ) {\n      uint gasused; // gas used by `makerExecute`\n      bytes32 makerData; // data returned by maker\n\n      /* <a id=\"MgvOfferTaking/statusCodes\"></a> `mgvData` is an internal Mangrove status code. It may appear in an [`OrderResult`](#MgvLib/OrderResult). Its possible values are:\n      * `\"mgv/notExecuted\"`: offer was not executed.\n      * `\"mgv/tradeSuccess\"`: offer execution succeeded. Will appear in `OrderResult`.\n      * `\"mgv/notEnoughGasForMakerTrade\"`: cannot give maker close enough to `gasreq`. Triggers a revert of the entire order.\n      * `\"mgv/makerRevert\"`: execution of `makerExecute` reverted. Will appear in `OrderResult`.\n      * `\"mgv/makerAbort\"`: execution of `makerExecute` returned normally, but returndata did not start with 32 bytes of 0s. Will appear in `OrderResult`.\n      * `\"mgv/makerTransferFail\"`: maker could not send outbound_tkn tokens. Will appear in `OrderResult`.\n      * `\"mgv/makerReceiveFail\"`: maker could not receive inbound_tkn tokens. Will appear in `OrderResult`.\n      * `\"mgv/takerTransferFail\"`: taker could not send inbound_tkn tokens. Triggers a revert of the entire order.\n\n      `mgvData` should not be exploitable by the maker! */\n      bytes32 mgvData;\n\n      /* Load additional information about the offer. We don't do it earlier to save one storage read in case `proceed` was false. */\n      sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\n        sor.offerId\n      ];\n\n      /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way, [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` means the failure is the maker's fault. */\n      /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. We will need it after the recursive call, so we save it in local variables. Same goes for `offerId`, `sor.offer` and `sor.offerDetail`. */\n\n      (gasused, makerData, mgvData) = execute(mor, sor);\n\n      /* Keep cached copy of current `sor` values. */\n      uint takerWants = sor.wants;\n      uint takerGives = sor.gives;\n      uint offerId = sor.offerId;\n      P.Offer.t offer = sor.offer;\n      P.OfferDetail.t offerDetail = sor.offerDetail;\n\n      /* If an execution was attempted, we move `sor` to the next offer. Note that the current state is inconsistent, since we have not yet updated `sor.offerDetails`. */\n      if (mgvData != \"mgv/notExecuted\") {\n        sor.wants = mor.initialWants > mor.totalGot\n          ? mor.initialWants - mor.totalGot\n          : 0;\n        /* It is known statically that `mor.initialGives - mor.totalGave` does not underflow since\n           1. `mor.totalGave` was increased by `sor.gives` during `execute`,\n           2. `sor.gives` was at most `mor.initialGives - mor.totalGave` from earlier step,\n           3. `sor.gives` may have been clamped _down_ during `execute` (to \"`offer.wants`\" if the offer is entirely consumed, or to `makerWouldWant`, cf. code of `execute`).\n        */\n        sor.gives = mor.initialGives - mor.totalGave;\n        sor.offerId = sor.offer.next();\n        sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\n      }\n\n      /* note that internalMarketOrder may be called twice with same offerId, but in that case `proceed` will be false! */\n      internalMarketOrder(\n        mor,\n        sor,\n        /* `proceed` value for next call. Currently, when an offer did not execute, it's because the offer's price was too high. In that case we interrupt the loop and let the taker leave with less than they asked for (but at a correct price). We could also revert instead of breaking; this could be a configurable flag for the taker to pick. */\n        mgvData != \"mgv/notExecuted\"\n      );\n\n      /* Restore `sor` values from to before recursive call */\n      sor.offerId = offerId;\n      sor.wants = takerWants;\n      sor.gives = takerGives;\n      sor.offer = offer;\n      sor.offerDetail = offerDetail;\n\n      /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\n      if (mgvData != \"mgv/notExecuted\") {\n        postExecute(mor, sor, gasused, makerData, mgvData);\n      }\n\n      /* #### Case 2 : End of market order */\n      /* If `proceed` is false, the taker has gotten its requested volume, or we have reached the end of the book, we conclude the market order. */\n    } else {\n      /* During the market order, all executed offers have been removed from the book. We end by stitching together the `best` offer pointer and the new best offer. */\n      sor.local = stitchOffers(\n        sor.outbound_tkn,\n        sor.inbound_tkn,\n        0,\n        sor.offerId,\n        sor.local\n      );\n      /* <a id=\"internalMarketOrder/liftReentrancy\"></a>Now that the market order is over, we can lift the lock on the book. In the same operation we\n\n      * lift the reentrancy lock, and\n      * update the storage\n\n      so we are free from out of order storage writes.\n      */\n      sor.local = sor.local.lock(false);\n      locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n\n      /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\n      payTakerMinusFees(mor, sor);\n\n      /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\n      executeEnd(mor, sor);\n    }\n  }}\n\n  /* # Sniping */\n  /* ## Snipes */\n  //+clear+\n\n  /* `snipes` executes multiple offers. It takes a `uint[4][]` as penultimate argument, with each array element of the form `[offerId,takerWants,takerGives,offerGasreq]`. The return parameters are of the form `(successes,snipesGot,snipesGave,bounty)`. \n  Note that we do not distinguish further between mismatched arguments/offer fields on the one hand, and an execution failure on the other. Still, a failed offer has to pay a penalty, and ultimately transaction logs explicitly mention execution failures (see `MgvLib.sol`). */\n  function snipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants\n  )\n    external\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  { unchecked {\n    return\n      generalSnipes(outbound_tkn, inbound_tkn, targets, fillWants, msg.sender);\n  }}\n\n  /*\n     From an array of _n_ `[offerId, takerWants,takerGives,gasreq]` elements, execute each snipe in sequence. Returns `(successes, takerGot, takerGave, bounty)`. \n\n     Note that if this function is not internal, anyone can make anyone use Mangrove.\n     Note that unlike general market order, the returned total values are _not_ `mor.totalGot` and `mor.totalGave`, since those are reset at every iteration of the `targets` array. Instead, accumulators `snipesGot` and `snipesGave` are used. */\n  function generalSnipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    internal\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  { unchecked {\n    ML.SingleOrder memory sor;\n    sor.outbound_tkn = outbound_tkn;\n    sor.inbound_tkn = inbound_tkn;\n    (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\n\n    MultiOrder memory mor;\n    mor.taker = taker;\n    mor.fillWants = fillWants;\n\n    /* For the snipes to even start, the market needs to be both active and not currently protected from reentrancy. */\n    activeMarketOnly(sor.global, sor.local);\n    unlockedMarketOnly(sor.local);\n\n    emit OrderStart();\n\n    /* ### Main loop */\n    //+clear+\n\n    /* Call `internalSnipes` function. */\n    (uint successCount, uint snipesGot, uint snipesGave) = internalSnipes(mor, sor, targets);\n\n    /* Over the course of the snipes order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\n    sendPenalty(mor.totalPenalty);\n    //+clear+\n\n    emit OrderComplete(\n      sor.outbound_tkn,\n      sor.inbound_tkn,\n      taker,\n      snipesGot,\n      snipesGave,\n      mor.totalPenalty\n    );\n\n    return (successCount, snipesGot, snipesGave, mor.totalPenalty);\n  }}\n\n  /* ## Internal snipes */\n  //+clear+\n  /* `internalSnipes` works by looping over targets. Each successive offer is executed under a [reentrancy lock](#internalSnipes/liftReentrancy), then its posthook is called. Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book. */\n  function internalSnipes(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    uint[4][] calldata targets\n  ) internal returns (uint successCount, uint snipesGot, uint snipesGave) { unchecked {\n    for (uint i = 0; i < targets.length; i++) {\n      /* Reset these amounts since every snipe is treated individually. Only the total penalty is sent at the end of all snipes. */\n      mor.totalGot = 0;\n      mor.totalGave = 0;\n\n      /* Initialize single order struct. */\n      sor.offerId = targets[i][0];\n      sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\n      sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\n        sor.offerId\n      ];\n\n      /* If we removed the `isLive` conditional, a single expired or nonexistent offer in `targets` would revert the entire transaction (by the division by `offer.gives` below since `offer.gives` would be 0). We also check that `gasreq` is not worse than specified. A taker who does not care about `gasreq` can specify any amount larger than $2^{24}-1$. A mismatched price will be detected by `execute`. */\n      if (\n        !isLive(sor.offer) ||\n        sor.offerDetail.gasreq() > targets[i][3]\n      ) {\n        /* We move on to the next offer in the array. */\n        continue;\n      } else {\n        require(\n          uint96(targets[i][1]) == targets[i][1],\n          \"mgv/snipes/takerWants/96bits\"\n        );\n        require(\n          uint96(targets[i][2]) == targets[i][2],\n          \"mgv/snipes/takerGives/96bits\"\n        );\n        sor.wants = targets[i][1];\n        sor.gives = targets[i][2];\n\n        /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\n        sor.local = sor.local.lock(true);\n        locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n\n        /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\"mgv/tradeSuccess\",\"mgv/notExecuted\"]` means the failure is the maker's fault. */\n        /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. */\n        (uint gasused, bytes32 makerData, bytes32 mgvData) = execute(mor, sor);\n\n        if (mgvData == \"mgv/tradeSuccess\") {\n          successCount += 1;\n        }\n\n        /* In the market order, we were able to avoid stitching back offers after every `execute` since we knew a continuous segment starting at best would be consumed. Here, we cannot do this optimisation since offers in the `targets` array may be anywhere in the book. So we stitch together offers immediately after each `execute`. */\n        if (mgvData != \"mgv/notExecuted\") {\n          sor.local = stitchOffers(\n            sor.outbound_tkn,\n            sor.inbound_tkn,\n            sor.offer.prev(),\n            sor.offer.next(),\n            sor.local\n          );\n        }\n\n        /* <a id=\"internalSnipes/liftReentrancy\"></a> Now that the current snipe is over, we can lift the lock on the book. In the same operation we\n        * lift the reentrancy lock, and\n        * update the storage\n\n        so we are free from out of order storage writes.\n        */\n        sor.local = sor.local.lock(false);\n        locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n\n        /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\n        payTakerMinusFees(mor, sor);\n\n        /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\n        executeEnd(mor, sor);\n\n        /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\n        if (mgvData != \"mgv/notExecuted\") {\n          postExecute(mor, sor, gasused, makerData, mgvData);\n        }\n\n\n        snipesGot += mor.totalGot;\n        snipesGave += mor.totalGave;\n      }\n    }\n  }}\n\n  /* # General execution */\n  /* During a market order or a snipes, offers get executed. The following code takes care of executing a single offer with parameters given by a `SingleOrder` within a larger context given by a `MultiOrder`. */\n\n  /* ## Execute */\n  /* This function will compare `sor.wants` `sor.gives` with `sor.offer.wants` and `sor.offer.gives`. If the price of the offer is low enough, an execution will be attempted (with volume limited by the offer's advertised volume).\n\n     Summary of the meaning of the return values:\n    * `gasused` is the gas consumed by the execution\n    * `makerData` is the data returned after executing the offer\n    * `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes).\n  */\n  function execute(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    returns (\n      uint gasused,\n      bytes32 makerData,\n      bytes32 mgvData\n    )\n  { unchecked {\n    /* #### `Price comparison` */\n    //+clear+\n    /* The current offer has a price `p = offerWants  offerGives` and the taker is ready to accept a price up to `p' = takerGives  takerWants`. Comparing `offerWants * takerWants` and `offerGives * takerGives` tels us whether `p < p'`.\n     */\n    {\n      uint offerWants = sor.offer.wants();\n      uint offerGives = sor.offer.gives();\n      uint takerWants = sor.wants;\n      uint takerGives = sor.gives;\n      /* <a id=\"MgvOfferTaking/checkPrice\"></a>If the price is too high, we return early.\n\n         Otherwise we now know we'll execute the offer. */\n      if (offerWants * takerWants > offerGives * takerGives) {\n        return (0, bytes32(0), \"mgv/notExecuted\");\n      }\n\n      /* ### Specification of value transfers:\n\n      Let $o_w$ be `offerWants`, $o_g$ be `offerGives`, $t_w$ be `takerWants`, $t_g$ be `takerGives`, and `f  {w,g}` be $w$ if `fillWants` is true, $g$ otherwise.\n\n      Let $\\textrm{got}$ be the amount that the taker will receive, and $\\textrm{gave}$ be the amount that the taker will pay.\n\n      #### Case $f = w$\n\n      If $f = w$, let $\\textrm{got} = \\min(o_g,t_w)$, and let $\\textrm{gave} = \\left\\lceil\\dfrac{o_w \\textrm{got}}{o_g}\\right\\rceil$. This is well-defined since, for live offers, $o_g > 0$.\n\n      In plain english, we only give to the taker up to what they wanted (or what the offer has to give), and follow the offer price to determine what the taker will give.\n\n      Since $\\textrm{gave}$ is rounded up, the price might be overevaluated. Still, we cannot spend more than what the taker specified as `takerGives`. At this point [we know](#MgvOfferTaking/checkPrice) that $o_w t_w \\leq o_g t_g$, so since $t_g$ is an integer we have\n      \n      $t_g \\geq \\left\\lceil\\dfrac{o_w t_w}{o_g}\\right\\rceil \\geq \\left\\lceil\\dfrac{o_w \\textrm{got}}{o_g}\\right\\rceil = \\textrm{gave}$.\n\n\n      #### Case $f = g$\n\n      If $f = g$, let $\\textrm{gave} = \\min(o_w,t_g)$, and $\\textrm{got} = o_g$ if $o_w = 0$, $\\textrm{got} = \\left\\lfloor\\dfrac{o_g \\textrm{gave}}{o_w}\\right\\rfloor$ otherwise.\n\n      In plain english, we spend up to what the taker agreed to pay (or what the offer wants), and follow the offer price to determine what the taker will get. This may exceed $t_w$.\n\n      #### Price adjustment\n\n      Prices are rounded up to ensure maker is not drained on small amounts. It's economically unlikely, but `density` protects the taker from being drained anyway so it is better to default towards protecting the maker here.\n      */\n\n      /*\n      ### Implementation\n\n      First we check the cases $(f=w \\wedge o_g < t_w)\\vee(f_g \\wedge o_w < t_g)$, in which case the above spec simplifies to $\\textrm{got} = o_g, \\textrm{gave} = o_w$.\n\n      Otherwise the offer may be partially consumed.\n      \n      In the case $f=w$ we don't touch $\\textrm{got}$ (which was initialized to $t_w$) and compute $\\textrm{gave} = \\left\\lceil\\dfrac{o_w t_w}{o_g}\\right\\rceil$. As shown above we have $\\textrm{gave} \\leq t_g$.\n\n      In the case $f=g$ we don't touch $\\textrm{gave}$ (which was initialized to $t_g$) and compute $\\textrm{got} = o_g$ if $o_w = 0$, and $\\textrm{got} = \\left\\lfloor\\dfrac{o_g t_g}{o_w}\\right\\rfloor$ otherwise.\n      */\n      if (\n        (mor.fillWants && offerGives < takerWants) ||\n        (!mor.fillWants && offerWants < takerGives)\n      ) {\n        sor.wants = offerGives;\n        sor.gives = offerWants;\n      } else {\n        if (mor.fillWants) {\n          uint product = offerWants * takerWants;\n          sor.gives =\n            product /\n            offerGives +\n            (product % offerGives == 0 ? 0 : 1);\n        } else {\n          if (offerWants == 0) {\n            sor.wants = offerGives;\n          } else {\n            sor.wants = (offerGives * takerGives) / offerWants;\n          }\n        }\n      }\n    }\n    /* The flashloan is executed by call to `flashloan`. If the call reverts, it means the maker failed to send back `sor.wants` `outbound_tkn` to the taker. Notes :\n     * `msg.sender` is the Mangrove itself in those calls -- all operations related to the actual caller should be done outside of this call.\n     * any spurious exception due to an error in Mangrove code will be falsely blamed on the Maker, and its provision for the offer will be unfairly taken away.\n     */\n    (bool success, bytes memory retdata) = address(this).call(\n      abi.encodeWithSelector(this.flashloan.selector, sor, mor.taker)\n    );\n\n    /* `success` is true: trade is complete */\n    if (success) {\n      /* In case of success, `retdata` encodes the gas used by the offer. */\n      gasused = abi.decode(retdata, (uint));\n      /* `mgvData` indicates trade success */\n      mgvData = bytes32(\"mgv/tradeSuccess\");\n      emit OfferSuccess(\n        sor.outbound_tkn,\n        sor.inbound_tkn,\n        sor.offerId,\n        mor.taker,\n        sor.wants,\n        sor.gives\n      );\n\n      /* If configured to do so, the Mangrove notifies an external contract that a successful trade has taken place. */\n      if (sor.global.notify()) {\n        IMgvMonitor(sor.global.monitor()).notifySuccess(\n          sor,\n          mor.taker\n        );\n      }\n\n      /* We update the totals in the multiorder based on the adjusted `sor.wants`/`sor.gives`. */\n      /* overflow: sor.{wants,gives} are on 96bits, sor.total{Got,Gave} are on 256 bits. */\n      mor.totalGot += sor.wants;\n      mor.totalGave += sor.gives;\n    } else {\n      /* In case of failure, `retdata` encodes a short [status code](#MgvOfferTaking/statusCodes), the gas used by the offer, and an arbitrary 256 bits word sent by the maker.  */\n      (mgvData, gasused, makerData) = innerDecode(retdata);\n      /* Note that in the `if`s, the literals are bytes32 (stack values), while as revert arguments, they are strings (memory pointers). */\n      if (\n        mgvData == \"mgv/makerRevert\" ||\n        mgvData == \"mgv/makerAbort\" ||\n        mgvData == \"mgv/makerTransferFail\" ||\n        mgvData == \"mgv/makerReceiveFail\"\n      ) {\n\n        emit OfferFail(\n          sor.outbound_tkn,\n          sor.inbound_tkn,\n          sor.offerId,\n          mor.taker,\n          sor.wants,\n          sor.gives,\n          mgvData\n        );\n\n        /* If configured to do so, the Mangrove notifies an external contract that a failed trade has taken place. */\n        if (sor.global.notify()) {\n          IMgvMonitor(sor.global.monitor()).notifyFail(\n            sor,\n            mor.taker\n          );\n        }\n        /* It is crucial that any error code which indicates an error caused by the taker triggers a revert, because functions that call `execute` consider that `mgvData` not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` should be blamed on the maker. */\n      } else if (mgvData == \"mgv/notEnoughGasForMakerTrade\") {\n        revert(\"mgv/notEnoughGasForMakerTrade\");\n      } else if (mgvData == \"mgv/takerTransferFail\") {\n        revert(\"mgv/takerTransferFail\");\n      } else {\n        /* This code must be unreachable. **Danger**: if a well-crafted offer/maker pair can force a revert of `flashloan`, the Mangrove will be stuck. */\n        revert(\"mgv/swapError\");\n      }\n    }\n\n    /* Delete the offer. The last argument indicates whether the offer should be stripped of its provision (yes if execution failed, no otherwise). We delete offers whether the amount remaining on offer is > density or not for the sake of uniformity (code is much simpler). We also expect prices to move often enough that the maker will want to update their price anyway. To simulate leaving the remaining volume in the offer, the maker can program their `makerPosthook` to `updateOffer` and put the remaining volume back in. */\n    dirtyDeleteOffer(\n      sor.outbound_tkn,\n      sor.inbound_tkn,\n      sor.offerId,\n      sor.offer,\n      sor.offerDetail,\n      mgvData != \"mgv/tradeSuccess\"\n    );\n  }}\n\n  /* ## flashloan (abstract) */\n  /* Externally called by `execute`, flashloan lends money (from the taker to the maker, or from the maker to the taker, depending on the implementation) then calls `makerExecute` to run the maker liquidity fetching code. If `makerExecute` is unsuccessful, `flashloan` reverts (but the larger orderbook traversal will continue). \n\n  All `flashloan` implementations must `require(msg.sender) == address(this))`. */\n  function flashloan(ML.SingleOrder calldata sor, address taker)\n    external\n    virtual\n    returns (uint gasused);\n\n  /* ## Maker Execute */\n  /* Called by `flashloan`, `makerExecute` runs the maker code and checks that it can safely send the desired assets to the taker. */\n\n  function makerExecute(ML.SingleOrder calldata sor)\n    internal\n    returns (uint gasused)\n  { unchecked {\n    bytes memory cd = abi.encodeWithSelector(IMaker.makerExecute.selector, sor);\n\n    uint gasreq = sor.offerDetail.gasreq();\n    address maker = sor.offerDetail.maker();\n    uint oldGas = gasleft();\n    /* We let the maker pay for the overhead of checking remaining gas and making the call, as well as handling the return data (constant gas since only the first 32 bytes of return data are read). So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\textrm{gasreq} - \\frac{63h}{64}$ gas. */\n    /* Note : as a possible future feature, we could stop an order when there's not enough gas left to continue processing offers. This could be done safely by checking, as soon as we start processing an offer, whether `63/64(gasleft-offer_gasbase) > gasreq`. If no, we could stop and know by induction that there is enough gas left to apply fees, stitch offers, etc for the offers already executed. */\n    if (!(oldGas - oldGas / 64 >= gasreq)) {\n      innerRevert([bytes32(\"mgv/notEnoughGasForMakerTrade\"), \"\", \"\"]);\n    }\n\n    (bool callSuccess, bytes32 makerData) = controlledCall(maker, gasreq, cd);\n\n    gasused = oldGas - gasleft();\n\n    if (!callSuccess) {\n      innerRevert([bytes32(\"mgv/makerRevert\"), bytes32(gasused), makerData]);\n    }\n\n    /* Successful execution must have a returndata that begins with `bytes32(\"\")`.\n     */\n    if (makerData != \"\") {\n      innerRevert([bytes32(\"mgv/makerAbort\"), bytes32(gasused), makerData]);\n    }\n\n    bool transferSuccess = transferTokenFrom(\n      sor.outbound_tkn,\n      maker,\n      address(this),\n      sor.wants\n    );\n\n    if (!transferSuccess) {\n      innerRevert(\n        [bytes32(\"mgv/makerTransferFail\"), bytes32(gasused), makerData]\n      );\n    }\n  }}\n\n  /* ## executeEnd (abstract) */\n  /* Called by `internalSnipes` and `internalMarketOrder`, `executeEnd` may run implementation-specific code after all makers have been called once. In [`InvertedMangrove`](#InvertedMangrove), the function calls the taker once so they can act on their flashloan. In [`Mangrove`], it does nothing. */\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    virtual;\n\n  /* ## Post execute */\n  /* At this point, we know `mgvData != \"mgv/notExecuted\"`. After executing an offer (whether in a market order or in snipes), we\n     1. Call the maker's posthook and sum the total gas used.\n     2. If offer failed: sum total penalty due to taker and give remainder to maker.\n   */\n  function postExecute(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    uint gasused,\n    bytes32 makerData,\n    bytes32 mgvData\n  ) internal { unchecked {\n    if (mgvData == \"mgv/tradeSuccess\") {\n      beforePosthook(sor);\n    }\n\n    uint gasreq = sor.offerDetail.gasreq();\n\n    /* We are about to call back the maker, giving it its unused gas (`gasreq - gasused`). Since the gas used so far may exceed `gasreq`, we prevent underflow in the subtraction below by bounding `gasused` above with `gasreq`. We could have decided not to call back the maker at all when there is no gas left, but we do it for uniformity. */\n    if (gasused > gasreq) {\n      gasused = gasreq;\n    }\n\n    gasused =\n      gasused +\n      makerPosthook(sor, gasreq - gasused, makerData, mgvData);\n\n    if (mgvData != \"mgv/tradeSuccess\") {\n      mor.totalPenalty += applyPenalty(sor, gasused);\n    }\n  }}\n\n  /* ## beforePosthook (abstract) */\n  /* Called by `makerPosthook`, this function can run implementation-specific code before calling the maker has been called a second time. In [`InvertedMangrove`](#InvertedMangrove), all makers are called once so the taker gets all of its money in one shot. Then makers are traversed again and the money is sent back to each taker using `beforePosthook`. In [`Mangrove`](#Mangrove), `beforePosthook` does nothing. */\n\n  function beforePosthook(ML.SingleOrder memory sor) internal virtual;\n\n  /* ## Maker Posthook */\n  function makerPosthook(\n    ML.SingleOrder memory sor,\n    uint gasLeft,\n    bytes32 makerData,\n    bytes32 mgvData\n  ) internal returns (uint gasused) { unchecked {\n    /* At this point, mgvData can only be `\"mgv/tradeSuccess\"`, `\"mgv/makerAbort\"`, `\"mgv/makerRevert\"`, `\"mgv/makerTransferFail\"` or `\"mgv/makerReceiveFail\"` */\n    bytes memory cd = abi.encodeWithSelector(\n      IMaker.makerPosthook.selector,\n      sor,\n      ML.OrderResult({makerData: makerData, mgvData: mgvData})\n    );\n\n    address maker = sor.offerDetail.maker();\n\n    uint oldGas = gasleft();\n    /* We let the maker pay for the overhead of checking remaining gas and making the call. So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\textrm{gasreq} - \\frac{63h}{64}$ gas. */\n    if (!(oldGas - oldGas / 64 >= gasLeft)) {\n      revert(\"mgv/notEnoughGasForMakerPosthook\");\n    }\n\n    (bool callSuccess, ) = controlledCall(maker, gasLeft, cd);\n\n    gasused = oldGas - gasleft();\n\n    if (!callSuccess) {\n      emit PosthookFail(sor.outbound_tkn, sor.inbound_tkn, sor.offerId);\n    }\n  }}\n\n  /* ## `controlledCall` */\n  /* Calls an external function with controlled gas expense. A direct call of the form `(,bytes memory retdata) = maker.call{gas}(selector,...args)` enables a griefing attack: the maker uses half its gas to write in its memory, then reverts with that memory segment as argument. After a low-level call, solidity automaticaly copies `returndatasize` bytes of `returndata` into memory. So the total gas consumed to execute a failing offer could exceed `gasreq + offer_gasbase` where `n` is the number of failing offers. This yul call only retrieves the first 32 bytes of the maker's `returndata`. */\n  function controlledCall(\n    address callee,\n    uint gasreq,\n    bytes memory cd\n  ) internal returns (bool success, bytes32 data) { unchecked {\n    bytes32[1] memory retdata;\n\n    assembly {\n      success := call(gasreq, callee, 0, add(cd, 32), mload(cd), retdata, 32)\n    }\n\n    data = retdata[0];\n  }}\n\n  /* # Penalties */\n  /* Offers are just promises. They can fail. Penalty provisioning discourages from failing too much: we ask makers to provision more ETH than the expected gas cost of executing their offer and penalize them accoridng to wasted gas.\n\n     Under normal circumstances, we should expect to see bots with a profit expectation dry-running offers locally and executing `snipe` on failing offers, collecting the penalty. The result should be a mostly clean book for actual takers (i.e. a book with only successful offers).\n\n     **Incentive issue**: if the gas price increases enough after an offer has been created, there may not be an immediately profitable way to remove the fake offers. In that case, we count on 3 factors to keep the book clean:\n     1. Gas price eventually comes down.\n     2. Other market makers want to keep the Mangrove attractive and maintain their offer flow.\n     3. Mangrove governance (who may collect a fee) wants to keep the Mangrove attractive and maximize exchange volume. */\n\n  //+clear+\n  /* After an offer failed, part of its provision is given back to the maker and the rest is stored to be sent to the taker after the entire order completes. In `applyPenalty`, we _only_ credit the maker with its excess provision. So it looks like the maker is gaining something. In fact they're just getting back a fraction of what they provisioned earlier. */\n  /*\n     Penalty application summary:\n\n   * If the transaction was a success, we entirely refund the maker and send nothing to the taker.\n   * Otherwise, the maker loses the cost of `gasused + offer_gasbase` gas. The gas price is estimated by `gasprice`.\n   * To create the offer, the maker had to provision for `gasreq + offer_gasbase` gas at a price of `offerDetail.gasprice`.\n   * We do not consider the tx.gasprice.\n   * `offerDetail.gasbase` and `offerDetail.gasprice` are the values of the Mangrove parameters `config.offer_gasbase` and `config.gasprice` when the offer was created. Without caching those values, the provision set aside could end up insufficient to reimburse the maker (or to retribute the taker).\n   */\n  function applyPenalty(\n    ML.SingleOrder memory sor,\n    uint gasused\n  ) internal returns (uint) { unchecked {\n    uint gasreq = sor.offerDetail.gasreq();\n\n    uint provision = 10**9 *\n      sor.offerDetail.gasprice() * \n      (gasreq + sor.offerDetail.offer_gasbase());\n\n    /* We set `gasused = min(gasused,gasreq)` since `gasreq < gasused` is possible e.g. with `gasreq = 0` (all calls consume nonzero gas). */\n    if (gasused > gasreq) {\n      gasused = gasreq;\n    }\n\n    /* As an invariant, `applyPenalty` is only called when `mgvData` is not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` */\n    uint penalty = 10**9 *\n      sor.global.gasprice() *\n      (gasused +\n        sor.local.offer_gasbase());\n\n    if (penalty > provision) {\n      penalty = provision;\n    }\n\n    /* Here we write to storage the new maker balance. This occurs _after_ possible reentrant calls. How do we know we're not crediting twice the same amounts? Because the `offer`'s provision was set to 0 in storage (through `dirtyDeleteOffer`) before the reentrant calls. In this function, we are working with cached copies of the offer as it was before it was consumed. */\n    creditWei(sor.offerDetail.maker(), provision - penalty);\n\n    return penalty;\n  }}\n\n  function sendPenalty(uint amount) internal { unchecked {\n    if (amount > 0) {\n      (bool noRevert, ) = msg.sender.call{value: amount}(\"\");\n      require(noRevert, \"mgv/sendPenaltyReverted\");\n    }\n  }}\n\n  /* Post-trade, `payTakerMinusFees` sends what's due to the taker and the rest (the fees) to the vault. Routing through the Mangrove like that also deals with blacklisting issues (separates the maker-blacklisted and the taker-blacklisted cases). */\n  function payTakerMinusFees(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n  { unchecked {\n    /* Should be statically provable that the 2 transfers below cannot return false under well-behaved ERC20s and a non-blacklisted, non-0 target. */\n\n    uint concreteFee = (mor.totalGot * sor.local.fee()) / 10_000;\n    if (concreteFee > 0) {\n      mor.totalGot -= concreteFee;\n      require(\n        transferToken(sor.outbound_tkn, vault, concreteFee),\n        \"mgv/feeTransferFail\"\n      );\n    }\n    if (mor.totalGot > 0) {\n      require(\n        transferToken(sor.outbound_tkn, mor.taker, mor.totalGot),\n        \"mgv/MgvFailToPayTaker\"\n      );\n    }\n  }}\n\n  /* # Misc. functions */\n\n  /* Regular solidity reverts prepend the string argument with a [function signature](https://docs.soliditylang.org/en/v0.7.6/control-structures.html#revert). Since we wish to transfer data through a revert, the `innerRevert` function does a low-level revert with only the required data. `innerCode` decodes this data. */\n  function innerDecode(bytes memory data)\n    internal\n    pure\n    returns (\n      bytes32 mgvData,\n      uint gasused,\n      bytes32 makerData\n    )\n  { unchecked {\n    /* The `data` pointer is of the form `[mgvData,gasused,makerData]` where each array element is contiguous and has size 256 bits. */\n    assembly {\n      mgvData := mload(add(data, 32))\n      gasused := mload(add(data, 64))\n      makerData := mload(add(data, 96))\n    }\n  }}\n\n  /* <a id=\"MgvOfferTaking/innerRevert\"></a>`innerRevert` reverts a raw triple of values to be interpreted by `innerDecode`.    */\n  function innerRevert(bytes32[3] memory data) internal pure { unchecked {\n    assembly {\n      revert(data, 96)\n    }\n  }}\n\n  /* `transferTokenFrom` is adapted from [existing code](https://soliditydeveloper.com/safe-erc20) and in particular avoids the\n  \"no return value\" bug. It never throws and returns true iff the transfer was successful according to `tokenAddress`.\n\n    Note that any spurious exception due to an error in Mangrove code will be falsely blamed on `from`.\n  */\n  function transferTokenFrom(\n    address tokenAddress,\n    address from,\n    address to,\n    uint value\n  ) internal returns (bool) { unchecked {\n    bytes memory cd = abi.encodeWithSelector(\n      IERC20.transferFrom.selector,\n      from,\n      to,\n      value\n    );\n    (bool noRevert, bytes memory data) = tokenAddress.call(cd);\n    return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\n  }}\n\n  function transferToken(\n    address tokenAddress,\n    address to,\n    uint value\n  ) internal returns (bool) { unchecked {\n    bytes memory cd = abi.encodeWithSelector(\n      IERC20.transfer.selector,\n      to,\n      value\n    );\n    (bool noRevert, bytes memory data) = tokenAddress.call(cd);\n    return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\n  }}\n}\n"
    },
    "contracts/Tests/Vault.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract Vault_Test {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  address base;\n  address quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    mkr = MakerSetup.setup(mgv, base, quote);\n\n    payable(mkr).transfer(10 ether);\n\n    mkr.provisionMgv(5 ether);\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(mkr), 2 ether);\n    quoteT.mint(address(this), 2 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Test Contract\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  function initial_vault_value_test() public {\n    TestEvents.eq(\n      mgv.vault(),\n      address(this),\n      \"initial vault value should be mgv creator\"\n    );\n  }\n\n  function gov_can_set_vault_test() public {\n    mgv.setVault(address(0));\n    TestEvents.eq(mgv.vault(), address(0), \"gov should be able to set vault\");\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/Tests/Toolbox/TestUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.10;\n// Encode structs\npragma abicoder v2;\n\nimport \"../Agents/TestTaker.sol\";\nimport \"../Agents/MakerDeployer.sol\";\nimport \"../Agents/TestMoriartyMaker.sol\";\nimport \"../Agents/TestToken.sol\";\n\nimport {Display, Test as TestEvents} from \"@mangrovedao/hardhat-test-solidity/test.sol\";\nimport \"../../InvertedMangrove.sol\";\nimport \"../../Mangrove.sol\";\nimport \"../../MgvLib.sol\";\n\nlibrary TestUtils {\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  /* Various utilities */\n\n  function uint2str(uint _i)\n    internal\n    pure\n    returns (string memory _uintAsString)\n  {\n    unchecked {\n      if (_i == 0) {\n        return \"0\";\n      }\n      uint j = _i;\n      uint len;\n      while (j != 0) {\n        len++;\n        j /= 10;\n      }\n      bytes memory bstr = new bytes(len);\n      uint k = len - 1;\n      while (_i != 0) {\n        bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n        _i /= 10;\n      }\n      return string(bstr);\n    }\n  }\n\n  function append(string memory a, string memory b)\n    internal\n    pure\n    returns (string memory)\n  {\n    return string(abi.encodePacked(a, b));\n  }\n\n  function append(\n    string memory a,\n    string memory b,\n    string memory c\n  ) internal pure returns (string memory) {\n    return string(abi.encodePacked(a, b, c));\n  }\n\n  function append(\n    string memory a,\n    string memory b,\n    string memory c,\n    string memory d\n  ) internal pure returns (string memory) {\n    return string(abi.encodePacked(a, b, c, d));\n  }\n\n  function toEthUnits(uint w, string memory units)\n    internal\n    pure\n    returns (string memory eth)\n  {\n    string memory suffix = append(\" \", units);\n\n    if (w == 0) {\n      return (append(\"0\", suffix));\n    }\n    uint i = 0;\n    while (w % 10 == 0) {\n      w = w / 10;\n      i += 1;\n    }\n    if (i >= 18) {\n      w = w * (10**(i - 18));\n      return append(uint2str(w), suffix);\n    } else {\n      uint zeroBefore = 18 - i;\n      string memory zeros = \"\";\n      while (zeroBefore > 1) {\n        zeros = append(zeros, \"0\");\n        zeroBefore--;\n      }\n      return (append(\"0.\", zeros, uint2str(w), suffix));\n    }\n  }\n\n  /* Log offer book */\n\n  event OBState(\n    address base,\n    address quote,\n    uint[] offerIds,\n    uint[] wants,\n    uint[] gives,\n    address[] makerAddr,\n    uint[] gasreqs\n  );\n\n  /** Two different OB logging methods.\n   *\n   *  `logOfferBook` will be well-interlaced with tests so you can easily see what's going on.\n   *\n   *  `printOfferBook` will survive reverts so you can log inside a reverting call.\n   */\n\n  /* Log OB with events and hardhat-test-solidity */\n  function logOfferBook(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint size\n  ) internal {\n    uint offerId = mgv.best(base, quote);\n\n    uint[] memory wants = new uint[](size);\n    uint[] memory gives = new uint[](size);\n    address[] memory makerAddr = new address[](size);\n    uint[] memory offerIds = new uint[](size);\n    uint[] memory gasreqs = new uint[](size);\n    uint c = 0;\n    while ((offerId != 0) && (c < size)) {\n      (P.OfferStruct memory offer, P.OfferDetailStruct memory od) = mgv.offerInfo(\n        base,\n        quote,\n        offerId\n      );\n      wants[c] = offer.wants;\n      gives[c] = offer.gives;\n      makerAddr[c] = od.maker;\n      offerIds[c] = offerId;\n      gasreqs[c] = od.gasreq;\n      offerId = offer.next;\n      c++;\n    }\n    emit OBState(base, quote, offerIds, wants, gives, makerAddr, gasreqs);\n  }\n\n  /* Log OB with hardhat's console.log */\n  function printOfferBook(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) internal view {\n    uint offerId = mgv.best(base, quote);\n    TestToken req_tk = TestToken(quote);\n    TestToken ofr_tk = TestToken(base);\n\n    console.log(\"-----Best offer: %d-----\", offerId);\n    while (offerId != 0) {\n      (P.OfferStruct memory ofr, ) = mgv.offerInfo(base, quote, offerId);\n      console.log(\n        \"[offer %d] %s/%s\",\n        offerId,\n        TestUtils.toEthUnits(ofr.wants, req_tk.symbol()),\n        TestUtils.toEthUnits(ofr.gives, ofr_tk.symbol())\n      );\n      // console.log(\n      //   \"(%d gas, %d to finish, %d penalty)\",\n      //   gasreq,\n      //   minFinishGas,\n      //   gasprice\n      // );\n      // console.log(name(makerAddr));\n      offerId = ofr.next;\n    }\n    console.log(\"-----------------------\");\n  }\n\n  /* Additional testing functions */\n\n  function revertEq(string memory actual_reason, string memory expected_reason)\n    internal\n    returns (bool)\n  {\n    return TestEvents.eq(actual_reason, expected_reason, \"wrong revert reason\");\n  }\n\n  event TestNot0x(bool success, address addr);\n\n  function not0x(address actual) internal returns (bool) {\n    bool success = actual != address(0);\n    emit TestNot0x(success, actual);\n    return success;\n  }\n\n  event GasCost(string callname, uint value);\n\n  function execWithCost(\n    string memory callname,\n    address addr,\n    bytes memory data\n  ) internal returns (bytes memory) {\n    uint g0 = gasleft();\n    (bool noRevert, bytes memory retdata) = addr.delegatecall(data);\n    require(noRevert, \"execWithCost should not revert\");\n    emit GasCost(callname, g0 - gasleft());\n    return retdata;\n  }\n\n  struct Balances {\n    uint mgvBalanceWei;\n    uint mgvBalanceFees;\n    uint takerBalanceA;\n    uint takerBalanceB;\n    uint takerBalanceWei;\n    uint[] makersBalanceA;\n    uint[] makersBalanceB;\n    uint[] makersBalanceWei;\n  }\n  enum Info {\n    makerWants,\n    makerGives,\n    nextId,\n    gasreqreceive_on,\n    gasprice,\n    gasreq\n  }\n\n  function getReason(bytes memory returnData)\n    internal\n    pure\n    returns (string memory reason)\n  {\n    /* returnData for a revert(reason) is the result of\n       abi.encodeWithSignature(\"Error(string)\",reason)\n       but abi.decode assumes the first 4 bytes are padded to 32\n       so we repad them. See:\n       https://github.com/ethereum/solidity/issues/6012\n     */\n    bytes memory pointer = abi.encodePacked(bytes28(0), returnData);\n    uint len = returnData.length - 4;\n    assembly {\n      pointer := add(32, pointer)\n      mstore(pointer, len)\n    }\n    reason = abi.decode(pointer, (string));\n  }\n\n  function isEmptyOB(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) internal view returns (bool) {\n    return mgv.best(base, quote) == 0;\n  }\n\n  function adminOf(AbstractMangrove mgv) internal view returns (address) {\n    return mgv.governance();\n  }\n\n  function getFee(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint price\n  ) internal view returns (uint) {\n    (, P.Local.t local) = mgv.config(base, quote);\n    return ((price * local.fee()) / 10000);\n  }\n\n  function getProvision(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint gasreq\n  ) internal view returns (uint) {\n    (P.Global.t glo_cfg, P.Local.t loc_cfg) = mgv.config(base, quote);\n    return ((gasreq + loc_cfg.offer_gasbase()) *\n      uint(glo_cfg.gasprice()) *\n      10**9);\n  }\n\n  function getProvision(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint gasreq,\n    uint gasprice\n  ) internal view returns (uint) {\n    (P.Global.t glo_cfg, P.Local.t loc_cfg) = mgv.config(base, quote);\n    uint _gp;\n    if (glo_cfg.gasprice() > gasprice) {\n      _gp = uint(glo_cfg.gasprice());\n    } else {\n      _gp = gasprice;\n    }\n    return ((gasreq +\n      loc_cfg.offer_gasbase()) *\n      _gp *\n      10**9);\n  }\n\n  function getOfferInfo(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    Info infKey,\n    uint offerId\n  ) internal view returns (uint) {\n    (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) = mgv.offerInfo(\n      base,\n      quote,\n      offerId\n    );\n    if (!mgv.isLive(mgv.offers(base, quote, offerId))) {\n      return 0;\n    }\n    if (infKey == Info.makerWants) {\n      return offer.wants;\n    }\n    if (infKey == Info.makerGives) {\n      return offer.gives;\n    }\n    if (infKey == Info.nextId) {\n      return offer.next;\n    }\n    if (infKey == Info.gasreq) {\n      return offerDetail.gasreq;\n    } else {\n      return offerDetail.gasprice;\n    }\n  }\n\n  function hasOffer(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint offerId\n  ) internal view returns (bool) {\n    return (getOfferInfo(mgv, base, quote, Info.makerGives, offerId) > 0);\n  }\n\n  function makerOf(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint offerId\n  ) internal view returns (address) {\n    (, P.OfferDetailStruct memory od) = mgv.offerInfo(base, quote, offerId);\n    return od.maker;\n  }\n}\n\n// Pretest libraries are for deploying large contracts independently.\n// Otherwise bytecode can be too large. See EIP 170 for more on size limit:\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md\n\nlibrary TokenSetup {\n  function setup(string memory name, string memory ticker)\n    public\n    returns (TestToken)\n  {\n    return new TestToken(address(this), name, ticker);\n  }\n}\n\nlibrary MgvSetup {\n  function deploy(address governance) public returns (AbstractMangrove mgv) {\n    mgv = new Mangrove({\n      governance: governance,\n      gasprice: 40,\n      gasmax: 1_000_000\n    });\n  }\n\n  function invertedDeploy(address governance)\n    public\n    returns (AbstractMangrove mgv)\n  {\n    mgv = new InvertedMangrove({\n      governance: governance,\n      gasprice: 40,\n      gasmax: 1_000_000\n    });\n  }\n\n  function setup(TestToken base, TestToken quote)\n    public\n    returns (AbstractMangrove)\n  {\n    return setup(base, quote, false);\n  }\n\n  function setup(\n    TestToken base,\n    TestToken quote,\n    bool inverted\n  ) public returns (AbstractMangrove mgv) {\n    TestUtils.not0x(address(base));\n    TestUtils.not0x(address(quote));\n    if (inverted) {\n      mgv = invertedDeploy(address(this));\n    } else {\n      mgv = deploy(address(this));\n    }\n    mgv.activate(address(base), address(quote), 0, 100, 20_000);\n    mgv.activate(address(quote), address(base), 0, 100, 20_000);\n  }\n}\n\nlibrary MakerSetup {\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint failer // 1 shouldFail, 2 shouldRevert\n  ) external returns (TestMaker) {\n    TestMaker tm = new TestMaker(mgv, IERC20(base), IERC20(quote));\n    tm.shouldFail(failer == 1);\n    tm.shouldRevert(failer == 2);\n    return (tm);\n  }\n\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) external returns (TestMaker) {\n    return new TestMaker(mgv, IERC20(base), IERC20(quote));\n  }\n}\n\nlibrary MakerDeployerSetup {\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) external returns (MakerDeployer) {\n    TestUtils.not0x(address(mgv));\n    return (new MakerDeployer(mgv, base, quote));\n  }\n}\n\nlibrary TakerSetup {\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) external returns (TestTaker) {\n    TestUtils.not0x(address(mgv));\n    return new TestTaker(mgv, IERC20(base), IERC20(quote));\n  }\n}\n"
    },
    "contracts/Tests/Agents/TestToken.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"./TestTokenWithDecimals.sol\";\n\ncontract TestToken is TestTokenWithDecimals {\n  constructor(\n    address admin,\n    string memory name,\n    string memory symbol\n  ) TestTokenWithDecimals(admin, name, symbol, 18) {}\n}\n"
    },
    "contracts/Tests/Agents/TestTaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../AbstractMangrove.sol\";\nimport \"./OfferManager.sol\";\n\ncontract TestTaker is ITaker {\n  AbstractMangrove _mgv;\n  address _base;\n  address _quote;\n\n  constructor(\n    AbstractMangrove mgv,\n    IERC20 base,\n    IERC20 quote\n  ) {\n    _mgv = mgv;\n    _base = address(base);\n    _quote = address(quote);\n  }\n\n  receive() external payable {}\n\n  function approveMgv(IERC20 token, uint amount) external {\n    token.approve(address(_mgv), amount);\n  }\n\n  function approveSpender(address spender, uint amount) external {\n    _mgv.approve(_base, _quote, spender, amount);\n  }\n\n  function take(uint offerId, uint takerWants) external returns (bool success) {\n    //uint taken = TestEvents.min(makerGives, takerWants);\n    (success, , ) = this.takeWithInfo(offerId, takerWants);\n  }\n\n  function takeWithInfo(uint offerId, uint takerWants)\n    external\n    returns (\n      bool,\n      uint,\n      uint\n    )\n  {\n    //uint taken = TestEvents.min(makerGives, takerWants);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [offerId, takerWants, type(uint96).max, type(uint48).max];\n    (uint successes, uint got, uint gave, ) = _mgv.snipes(\n      _base,\n      _quote,\n      targets,\n      true\n    );\n    return (successes == 1, got, gave);\n    //return taken;\n  }\n\n  function snipe(\n    AbstractMangrove __mgv,\n    address __base,\n    address __quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives,\n    uint gasreq\n  ) external returns (bool) {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [offerId, takerWants, takerGives, gasreq];\n    (uint successes, , , ) = __mgv.snipes(__base, __quote, targets, true);\n    return successes == 1;\n  }\n\n  function takerTrade(\n    address,\n    address,\n    uint,\n    uint\n  ) external pure override {}\n\n  function marketOrder(uint wants, uint gives)\n    external\n    returns (uint takerGot, uint takerGave)\n  {\n    (takerGot, takerGave, ) = _mgv.marketOrder(\n      _base,\n      _quote,\n      wants,\n      gives,\n      true\n    );\n  }\n\n  function marketOrder(\n    AbstractMangrove __mgv,\n    address __base,\n    address __quote,\n    uint takerWants,\n    uint takerGives\n  ) external returns (uint takerGot, uint takerGave) {\n    (takerGot, takerGave, ) = __mgv.marketOrder(\n      __base,\n      __quote,\n      takerWants,\n      takerGives,\n      true\n    );\n  }\n\n  function marketOrderWithFail(uint wants, uint gives)\n    external\n    returns (uint takerGot, uint takerGave)\n  {\n    (takerGot, takerGave, ) = _mgv.marketOrder(\n      _base,\n      _quote,\n      wants,\n      gives,\n      true\n    );\n  }\n}\n"
    },
    "contracts/Tests/Agents/MakerDeployer.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"../../Mangrove.sol\";\nimport \"./TestMaker.sol\";\nimport \"./TestToken.sol\";\nimport \"hardhat/console.sol\";\n\n//import \"./TestMaker.sol\";\n//import \"./TestToken.sol\";\n\ncontract MakerDeployer {\n  address payable[] makers;\n  bool deployed;\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _base,\n    address _quote\n  ) {\n    mgv = _mgv;\n    base = _base;\n    quote = _quote;\n  }\n\n  receive() external payable {\n    uint k = makers.length;\n    uint perMaker = msg.value / k;\n    require(perMaker > 0, \"0 ether to transfer\");\n    for (uint i = 0; i < k; i++) {\n      address payable maker = makers[i];\n      bool ok = maker.send(perMaker);\n      require(ok);\n    }\n  }\n\n  function length() external view returns (uint) {\n    return makers.length;\n  }\n\n  function getMaker(uint i) external view returns (TestMaker) {\n    return TestMaker(makers[i]);\n  }\n\n  function deploy(uint k) external {\n    if (!deployed) {\n      makers = new address payable[](k);\n      for (uint i = 0; i < k; i++) {\n        makers[i] = payable(\n          address(new TestMaker(mgv, TestToken(base), TestToken(quote)))\n        );\n        TestMaker(makers[i]).approveMgv(TestToken(base), 10 ether);\n        TestMaker(makers[i]).shouldFail(i == 0); //maker-0 is failer\n      }\n    }\n    deployed = true;\n  }\n}\n"
    },
    "contracts/Tests/Agents/TestMoriartyMaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./Passthrough.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport \"../../MgvLib.sol\";\n\ncontract TestMoriartyMaker is IMaker, Passthrough {\n  using P.Local for P.Local.t;\n\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n  bool succeed;\n  uint dummy;\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _base,\n    address _quote\n  ) {\n    mgv = _mgv;\n    base = _base;\n    quote = _quote;\n    succeed = true;\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    override\n    returns (bytes32 ret)\n  {\n    bool _succeed = succeed;\n    if (order.offerId == dummy) {\n      succeed = false;\n    }\n    if (_succeed) {\n      ret = \"\";\n    } else {\n      assert(false);\n    }\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {}\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public {\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    (, P.Local.t cfg) = mgv.config(base, quote);\n    uint density = cfg.density();\n    uint offer_gasbase = cfg.offer_gasbase();\n    dummy = mgv.newOffer({\n      outbound_tkn: base,\n      inbound_tkn: quote,\n      wants: 1,\n      gives: density * (offer_gasbase + 100000),\n      gasreq: 100000,\n      gasprice: 0,\n      pivotId: 0\n    }); //dummy offer\n  }\n\n  function provisionMgv(uint amount) public {\n    (bool success, ) = address(mgv).call{value: amount}(\"\");\n    require(success);\n  }\n\n  function approveMgv(IERC20 token, uint amount) public {\n    token.approve(address(mgv), amount);\n  }\n\n  receive() external payable {}\n}\n"
    },
    "@mangrovedao/hardhat-test-solidity/test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n// Should be kept in sync with ./lib.js\n\nlibrary Test {\n  /* \n   * Expect events from contracts\n   */\n  event ExpectFrom(address from);\n  event StopExpecting();\n\n  // Usage: from a test contract `t`, call `expectFrom(a)`. \n  // Any subsequent non-special event emitted by `t` will mean \n  // \"I expect `a` to emit the exact same event\". \n  // The order of expectations must be respected.\n  function expectFrom(address from) internal {\n    emit ExpectFrom(from);\n  }\n\n  // After using `expectFrom` and emitting some events you expect\n  // to see emitted elsewhere, you can use `stopExpecting` to emit \n  // further, normal events from your test.\n  function stopExpecting() internal {\n    emit StopExpecting();\n  }\n\n\n  /* \n   * Boolean test\n   */\n  event TestTrue(bool success, string message);\n\n  // Succeed iff success is true\n  function check(bool success, string memory message) internal {\n    emit TestTrue(success, message);\n  }\n\n\n  /* \n   * Always fail, always succeed\n   */\n  function fail(string memory message) internal {\n    emit TestTrue(false, message);\n  }\n\n  function succeed() internal {\n    emit TestTrue(true, \"Success\");\n  }\n\n  /* \n   * Equality testing\n   * ! overloaded as `eq` for everything except for bytes use `eq0`.\n   */\n\n  // Bytes\n  event TestEqBytes(bool success, bytes actual, bytes expected, string message);\n\n  function eq0(\n    bytes memory actual,\n    bytes memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256((actual)) == keccak256((expected));\n    emit TestEqBytes(success, actual, expected, message);\n    return success;\n  }\n\n   // Byte32\n  event TestEqBytes32(\n    bool success,\n    bytes32 actual,\n    bytes32 expected,\n    string message\n  );\n\n  function eq(\n    bytes32 actual,\n    bytes32 expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBytes32(success, actual, expected, message);\n    return success;\n  }\n\n  // Bool\n  event TestEqBool(bool success, bool actual, bool expected, string message);\n  function eq(\n    bool actual,\n    bool expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBool(success, actual, expected, message);\n    return success;\n  }\n\n  // uints\n  event TestEqUint(bool success, uint actual, uint expected, string message);\n\n  function eq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqUint(success, actual, expected, message);\n    return success;\n  }\n\n  // strings\n  event TestEqString(\n    bool success,\n    string actual,\n    string expected,\n    string message\n  );\n\n  function eq(\n    string memory actual,\n    string memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256(bytes((actual))) == keccak256(bytes((expected)));\n    emit TestEqString(success, actual, expected, message);\n    return success;\n  }\n\n  // addresses\n  event TestEqAddress(\n    bool success,\n    address actual,\n    address expected,\n    string message\n  );\n\n\n  function eq(\n    address actual,\n    address expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqAddress(success, actual, expected, message);\n    return success;\n  }\n\n  /* \n   * Inequality testing\n   */\n  event TestLess(bool success, uint actual, uint expected, string message);\n  function less(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual < expected;\n    emit TestLess(success, actual, expected, message);\n    return success;\n  }\n\n  function more(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual > expected;\n    emit TestLess(success, actual, expected, message);\n    return success;\n  }\n}\n\n// /* Either cast your arguments to address when you call balanceOf logging functions\n//    or add `is address` to your ERC20s\n//    or use the overloads with `address` types */\ninterface ERC20BalanceOf {\n  function balanceOf(address account) view external returns (uint);\n}\n\n\nlibrary Display {\n  /* ****************************************************************\n   * Register/read address->name mappings to make logs easier to read.\n   *****************************************************************/\n  /* \n   * Names are stored in the contract using the library.\n   */\n\n  // Disgusting hack so a library can manipulate storage refs.\n  bytes32 constant NAMES_POS = keccak256(\"Display.NAMES_POS\");\n  // Store mapping in library caller's storage.\n  // That's quite fragile.\n  struct Registers {\n    mapping(address => string) map;\n  }\n\n  // Also send mapping to javascript test interpreter.  The interpreter COULD\n  // just make an EVM call to map every name but that would probably be very\n  // slow.  So we cache locally.\n  event Register(address addr, string name);\n\n  function registers() internal view returns (Registers storage) {\n    this; // silence warning about pure mutability\n    Registers storage regs;\n    bytes32 _slot = NAMES_POS;\n    assembly {\n      regs.slot := _slot\n    }\n    return regs;\n  }\n\n  /*\n   * Give a name to an address for logging purposes\n   * @example\n   * ```solidity\n   * address addr = address(new Contract());\n   * register(addr,\"My Contract instance\");\n   * ```\n   */\n\n  function register(address addr, string memory name) internal {\n    registers().map[addr] = name;\n    emit Register(addr, name);\n  }\n\n  /*\n   * Read the name of a registered address. Default: \"<not found>\". \n   */\n  function nameOf(address addr) internal view returns (string memory) {\n    string memory s = registers().map[addr];\n    if (keccak256(bytes(s)) != keccak256(bytes(\"\"))) {\n      return s;\n    } else {\n      return \"<not found>\";\n    }\n  }\n\n  /* 1 arg logging (string/uint) */\n\n  event LogString(string a);\n\n  function log(string memory a) internal {\n    emit LogString(a);\n  }\n\n  event LogUint(uint a);\n\n  function log(uint a) internal {\n    emit LogUint(a);\n  }\n\n  /* 2 arg logging (string/uint) */\n\n  event LogStringString(string a, string b);\n\n  function log(string memory a, string memory b) internal {\n    emit LogStringString(a, b);\n  }\n\n  event LogStringUint(string a, uint b);\n\n  function log(string memory a, uint b) internal {\n    emit LogStringUint(a, b);\n  }\n\n  event LogUintUint(uint a, uint b);\n\n  function log(uint a, uint b) internal {\n    emit LogUintUint(a, b);\n  }\n\n  event LogUintString(uint a, string b);\n\n  function log(uint a, string memory b) internal {\n    emit LogUintString(a, b);\n  }\n\n  /* 3 arg logging (string/uint) */\n\n  event LogStringStringString(string a, string b, string c);\n\n  function log(\n    string memory a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogStringStringString(a, b, c);\n  }\n\n  event LogStringStringUint(string a, string b, uint c);\n\n  function log(\n    string memory a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogStringStringUint(a, b, c);\n  }\n\n  event LogStringUintUint(string a, uint b, uint c);\n\n  function log(\n    string memory a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogStringUintUint(a, b, c);\n  }\n\n  event LogStringUintString(string a, uint b, string c);\n\n  function log(\n    string memory a,\n    uint b,\n    string memory c\n  ) internal {\n    emit LogStringUintString(a, b, c);\n  }\n\n  event LogUintUintUint(uint a, uint b, uint c);\n\n  function log(\n    uint a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogUintUintUint(a, b, c);\n  }\n\n  event LogUintStringUint(uint a, string b, uint c);\n\n  function log(\n    uint a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogUintStringUint(a, b, c);\n  }\n\n  event LogUintStringString(uint a, string b, string c);\n\n  function log(\n    uint a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogUintStringString(a, b, c);\n  }\n\n  /* End of register/read section */\n  event ERC20Balances(address[] tokens, address[] accounts, uint[] balances);\n\n  function logBalances(\n    address[1] memory _tokens, \n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  /* takes [t1,...,tM], [a1,...,aN]\n       logs also [...b(t1,aj) ... b(tM,aj) ...] */\n\n  function logBalances(address[] memory tokens, address[] memory accounts)\n    internal\n  {\n    uint[] memory balances = new uint[](tokens.length * accounts.length);\n    for (uint i = 0; i < tokens.length; i++) {\n      for (uint j = 0; j < accounts.length; j++) {\n        uint bal = ERC20BalanceOf(tokens[i]).balanceOf(accounts[j]);\n        balances[i * accounts.length + j] = bal;\n        //console.log(tokens[i].symbol(),nameOf(accounts[j]),bal);\n      }\n    }\n    emit ERC20Balances(tokens, accounts, balances);\n  }\n\n}"
    },
    "contracts/InvertedMangrove.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// InvertedMangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {ITaker, MgvLib as ML, P} from \"./MgvLib.sol\";\n\nimport {AbstractMangrove} from \"./AbstractMangrove.sol\";\n\n/* <a id=\"InvertedMangrove\"></a> The `InvertedMangrove` contract implements the \"inverted\" version of Mangrove, where each maker loans money to the taker. The taker is then called, and finally each maker is sent its payment and called again (with the orderbook unlocked). */\ncontract InvertedMangrove is AbstractMangrove {\n  // prettier-ignore\n  using P.OfferDetail for P.OfferDetail.t;\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax\n  ) AbstractMangrove(governance, gasprice, gasmax, \"InvertedMangrove\") {}\n\n  // execute taker trade\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    override\n  { unchecked {\n    ITaker(mor.taker).takerTrade(\n      sor.outbound_tkn,\n      sor.inbound_tkn,\n      mor.totalGot,\n      mor.totalGave\n    );\n    bool success = transferTokenFrom(\n      sor.inbound_tkn,\n      mor.taker,\n      address(this),\n      mor.totalGave\n    );\n    require(success, \"mgv/takerFailToPayTotal\");\n  }}\n\n  /* We use `transferFrom` with takers (instead of checking `balanceOf` before/after the call) for the following reason we want the taker to be awaken after all loans have been made, so either\n     1. The taker gets a list of all makers and loops through them to pay back, or\n     2. we call a new taker method \"payback\" after returning from each maker call, or\n     3. we call transferFrom after returning from each maker call\n\nSo :\n   1. Would mean accumulating a list of all makers, which would make the market order code too complex\n   2. Is OK, but has an extra CALL cost on top of the token transfer, one for each maker. This is unavoidable anyway when calling makerExecute (since the maker must be able to execute arbitrary code at that moment), but we can skip it here.\n   3. Is the cheapest, but it has the drawbacks of `transferFrom`: money must end up owned by the taker, and taker needs to `approve` Mangrove\n   */\n  function beforePosthook(ML.SingleOrder memory sor) internal override { unchecked {\n    /* If `transferToken` returns false here, we're in a special (and bad) situation. The taker is returning part of their total loan to a maker, but the maker can't receive the tokens. Only case we can see: maker is blacklisted. In that case, we send the tokens to the vault, so things have a chance of getting sorted out later (Mangrove is a token black hole). */\n    if (\n      !transferToken(\n        sor.inbound_tkn,\n        sor.offerDetail.maker(),\n        sor.gives\n      )\n    ) {\n      /* If that transfer fails there's nothing we can do -- reverting would punish the taker for the maker's blacklisting. */\n      transferToken(sor.inbound_tkn, vault, sor.gives);\n    }\n  }}\n\n  /* # Flashloans */\n  //+clear+\n  /* ## Inverted Flashloan */\n  /*\n     `invertedFlashloan` is for the 'arbitrage' mode of operation. It:\n     0. Calls the maker's `execute` function. If successful (tokens have been sent to taker):\n     2. Runs `taker`'s `execute` function.\n     4. Returns the results ofthe operations, with optional makerData to help the maker debug.\n\n     There are two ways to do the flashloan:\n     1. balanceOf before/after\n     2. run transferFrom ourselves.\n\n     ### balanceOf pros:\n       * maker may `transferFrom` another address they control; saves gas compared to Mangrove's `transferFrom`\n       * maker does not need to `approve` Mangrove\n\n     ### balanceOf cons\n       * if the ERC20 transfer method has a callback to receiver, the method does not work (the receiver can set its balance to 0 during the callback)\n       * if the taker is malicious, they can analyze the maker code. If the maker goes on any Mangrove2, they may execute code provided by the taker. This would reduce the taker balance and make the maker fail. So the taker could steal the maker's balance.\n\n    We choose `transferFrom`.\n    */\n\n  function flashloan(ML.SingleOrder calldata sor, address)\n    external\n    override\n    returns (uint gasused)\n  { unchecked {\n    /* `invertedFlashloan` must be used with a call (hence the `external` modifier) so its effect can be reverted. But a call from the outside would be fatal. */\n    require(msg.sender == address(this), \"mgv/invertedFlashloan/protected\");\n    gasused = makerExecute(sor);\n  }}\n}\n"
    },
    "contracts/Mangrove.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// Mangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, P} from \"./MgvLib.sol\";\n\nimport {AbstractMangrove} from \"./AbstractMangrove.sol\";\n\n/* <a id=\"Mangrove\"></a> The `Mangrove` contract implements the \"normal\" version of Mangrove, where the taker flashloans the desired amount to each maker. Each time, makers are called after the loan. When the order is complete, each maker is called once again (with the orderbook unlocked). */\ncontract Mangrove is AbstractMangrove {\n  using P.OfferDetail for P.OfferDetail.t;\n\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax\n  ) AbstractMangrove(governance, gasprice, gasmax, \"Mangrove\") {}\n\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    override\n  {}\n\n  function beforePosthook(ML.SingleOrder memory sor) internal override {}\n\n  /* ## Flashloan */\n  /*\n     `flashloan` is for the 'normal' mode of operation. It:\n     1. Flashloans `takerGives` `inbound_tkn` from the taker to the maker and returns false if the loan fails.\n     2. Runs `offerDetail.maker`'s `execute` function.\n     3. Returns the result of the operations, with optional makerData to help the maker debug.\n   */\n  function flashloan(ML.SingleOrder calldata sor, address taker)\n    external\n    override\n    returns (uint gasused)\n  { unchecked {\n    /* `flashloan` must be used with a call (hence the `external` modifier) so its effect can be reverted. But a call from the outside would be fatal. */\n    require(msg.sender == address(this), \"mgv/flashloan/protected\");\n    /* The transfer taker -> maker is in 2 steps. First, taker->mgv. Then\n       mgv->maker. With a direct taker->maker transfer, if one of taker/maker\n       is blacklisted, we can't tell which one. We need to know which one:\n       if we incorrectly blame the taker, a blacklisted maker can block a pair forever; if we incorrectly blame the maker, a blacklisted taker can unfairly make makers fail all the time. Of course we assume the Mangrove is not blacklisted. Also note that this setup doesn't not work well with tokens that take fees or recompute balances at transfer time. */\n    if (transferTokenFrom(sor.inbound_tkn, taker, address(this), sor.gives)) {\n      if (\n        transferToken(\n          sor.inbound_tkn,\n          sor.offerDetail.maker(),\n          sor.gives\n        )\n      ) {\n        gasused = makerExecute(sor);\n      } else {\n        innerRevert([bytes32(\"mgv/makerReceiveFail\"), bytes32(0), \"\"]);\n      }\n    } else {\n      innerRevert([bytes32(\"mgv/takerTransferFail\"), \"\", \"\"]);\n    }\n  }}\n}\n"
    },
    "contracts/Tests/Agents/OfferManager.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../../AbstractMangrove.sol\";\n//import \"../../MgvLib.sol\";\nimport {IERC20, IMaker, ITaker, MgvLib as ML, HasMgvEvents, IMgvMonitor, P} from \"../../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\ncontract OfferManager is IMaker, ITaker {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  // erc_addr -> owner_addr -> balance\n  AbstractMangrove mgv;\n  AbstractMangrove invMgv;\n  address caller_id;\n  // mgv_addr -> base_addr -> quote_addr -> offerId -> owner\n  mapping(address => mapping(address => mapping(address => mapping(uint => address)))) owners;\n  uint constant gas_to_execute = 100_000;\n\n  constructor(AbstractMangrove _mgv, AbstractMangrove _inverted) {\n    mgv = _mgv;\n    invMgv = _inverted;\n  }\n\n  //posthook data:\n  //outbound_tkn: orp.outbound_tkn,\n  // inbound_tkn: orp.inbound_tkn,\n  // takerWants: takerWants,\n  // takerGives: takerGives,\n  // offerId: offerId,\n  // offerDeleted: toDelete\n\n  function takerTrade(\n    //NB this is not called if mgv is not a flashTaker mgv\n    address base,\n    address quote,\n    uint netReceived,\n    uint shouldGive\n  ) external override {\n    if (msg.sender == address(invMgv)) {\n      ITaker(caller_id).takerTrade(base, quote, netReceived, shouldGive); // taker will find funds\n      IERC20(quote).transferFrom(caller_id, address(this), shouldGive); // ready to be withdawn by Mangrove\n    }\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata _order,\n    ML.OrderResult calldata\n  ) external override {\n    if (msg.sender == address(invMgv)) {\n      //should have received funds by now\n      address owner = owners[msg.sender][_order.outbound_tkn][\n        _order.inbound_tkn\n      ][_order.offerId];\n      require(owner != address(0), \"Unkown owner\");\n      IERC20(_order.inbound_tkn).transfer(owner, _order.gives);\n    }\n  }\n\n  // Maker side execute for residual offer\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function makerExecute(ML.SingleOrder calldata _order)\n    external\n    override\n    returns (bytes32 ret)\n  {\n    emit Execute(\n      msg.sender,\n      _order.outbound_tkn,\n      _order.inbound_tkn,\n      _order.offerId,\n      _order.wants,\n      _order.gives\n    );\n    bool inverted;\n    address MGV;\n    if (msg.sender == address(mgv)) {\n      MGV = address(mgv);\n    }\n    if (msg.sender == address(invMgv)) {\n      MGV = address(invMgv);\n      inverted = true;\n    }\n    require(MGV != address(0), \"Unauth call\");\n    // if residual of offerId is < dust, offer will be removed and dust lost\n    // also freeWeil[this] will increase, offerManager may chose to give it back to owner\n    address owner = owners[address(MGV)][_order.outbound_tkn][\n      _order.inbound_tkn\n    ][_order.offerId];\n    console.log(owner);\n    if (owner == address(0)) {\n      ret = \"mgvOffer/unknownOwner\";\n    }\n    if (!inverted) {\n      try IERC20(_order.inbound_tkn).transfer(owner, _order.gives) {\n        console.log(\"Success\");\n        ret = \"\";\n      } catch Error(string memory message) {\n        console.log(message);\n        ret = \"mgvOffer/transferToOwnerFail\";\n      }\n    } else {\n      ret = \"\";\n    }\n  }\n\n  //marketOrder (base,quote) + NewOffer(quote,base)\n  function order(\n    AbstractMangrove MGV,\n    address base,\n    address quote,\n    uint wants,\n    uint gives,\n    bool invertedResidual\n  ) external payable {\n    bool flashTaker = (address(MGV) == address(invMgv));\n    caller_id = msg.sender; // this should come with a reentrancy lock\n    if (!flashTaker) {\n      // else caller_id will be called when takerTrade is called by Mangrove\n      IERC20(quote).transferFrom(msg.sender, address(this), gives); // OfferManager must be approved by sender\n    }\n    IERC20(quote).approve(address(MGV), 100 ether); // to pay maker\n    IERC20(base).approve(address(MGV), 100 ether); // takerfee\n\n    (uint netReceived, , ) = MGV.marketOrder(base, quote, wants, gives, true); // OfferManager might collect provisions of failing offers\n\n    try IERC20(base).transfer(msg.sender, netReceived) {\n      uint residual_w = wants - netReceived;\n      uint residual_g = (gives * residual_w) / wants;\n\n      AbstractMangrove _MGV;\n      if (invertedResidual) {\n        _MGV = invMgv;\n      } else {\n        _MGV = mgv;\n      }\n      (P.Global.t config, ) = _MGV.config(base, quote);\n      require(\n        msg.value >=\n          gas_to_execute * uint(config.gasprice()) * 10**9,\n        \"Insufficent funds to delegate order\"\n      ); //not checking overflow issues\n      (bool success, ) = address(_MGV).call{value: msg.value}(\"\");\n      require(success, \"provision mgv failed\");\n      uint residual_ofr = _MGV.newOffer(\n        quote,\n        base,\n        residual_w,\n        residual_g,\n        gas_to_execute,\n        0,\n        0\n      );\n      owners[address(_MGV)][quote][base][residual_ofr] = msg.sender;\n    } catch {\n      require(false, \"Failed to send market order money to owner\");\n    }\n  }\n}\n"
    },
    "contracts/Tests/Agents/TestMaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"./Passthrough.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport \"hardhat/console.sol\";\nimport {IERC20, IMaker} from \"../../MgvLib.sol\";\nimport {Test as TestEvents} from \"@mangrovedao/hardhat-test-solidity/test.sol\";\n\ncontract TestMaker is IMaker, Passthrough {\n  AbstractMangrove _mgv;\n  address _base;\n  address _quote;\n  bool _shouldFail; // will set mgv allowance to 0\n  bool _shouldAbort; // will not return bytes32(\"\")\n  bool _shouldRevert; // will revert\n  bytes32 _expectedStatus;\n\n  constructor(\n    AbstractMangrove mgv,\n    IERC20 base,\n    IERC20 quote\n  ) {\n    _mgv = mgv;\n    _base = address(base);\n    _quote = address(quote);\n  }\n\n  receive() external payable {}\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function logExecute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  ) external {\n    emit Execute(mgv, base, quote, offerId, takerWants, takerGives);\n  }\n\n  function shouldRevert(bool should) external {\n    _shouldRevert = should;\n  }\n\n  function shouldFail(bool should) external {\n    _shouldFail = should;\n  }\n\n  function shouldAbort(bool should) external {\n    _shouldAbort = should;\n  }\n\n  function approveMgv(IERC20 token, uint amount) public {\n    token.approve(address(_mgv), amount);\n  }\n\n  function expect(bytes32 mgvData) external {\n    _expectedStatus = mgvData;\n  }\n\n  function transferToken(\n    IERC20 token,\n    address to,\n    uint amount\n  ) external {\n    token.transfer(to, amount);\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    virtual\n    override\n    returns (bytes32)\n  {\n    if (_shouldRevert) {\n      bytes32[1] memory revert_msg = [bytes32(\"testMaker/revert\")];\n      assembly {\n        revert(revert_msg, 32)\n      }\n    }\n    emit Execute(\n      msg.sender,\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId,\n      order.wants,\n      order.gives\n    );\n    if (_shouldFail) {\n      IERC20(order.outbound_tkn).approve(address(_mgv), 0);\n      // bytes32[1] memory refuse_msg = [bytes32(\"testMaker/transferFail\")];\n      // assembly {\n      //   return(refuse_msg, 32)\n      // }\n      //revert(\"testMaker/fail\");\n    }\n    if (_shouldAbort) {\n      return \"abort\";\n    } else {\n      return \"\";\n    }\n  }\n\n  bool _shouldFailHook;\n\n  function setShouldFailHook(bool should) external {\n    _shouldFailHook = should;\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external virtual override {\n    order; //shh\n    if (_shouldFailHook) {\n      bytes32[1] memory refuse_msg = [bytes32(\"posthookFail\")];\n      assembly {\n        revert(refuse_msg, 32)\n      }\n    }\n\n    if (_expectedStatus != bytes32(\"\")) {\n      TestEvents.eq(\n        result.mgvData,\n        _expectedStatus,\n        \"Incorrect status message\"\n      );\n    }\n  }\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public returns (uint) {\n    return (_mgv.newOffer(_base, _quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOfferWithFunding(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint amount\n  ) public returns (uint) {\n    return (_mgv.newOffer{value:amount}(_base, _quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOffer(\n    address base,\n    address quote,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public returns (uint) {\n    return (_mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOfferWithFunding(\n    address base,\n    address quote,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint amount\n  ) public returns (uint) {\n    return (_mgv.newOffer{value:amount}(base, quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) public returns (uint) {\n    return (\n      _mgv.newOffer(_base, _quote, wants, gives, gasreq, gasprice, pivotId)\n    );\n  }\n\n  function newOfferWithFunding(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint amount\n  ) public returns (uint) {\n    return (_mgv.newOffer{value:amount}(_base, _quote, wants, gives, gasreq, gasprice, pivotId));\n  }\n\n  function updateOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint offerId\n  ) public {\n    _mgv.updateOffer(_base, _quote, wants, gives, gasreq, 0, pivotId, offerId);\n  }\n\n  function updateOfferWithFunding(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint offerId,\n    uint amount\n  ) public {\n    _mgv.updateOffer{value:amount}(_base, _quote, wants, gives, gasreq, 0, pivotId, offerId);\n  }\n\n  function retractOffer(uint offerId) public returns (uint) {\n    return _mgv.retractOffer(_base, _quote, offerId, false);\n  }\n\n  function retractOfferWithDeprovision(uint offerId) public returns (uint) {\n    return _mgv.retractOffer(_base, _quote, offerId, true);\n  }\n\n  function provisionMgv(uint amount) public {\n    _mgv.fund{value: amount}(address(this));\n  }\n\n  function withdrawMgv(uint amount) public returns (bool) {\n    return _mgv.withdraw(amount);\n  }\n\n  function freeWei() public view returns (uint) {\n    return _mgv.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/Tests/Agents/Passthrough.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\n/* \n  Experimental contract to simulate an EOA which can call arbitrary functions.\n  How to use :\n  \n  p = new Passthrough();\n  p.calls(<address>,Contract.function.selector,arg1,...argN);\n*/\n\ncontract Passthrough {\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1,\n    uint arg2\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1, arg2));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1,\n    uint arg2,\n    uint arg3\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1, arg2, arg3));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1,\n    uint arg2,\n    uint arg3,\n    uint arg4\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1, arg2, arg3, arg4));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    address arg1\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    string memory arg1\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1));\n  }\n}\n"
    },
    "contracts/Tests/Agents/TestTokenWithDecimals.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"../ERC20BLWithDecimals.sol\";\n\ncontract TestTokenWithDecimals is ERC20BLWithDecimals {\n  mapping(address => bool) admins;\n\n  constructor(\n    address admin,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) ERC20BLWithDecimals(name, symbol, decimals) {\n    admins[admin] = true;\n  }\n\n  function requireAdmin() internal view {\n    require(admins[msg.sender], \"TestToken/adminOnly\");\n  }\n\n  function addAdmin(address admin) external {\n    requireAdmin();\n    admins[admin] = true;\n  }\n\n  function mint(address to, uint amount) external {\n    requireAdmin();\n    _mint(to, amount);\n  }\n\n  function burn(address account, uint amount) external {\n    requireAdmin();\n    _burn(account, amount);\n  }\n\n  function blacklists(address account) external {\n    requireAdmin();\n    _blacklists(account);\n  }\n\n  function whitelists(address account) external {\n    requireAdmin();\n    _whitelists(account);\n  }\n}\n"
    },
    "contracts/Tests/ERC20BLWithDecimals.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"./ERC20BL.sol\";\n\ncontract ERC20BLWithDecimals is ERC20BL {\n  constructor(\n    string memory __name,\n    string memory __symbol,\n    uint8 __decimals\n  ) ERC20BL(__name, __symbol) {\n    _decimals = __decimals;\n  }\n}\n"
    },
    "contracts/Tests/ERC20BL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./SafeMath.sol\";\nimport {IERC20} from \"../MgvLib.sol\";\n\n// From OpenZeppelin & Giry\n//The MIT License (MIT)\n\n//Copyright (c) 2016-2020 zOS Global Limited\n\n//Permission is hereby granted, free of charge, to any person obtaining\n//a copy of this software and associated documentation files (the\n//\"Software\"), to deal in the Software without restriction, including\n//without limitation the rights to use, copy, modify, merge, publish,\n//distribute, sublicense, and/or sell copies of the Software, and to\n//permit persons to whom the Software is furnished to do so, subject to\n//the following conditions:\n\n//The above copyright notice and this permission notice shall be included\n//in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n//MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n//CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n//TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return payable(msg.sender);\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20BL is Context, IERC20 {\n  using SafeMath for uint;\n\n  mapping(address => bool) private _blacklisted;\n  mapping(address => uint) private _balances;\n\n  mapping(address => mapping(address => uint)) private _allowances;\n\n  uint private _totalSupply;\n\n  string internal _name;\n  string internal _symbol;\n  uint8 internal _decimals;\n\n  modifier notBlackListed(address addr) {\n    require(\n      !_blacklisted[addr] && !_blacklisted[_msgSender()],\n      \"ERC20BL/Blacklisted\"\n    );\n    _;\n  }\n\n  function _blacklists(address addr) public {\n    _blacklisted[addr] = true;\n  }\n\n  function _whitelists(address addr) public {\n    _blacklisted[addr] = false;\n  }\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory __name, string memory __symbol) {\n    _name = __name;\n    _symbol = __symbol;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint amount)\n    public\n    virtual\n    override\n    notBlackListed(recipient)\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint amount)\n    public\n    virtual\n    override\n    notBlackListed(spender)\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  )\n    public\n    virtual\n    override\n    notBlackListed(sender)\n    notBlackListed(recipient)\n    returns (bool)\n  {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint addedValue)\n    public\n    virtual\n    notBlackListed(spender)\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint amount\n  ) internal virtual {}\n\n  function deposit() external payable override {}\n\n  function withdraw(uint) external override {}\n}\n"
    },
    "contracts/Tests/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n// From OpenZeppelin\n//The MIT License (MIT)\n\n//Copyright (c) 2016-2020 zOS Global Limited\n\n//Permission is hereby granted, free of charge, to any person obtaining\n//a copy of this software and associated documentation files (the\n//\"Software\"), to deal in the Software without restriction, including\n//without limitation the rights to use, copy, modify, merge, publish,\n//distribute, sublicense, and/or sell copies of the Software, and to\n//permit persons to whom the Software is furnished to do so, subject to\n//the following conditions:\n\n//The above copyright notice and this permission notice shall be included\n//in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n//MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n//CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n//TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint a, uint b) internal pure returns (uint) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint a, uint b) internal pure returns (uint) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint a, uint b) internal pure returns (uint) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b > 0, errorMessage);\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(uint a, uint b) internal pure returns (uint) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n"
    },
    "contracts/Tests/TakerOperations.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n/* The following constructs an ERC20 with a transferFrom callback method,\n   and a TestTaker which throws away any funds received upon getting\n   a callback.\n*/\ncontract TakerOperations_Test is HasMgvEvents {\n  TestToken baseT;\n  TestToken quoteT;\n  address base;\n  address quote;\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  TestMaker refusemkr;\n  TestMaker failmkr;\n\n  bool refuseReceive = false;\n\n  receive() external payable {\n    if (refuseReceive) {\n      revert(\"no\");\n    }\n  }\n\n  function a_beforeAll() public {\n    baseT = TokenSetup.setup(\"A\", \"$A\");\n    quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n\n    mkr = MakerSetup.setup(mgv, base, quote);\n    refusemkr = MakerSetup.setup(mgv, base, quote, 1);\n    failmkr = MakerSetup.setup(mgv, base, quote, 2);\n\n    payable(mkr).transfer(10 ether);\n    payable(refusemkr).transfer(10 ether);\n    payable(failmkr).transfer(10 ether);\n\n    mkr.provisionMgv(10 ether);\n    mkr.approveMgv(baseT, 10 ether);\n\n    refusemkr.provisionMgv(1 ether);\n    refusemkr.approveMgv(baseT, 10 ether);\n    failmkr.provisionMgv(1 ether);\n    failmkr.approveMgv(baseT, 10 ether);\n\n    baseT.mint(address(mkr), 5 ether);\n    baseT.mint(address(failmkr), 5 ether);\n    baseT.mint(address(refusemkr), 5 ether);\n\n    quoteT.mint(address(this), 5 ether);\n    quoteT.mint(address(this), 5 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"taker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n\n    Display.register(address(mkr), \"maker\");\n    Display.register(address(failmkr), \"reverting maker\");\n    Display.register(address(refusemkr), \"refusing maker\");\n  }\n\n  function snipe_reverts_if_taker_is_blacklisted_for_quote_test() public {\n    uint weiBalanceBefore = mgv.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    quoteT.blacklists(address(this));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipe should fail\");\n    } catch Error(string memory errorMsg) {\n      TestEvents.eq(\n        errorMsg,\n        \"mgv/takerTransferFail\",\n        \"Unexpected revert reason\"\n      );\n      TestEvents.eq(\n        weiBalanceBefore,\n        mgv.balanceOf(address(this)),\n        \"Taker should not take bounty\"\n      );\n    }\n  }\n\n  function snipe_reverts_if_taker_is_blacklisted_for_base_test() public {\n    uint weiBalanceBefore = mgv.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    baseT.blacklists(address(this));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipe should fail\");\n    } catch Error(string memory errorMsg) {\n      TestEvents.eq(\n        errorMsg,\n        \"mgv/MgvFailToPayTaker\",\n        \"Unexpected revert reason\"\n      );\n      TestEvents.eq(\n        weiBalanceBefore,\n        mgv.balanceOf(address(this)),\n        \"Taker should not take bounty\"\n      );\n    }\n  }\n\n  function snipe_fails_if_price_has_changed_test() public {\n    uint weiBalanceBefore = mgv.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 0.5 ether, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 0, \"Snipe should fail\");\n      TestEvents.eq(\n        weiBalanceBefore,\n        mgv.balanceOf(address(this)),\n        \"Taker should not take bounty\"\n      );\n      TestEvents.check(\n        (got == gave && gave == 0),\n        \"Taker should not give or take anything\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function taker_cannot_drain_maker_test() public {\n    mgv.setDensity(base, quote, 0);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(9, 10, 100_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1, 15 ether, 100_000];\n    uint oldBal = quoteT.balanceOf(address(this));\n    mgv.snipes(base, quote, targets, true);\n    uint newBal = quoteT.balanceOf(address(this));\n    TestEvents.more(oldBal, newBal, \"oldBal should be strictly higher\");\n  }\n\n  function snipe_fillWants_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.5 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0.5 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 0.5 ether, \"Taker did not give enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function multiple_snipes_fillWants_test() public {\n    uint i;\n    uint[] memory ofrs = new uint[](3);\n    ofrs[i++] = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    ofrs[i++] = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    ofrs[i++] = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 3 ether);\n    uint[4][] memory targets = new uint[4][](3);\n    uint j;\n    targets[j] = [ofrs[j], 0.5 ether, 1 ether, 100_000];\n    j++;\n    targets[j] = [ofrs[j], 1 ether, 1 ether, 100_000];\n    j++;\n    targets[j] = [ofrs[j], 0.8 ether, 1 ether, 100_000];\n\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 3, \"Snipes should not fail\");\n      TestEvents.eq(got, 2.3 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 2.3 ether, \"Taker did not give enough\");\n      TestEvents.expectFrom(address(mgv));\n      emit OrderStart();\n      emit OrderComplete(\n        address(base),\n        address(quote),\n        address(this),\n        got,\n        gave,\n        0\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  function snipe_fillWants_zero_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 0, 100_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0 ether, \"Taker had too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n      TestEvents.expectFrom(address(quote));\n      emit Transfer(address(this), address(mgv), 0);\n      emit Transfer(address(mgv), address(mkr), 0);\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_free_offer_fillWants_respects_spec_test() public {\n    uint ofr = mkr.newOffer(0, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    /* Setting fillWants = true means we should not receive more than `wants`.\n       Here we are asking for 0.1 eth to an offer that gives 1eth for nothing.\n       We should still only receive 0.1 eth */\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.1 ether, 0, 100_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0.1 ether, \"Wrong got value\");\n      TestEvents.eq(gave, 0 ether, \"Wrong gave value\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_free_offer_fillGives_respects_spec_test() public {\n    uint ofr = mkr.newOffer(0, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    /* Setting fillWants = false means we should spend as little as possible to receive\n       as much as possible.\n       Here despite asking for .1eth the offer gives 1eth for 0 so we should receive 1eth. */\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.1 ether, 0, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 1 ether, \"Wrong got value\");\n      TestEvents.eq(gave, 0 ether, \"Wrong gave value\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_fillGives_zero_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 0, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0 ether, \"Taker had too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_fillGives_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.5 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 1 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 1 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function mo_fillWants_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 2 ether);\n    try mgv.marketOrder(base, quote, 1.1 ether, 2 ether, true) returns (\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.eq(got, 1.1 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 1.1 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function mo_fillGives_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 2 ether);\n    try mgv.marketOrder(base, quote, 1.1 ether, 2 ether, false) returns (\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.eq(got, 2 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 2 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function mo_fillGivesAll_no_approved_fails_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 2 ether);\n    try mgv.marketOrder(base, quote, 0 ether, 3 ether, false) {} catch Error(\n      string memory errorMsg\n    ) {\n      TestEvents.eq(\n        errorMsg,\n        \"mgv/takerTransferFail\",\n        \"Invalid revert message\"\n      );\n    }\n  }\n\n  function mo_fillGivesAll_succeeds_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 3 ether);\n    try mgv.marketOrder(base, quote, 0 ether, 3 ether, false) returns (\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.eq(got, 3 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 3 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function taker_reimbursed_if_maker_doesnt_pay_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 100_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = refusemkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\"); // status visible in the posthook\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave, ) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerTransferFail\"\n    );\n    emit Credit(address(refusemkr), mkr_provision - penalty);\n  }\n\n  function taker_reverts_on_penalty_triggers_revert_test() public {\n    uint ofr = refusemkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    refuseReceive = true;\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\n        \"Snipe should fail because taker has reverted on penalty send.\"\n      );\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/sendPenaltyReverted\", \"wrong revert reason\");\n    }\n  }\n\n  function taker_reimbursed_if_maker_is_blacklisted_for_base_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 100_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\"); // status visible in the posthook\n\n    baseT.blacklists(address(mkr));\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave, ) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerTransferFail\"\n    );\n    emit Credit(address(mkr), mkr_provision - penalty);\n  }\n\n  function taker_reimbursed_if_maker_is_blacklisted_for_quote_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 100_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerReceiveFail\"); // status visible in the posthook\n\n    quoteT.blacklists(address(mkr));\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave, ) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerReceiveFail\"\n    );\n    emit Credit(address(mkr), mkr_provision - penalty);\n  }\n\n  function taker_collects_failing_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = failmkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 0, 100_000];\n    (uint successes, uint takerGot, uint takerGave, ) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Transaction data should be 0\"\n    );\n    TestEvents.check(\n      address(this).balance > beforeWei,\n      \"Taker was not compensated\"\n    );\n  }\n\n  function taker_reimbursed_if_maker_reverts_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 50_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = failmkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave, ) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    emit Credit(address(failmkr), mkr_provision - penalty);\n  }\n\n  function taker_hasnt_approved_base_succeeds_order_with_fee_test() public {\n    mgv.setFee(base, quote, 3);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        1 ether,\n        \"Incorrect delivered amount\"\n      );\n    } catch {\n      TestEvents.fail(\"Snipe should succeed\");\n    }\n  }\n\n  function taker_hasnt_approved_base_succeeds_order_wo_fee_test() public {\n    uint balTaker = baseT.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        1 ether,\n        \"Incorrect delivered amount\"\n      );\n    } catch {\n      TestEvents.fail(\"Snipe should succeed\");\n    }\n  }\n\n  function taker_hasnt_approved_quote_fails_order_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    baseT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Order should fail when base is not mgv approved\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/takerTransferFail\", \"wrong revert reason\");\n    }\n  }\n\n  function simple_snipe_test() public {\n    uint ofr = mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    baseT.approve(address(mgv), 10 ether);\n    quoteT.approve(address(mgv), 10 ether);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint balMaker = quoteT.balanceOf(address(mkr));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1.1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should succeed\");\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        1 ether,\n        \"Incorrect delivered amount (taker)\"\n      );\n      TestEvents.eq(\n        quoteT.balanceOf(address(mkr)) - balMaker,\n        1.1 ether,\n        \"Incorrect delivered amount (maker)\"\n      );\n      TestEvents.eq(takerGot, 1 ether, \"Incorrect transaction information\");\n      TestEvents.eq(takerGave, 1.1 ether, \"Incorrect transaction information\");\n      TestEvents.expectFrom(address(mgv));\n      emit OfferSuccess(base, quote, ofr, address(this), 1 ether, 1.1 ether);\n    } catch {\n      TestEvents.fail(\"Snipe should succeed\");\n    }\n  }\n\n  function simple_marketOrder_test() public {\n    mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    mkr.newOffer(1.2 ether, 1 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n\n    baseT.approve(address(mgv), 10 ether);\n    quoteT.approve(address(mgv), 10 ether);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint balMaker = quoteT.balanceOf(address(mkr));\n\n    try mgv.marketOrder(base, quote, 2 ether, 4 ether, true) returns (\n      uint takerGot,\n      uint takerGave,\n      uint\n    ) {\n      TestEvents.eq(\n        takerGot,\n        2 ether,\n        \"Incorrect declared delivered amount (taker)\"\n      );\n      TestEvents.eq(\n        takerGave,\n        2.3 ether,\n        \"Incorrect declared delivered amount (maker)\"\n      );\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        2 ether,\n        \"Incorrect delivered amount (taker)\"\n      );\n      TestEvents.eq(\n        quoteT.balanceOf(address(mkr)) - balMaker,\n        2.3 ether,\n        \"Incorrect delivered amount (maker)\"\n      );\n    } catch {\n      TestEvents.fail(\"Market order should succeed\");\n    }\n  }\n\n  function simple_fillWants_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, ) = mgv.marketOrder(\n      base,\n      quote,\n      1 ether,\n      2 ether,\n      true\n    );\n    TestEvents.eq(\n      takerGot,\n      1 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n    TestEvents.eq(\n      takerGave,\n      1 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n  }\n\n  function simple_fillGives_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, ) = mgv.marketOrder(\n      base,\n      quote,\n      1 ether,\n      2 ether,\n      false\n    );\n    TestEvents.eq(\n      takerGave,\n      2 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      2 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function fillGives_at_0_wants_works_test() public {\n    uint ofr = mkr.newOffer(0 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 2 ether, 0 ether, 300_000];\n\n    (, uint takerGot, uint takerGave, ) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      false\n    );\n    TestEvents.eq(\n      takerGave,\n      0 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      2 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function empty_wants_fillGives_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, ) = mgv.marketOrder(\n      base,\n      quote,\n      0 ether,\n      2 ether,\n      false\n    );\n    TestEvents.eq(\n      takerGave,\n      2 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      2 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function empty_wants_fillWants_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, ) = mgv.marketOrder(\n      base,\n      quote,\n      0 ether,\n      2 ether,\n      true\n    );\n    TestEvents.eq(\n      takerGave,\n      0 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      0 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function taker_has_no_quote_fails_order_test() public {\n    uint ofr = mkr.newOffer(100 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n\n    quoteT.approve(address(mgv), 100 ether);\n    baseT.approve(address(mgv), 1 ether); // not necessary since no fee\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 2 ether, 100 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\n        \"Taker does not have enough quote tokens, order should fail\"\n      );\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/takerTransferFail\", \"wrong revert reason\");\n    }\n  }\n\n  function maker_has_not_enough_base_fails_order_test() public {\n    uint ofr = mkr.newOffer(1 ether, 100 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\");\n    // getting rid of base tokens\n    //mkr.transferToken(baseT,address(this),5 ether);\n    quoteT.approve(address(mgv), 0.5 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 50 ether, 0.5 ether, 100_000];\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 0, \"order should fail\");\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      50 ether,\n      0.5 ether,\n      \"mgv/makerTransferFail\"\n    );\n  }\n\n  function maker_revert_is_logged_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    mkr.expect(\"mgv/makerRevert\");\n    mkr.shouldRevert(true);\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    mgv.snipes(base, quote, targets, true);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n  }\n\n  function snipe_on_higher_price_fails_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 0.5 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 0.5 ether, 100_000];\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(\n      successes == 0,\n      \"Order should fail when order price is higher than offer\"\n    );\n  }\n\n  function snipe_on_higher_gas_fails_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(\n      successes == 0,\n      \"Order should fail when order gas is higher than offer\"\n    );\n  }\n\n  function detect_lowgas_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 100 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    bytes memory cd = abi.encodeWithSelector(\n      mgv.snipes.selector,\n      base,\n      quote,\n      targets,\n      true\n    );\n\n    (bool noRevert, bytes memory data) = address(mgv).call{gas: 130000}(cd);\n    if (noRevert) {\n      TestEvents.fail(\"take should fail due to low gas\");\n    } else {\n      TestUtils.revertEq(\n        TestUtils.getReason(data),\n        \"mgv/notEnoughGasForMakerTrade\"\n      );\n    }\n  }\n\n  function snipe_on_lower_price_succeeds_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 2 ether);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint balMaker = quoteT.balanceOf(address(mkr));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 2 ether, 100_000];\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(\n      successes == 1,\n      \"Order should succeed when order price is lower than offer\"\n    );\n    // checking order was executed at Maker's price\n    TestEvents.eq(\n      baseT.balanceOf(address(this)) - balTaker,\n      1 ether,\n      \"Incorrect delivered amount (taker)\"\n    );\n    TestEvents.eq(\n      quoteT.balanceOf(address(mkr)) - balMaker,\n      1 ether,\n      \"Incorrect delivered amount (maker)\"\n    );\n  }\n\n  /* Note as for jan 5 2020: by locally pushing the block gas limit to 38M, you can go up to 162 levels of recursion before hitting \"revert for an unknown reason\" -- I'm assuming that's the stack limit. */\n  function recursion_depth_is_acceptable_test() public {\n    for (uint i = 0; i < 50; i++) {\n      mkr.newOffer(0.001 ether, 0.001 ether, 50_000, i);\n    }\n    quoteT.approve(address(mgv), 10 ether);\n    // 6/1/20 : ~50k/offer with optims\n    //uint g = gasleft();\n    //console.log(\"gas used per offer: \",(g-gasleft())/50);\n  }\n\n  function partial_fill_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 1);\n    mkr.expect(\"mgv/tradeSuccess\");\n    (uint takerGot, , ) = mgv.marketOrder(\n      base,\n      quote,\n      0.15 ether,\n      0.15 ether,\n      true\n    );\n    TestEvents.eq(\n      takerGot,\n      0.15 ether,\n      \"Incorrect declared partial fill amount\"\n    );\n    TestEvents.eq(\n      baseT.balanceOf(address(this)),\n      0.15 ether,\n      \"incorrect partial fill\"\n    );\n  }\n\n  // ! unreliable test, depends on gas use\n  function market_order_stops_for_high_price_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer((i + 1) * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 2 * (0.1 ether + 0.1 ether);\n    uint takerGives = 2 * (0.1 ether + 0.2 ether);\n    mgv.marketOrder{gas: 350_000}(base, quote, takerWants, takerGives, true);\n  }\n\n  // ! unreliable test, depends on gas use\n  function market_order_stops_for_filled_mid_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer(i * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 0.1 ether + 0.05 ether;\n    uint takerGives = 0.1 ether + 0.1 ether;\n    mgv.marketOrder{gas: 350_000}(base, quote, takerWants, takerGives, true);\n  }\n\n  function market_order_stops_for_filled_after_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer(i * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 0.1 ether + 0.1 ether;\n    uint takerGives = 0.1 ether + 0.2 ether;\n    mgv.marketOrder{gas: 350_000}(base, quote, takerWants, takerGives, true);\n  }\n\n  function takerWants_wider_than_160_bits_fails_marketOrder_test() public {\n    try mgv.marketOrder(base, quote, 2**160, 1, true) {\n      TestEvents.fail(\"TakerWants > 160bits, order should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/mOrder/takerWants/160bits\", \"wrong revert reason\");\n    }\n  }\n\n  function snipe_with_0_wants_ejects_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    uint mkrBal = baseT.balanceOf(address(mkr));\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 0);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 1 ether, 50_000];\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 1, \"snipe should succeed\");\n    TestEvents.eq(mgv.best(base, quote), 0, \"offer should be gone\");\n    TestEvents.eq(\n      baseT.balanceOf(address(mkr)),\n      mkrBal,\n      \"mkr balance should not change\"\n    );\n  }\n\n  function unsafe_gas_left_fails_order_test() public {\n    mgv.setGasbase(base, quote, 1);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 120_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 120_000];\n    try mgv.snipes{gas: 120_000}(base, quote, targets, true) {\n      TestEvents.fail(\"unsafe gas amount, order should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/notEnoughGasForMakerTrade\", \"wrong revert reason\");\n    }\n  }\n\n  function marketOrder_on_empty_book_returns_test() public {\n    try mgv.marketOrder(base, quote, 1 ether, 1 ether, true) {\n      TestEvents.succeed();\n    } catch Error(string memory) {\n      TestEvents.fail(\"market order on empty book should not fail\");\n    }\n  }\n\n  function marketOrder_on_empty_book_does_not_leave_lock_on_test() public {\n    mgv.marketOrder(base, quote, 1 ether, 1 ether, true);\n    TestEvents.check(\n      !mgv.locked(base, quote),\n      \"mgv should not be locked after marketOrder on empty OB\"\n    );\n  }\n\n  function takerWants_is_zero_succeeds_test() public {\n    try mgv.marketOrder(base, quote, 0, 1 ether, true) returns (\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.eq(got, 0, \"Taker got too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n    } catch {\n      TestEvents.fail(\"Unexpected revert\");\n    }\n  }\n\n  function takerGives_is_zero_succeeds_test() public {\n    try mgv.marketOrder(base, quote, 1 ether, 0, true) returns (\n      uint got,\n      uint gave,\n      uint\n    ) {\n      TestEvents.eq(got, 0, \"Taker got too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n    } catch {\n      TestEvents.fail(\"Unexpected revert\");\n    }\n  }\n}\n"
    },
    "contracts/Tests/PermitHelper.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n/* *********************************************** */\n/* THIS IS NOT A `hardhat test-solidity` TEST FILE */\n/* *********************************************** */\n\n/* See test/permit.js, this helper sets up a mgv for the javascript tester of the permit functionality */\n\ncontract PermitHelper is IMaker {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n\n  function makerExecute(ML.SingleOrder calldata)\n    external\n    pure\n    override\n    returns (bytes32)\n  {\n    return \"\";\n  }\n\n  function makerPosthook(ML.SingleOrder calldata, ML.OrderResult calldata)\n    external\n    override\n  {}\n\n  constructor() payable {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(this), 2 ether);\n    quoteT.mint(msg.sender, 2 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Permit signer\");\n    Display.register(address(this), \"Permit Helper\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n\n    mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n  }\n\n  function mgvAddress() external view returns (address) {\n    return address(mgv);\n  }\n\n  function baseAddress() external view returns (address) {\n    return base;\n  }\n\n  function quoteAddress() external view returns (address) {\n    return quote;\n  }\n\n  function no_allowance() external {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [uint(1), 1 ether, 1 ether, 300_000];\n    try mgv.snipesFor(base, quote, targets, true, msg.sender) {\n      revert(\"snipesFor without allowance should revert\");\n    } catch Error(string memory reason) {\n      if (keccak256(bytes(reason)) != keccak256(\"mgv/lowAllowance\")) {\n        revert(\"revert when no allowance should be due to no allowance\");\n      }\n    }\n  }\n\n  function wrong_permit(\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    try\n      mgv.permit({\n        outbound_tkn: base,\n        inbound_tkn: quote,\n        owner: msg.sender,\n        spender: address(this),\n        value: value,\n        deadline: deadline,\n        v: v,\n        r: r,\n        s: s\n      })\n    {\n      revert(\"Permit with bad v,r,s should revert\");\n    } catch Error(string memory reason) {\n      if (\n        keccak256(bytes(reason)) != keccak256(\"mgv/permit/invalidSignature\")\n      ) {\n        revert(\"permit failed, but signature should be deemed invalid\");\n      }\n    }\n  }\n\n  function expired_permit(\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    try\n      mgv.permit({\n        outbound_tkn: base,\n        inbound_tkn: quote,\n        owner: msg.sender,\n        spender: address(this),\n        value: value,\n        deadline: deadline,\n        v: v,\n        r: r,\n        s: s\n      })\n    {\n      revert(\"Permit with expired deadline should revert\");\n    } catch Error(string memory reason) {\n      if (keccak256(bytes(reason)) != keccak256(\"mgv/permit/expired\")) {\n        revert(\"permit failed, but deadline should be deemed expired\");\n      }\n    }\n  }\n\n  function good_permit(\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    mgv.permit(\n      base,\n      quote,\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n\n    if (mgv.allowances(base, quote, msg.sender, address(this)) != value) {\n      revert(\"Allowance not set\");\n    }\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [uint(1), 1 ether, 1 ether, 300_000];\n    (uint successes, uint takerGot, uint takerGave, ) = mgv.snipesFor(\n      base,\n      quote,\n      targets,\n      true,\n      msg.sender\n    );\n    if (successes != 0) {\n      revert(\"Snipe should succeed\");\n    }\n    if (takerGot != 1 ether) {\n      revert(\"takerGot should be 1 ether\");\n    }\n\n    if (takerGave != 1 ether) {\n      revert(\"takerGave should be 1 ether\");\n    }\n\n    if (\n      mgv.allowances(base, quote, msg.sender, address(this)) !=\n      (value - 1 ether)\n    ) {\n      revert(\"Allowance incorrectly decreased\");\n    }\n  }\n}\n"
    },
    "contracts/Tests/Pedagogical.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\nimport \"./Agents/Compound.sol\";\n\ncontract Pedagogical_Test {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestToken bat;\n  TestToken dai;\n  TestTaker tkr;\n  TestMaker mkr;\n  Compound compound;\n\n  function example_1_offerbook_test() public {\n    setupMakerBasic();\n\n    Display.log(\"Filling book\");\n\n    mkr.newOffer({wants: 1 ether, gives: 1 ether, gasreq: 300_000, pivotId: 0});\n\n    mkr.newOffer({\n      wants: 1.1 ether,\n      gives: 1 ether,\n      gasreq: 300_000,\n      pivotId: 0\n    });\n\n    mkr.newOffer({\n      wants: 1.2 ether,\n      gives: 1 ether,\n      gasreq: 300_000,\n      pivotId: 0\n    });\n\n    //logBook\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 3);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n  }\n\n  function example_2_markerOrder_test() public {\n    example_1_offerbook_test();\n\n    Display.log(\n      \"Market order. Taker wants 2.7 exaunits and gives 3.5 exaunits.\"\n    );\n    (uint got, uint gave) = tkr.marketOrder({\n      wants: 2.7 ether,\n      gives: 3.5 ether\n    });\n    Display.log(\"Market order ended. Got / gave\", got, gave);\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n  }\n\n  function example_3_redeem_test() public {\n    setupMakerCompound();\n\n    Display.log(\"Maker posts an offer for 1 exaunit\");\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 600_000,\n      pivotId: 0\n    });\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr),\n      address(compound)\n    );\n    Display.logBalances(\n      [address(compound.c(bat)), address(compound.c(dai))],\n      address(mkr)\n    );\n\n    Display.log(\"Taker takes offer for 0.3 exaunits\");\n    bool took = tkr.take(ofr, 0.3 ether);\n    if (took) {\n      Display.log(\"Take successful\");\n    } else {\n      Display.log(\"Take failed\");\n    }\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr),\n      address(compound)\n    );\n  }\n\n  function example_4_callback_test() public {\n    setupMakerCallback();\n\n    Display.log(\"Maker posts 1 offer\");\n    mkr.newOffer({wants: 1 ether, gives: 1 ether, gasreq: 400_000, pivotId: 0});\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n\n    Display.log(\n      \"Market order begins. Maker will be called back and reinsert its offer\"\n    );\n    (uint got, uint gave) = tkr.marketOrder({wants: 1 ether, gives: 1 ether});\n    Display.log(\"Market order complete. got / gave:\", got, gave);\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n  }\n\n  function _beforeAll() public {\n    bat = new TestToken({\n      admin: address(this),\n      name: \"Basic attention token\",\n      symbol: \"BAT\"\n    });\n\n    dai = new TestToken({admin: address(this), name: \"Dai\", symbol: \"DAI\"});\n\n    mgv = new Mangrove({\n      governance: address(this),\n      gasprice: 40,\n      gasmax: 1_000_000\n    });\n\n    // activate a market where taker buys BAT using DAI\n    mgv.activate({\n      outbound_tkn: address(bat),\n      inbound_tkn: address(dai),\n      fee: 0,\n      density: 100,\n      offer_gasbase: 10_000\n    });\n\n    tkr = new TestTaker({mgv: mgv, base: bat, quote: dai});\n\n    mgv.fund{value: 10 ether}(address(this));\n\n    dai.mint({amount: 10 ether, to: address(tkr)});\n    tkr.approveMgv({amount: 10 ether, token: dai});\n\n    Display.register({addr: msg.sender, name: \"Test Runner\"});\n    Display.register({addr: address(this), name: \"Testing Contract\"});\n    Display.register({addr: address(bat), name: \"BAT\"});\n    Display.register({addr: address(dai), name: \"DAI\"});\n    Display.register({addr: address(mgv), name: \"mgv\"});\n    Display.register({addr: address(tkr), name: \"taker\"});\n  }\n\n  function setupMakerBasic() internal {\n    mkr = new Maker_basic({mgv: mgv, base: bat, quote: dai});\n\n    Display.register({addr: address(mkr), name: \"maker-basic\"});\n\n    // testing contract starts with 1000 ETH\n    payable(mkr).transfer(10 ether);\n    mkr.provisionMgv({amount: 5 ether});\n    bat.mint({amount: 10 ether, to: address(mkr)});\n  }\n\n  function setupMakerCompound() internal {\n    compound = new Compound();\n    Display.register(address(compound), \"compound\");\n    Display.register(address(compound.c(bat)), \"cBAT\");\n    Display.register(address(compound.c(dai)), \"cDAI\");\n\n    Maker_compound _mkr = new Maker_compound({\n      mgv: mgv,\n      base: bat,\n      quote: dai,\n      compound: compound\n    });\n\n    mkr = _mkr;\n\n    bat.mint({amount: 10 ether, to: address(mkr)});\n    _mkr.useCompound();\n\n    Display.register({addr: address(mkr), name: \"maker-compound\"});\n\n    // testing contract starts with 1000 ETH\n    payable(mkr).transfer(10 ether);\n    mkr.provisionMgv({amount: 5 ether});\n  }\n\n  function setupMakerCallback() internal {\n    Display.log(\"Setting up maker with synchronous callback\");\n    mkr = new Maker_callback({mgv: mgv, base: bat, quote: dai});\n\n    Display.register({addr: address(mkr), name: \"maker-callback\"});\n\n    // testing contract starts with 1000 ETH\n    payable(mkr).transfer(10 ether);\n    mkr.provisionMgv({amount: 5 ether});\n\n    bat.mint({amount: 10 ether, to: address(mkr)});\n  }\n}\n\n// Provisioned.\n// Sends amount to taker.\ncontract Maker_basic is TestMaker {\n  constructor(\n    AbstractMangrove mgv,\n    ERC20BL base,\n    ERC20BL quote\n  ) TestMaker(mgv, base, quote) {\n    approveMgv(base, 500 ether);\n  }\n\n  function makerExecute(ML.SingleOrder calldata)\n    public\n    pure\n    override\n    returns (bytes32)\n  {\n    return \"\";\n    //ERC20(order.outbound_tkn).transfer({recipient: taker, amount: order.wants});\n  }\n}\n\n// Not provisioned.\n// Redeems money from fake-Compound\ncontract Maker_compound is TestMaker {\n  Compound _compound;\n\n  constructor(\n    AbstractMangrove mgv,\n    ERC20BL base,\n    ERC20BL quote,\n    Compound compound\n  ) TestMaker(mgv, base, quote) {\n    _compound = compound;\n    approveMgv(base, 500 ether);\n    base.approve(address(compound), 500 ether);\n    quote.approve(address(compound), 500 ether);\n  }\n\n  function useCompound() external {\n    Display.log(\"Maker deposits 10 exaunits at Compound.\");\n    _compound.mint(ERC20BL(_base), 10 ether);\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    override\n    returns (bytes32)\n  {\n    _compound.mint({token: ERC20BL(order.inbound_tkn), amount: order.gives});\n    Display.log(\"Maker redeems from Compound.\");\n    _compound.redeem({\n      token: ERC20BL(order.outbound_tkn),\n      amount: order.wants,\n      to: address(this)\n    });\n    return \"\";\n  }\n}\n\n// Provisioned.\n// Reinserts the offer if necessary.\ncontract Maker_callback is TestMaker {\n  constructor(\n    AbstractMangrove mgv,\n    ERC20BL base,\n    ERC20BL quote\n  ) TestMaker(mgv, base, quote) {\n    approveMgv(base, 500 ether);\n  }\n\n  function makerExecute(ML.SingleOrder calldata)\n    public\n    pure\n    override\n    returns (bytes32)\n  {\n    return \"\";\n    //ERC20BL(order.outbound_tkn).transfer({recipient: taker, amount: order.wants});\n  }\n\n  uint volume = 1 ether;\n  uint price = 340; // in %\n  uint gasreq = 400_000;\n\n  function makerPosthook(ML.SingleOrder calldata order, ML.OrderResult calldata)\n    external\n    override\n  {\n    Display.log(\"Reinserting offer...\");\n    AbstractMangrove mgv = AbstractMangrove(payable(msg.sender));\n    mgv.updateOffer({\n      outbound_tkn: order.outbound_tkn,\n      inbound_tkn: order.inbound_tkn,\n      wants: (price * volume) / 100,\n      gives: volume,\n      gasreq: gasreq,\n      gasprice: 0,\n      pivotId: 0,\n      offerId: order.offerId\n    });\n  }\n}\n"
    },
    "contracts/Tests/Agents/Compound.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../Toolbox/TestUtils.sol\";\n\nimport \"./TestToken.sol\";\n\ncontract Compound {\n  constructor() {}\n\n  mapping(ERC20BL => mapping(address => uint)) deposits;\n  mapping(ERC20BL => TestToken) cTokens;\n\n  //function grant(address to, IERC20 token, uint amount) {\n  //deposits[token][to] += amount;\n  //c(token).mint(to, amount);\n  //}\n\n  function c(ERC20BL token) public returns (TestToken) {\n    if (address(cTokens[token]) == address(0)) {\n      string memory cName = TestUtils.append(\"c\", token.name());\n      string memory cSymbol = TestUtils.append(\"c\", token.symbol());\n      cTokens[token] = new TestToken(address(this), cName, cSymbol);\n    }\n\n    return cTokens[token];\n  }\n\n  function mint(ERC20BL token, uint amount) external {\n    token.transferFrom(msg.sender, address(this), amount);\n    deposits[token][msg.sender] += amount;\n    c(token).mint(msg.sender, amount);\n  }\n\n  function redeem(\n    address to,\n    ERC20BL token,\n    uint amount\n  ) external {\n    c(token).burn(msg.sender, amount);\n    token.transfer(to, amount);\n  }\n}\n"
    },
    "contracts/Tests/Monitor.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"hardhat/console.sol\";\nimport \"../MgvLib.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMonitor.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract Monitor_Test {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  MgvMonitor monitor;\n  address base;\n  address quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    monitor = new MgvMonitor();\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    mkr = MakerSetup.setup(mgv, base, quote);\n\n    payable(mkr).transfer(10 ether);\n\n    mkr.provisionMgv(5 ether);\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(mkr), 2 ether);\n    quoteT.mint(address(this), 2 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Test Contract\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  function initial_monitor_values_test() public {\n    (P.Global.t config, ) = mgv.config(base, quote);\n    TestEvents.check(\n      !config.useOracle(),\n      \"initial useOracle should be false\"\n    );\n    TestEvents.check(\n      !config.notify(),\n      \"initial notify should be false\"\n    );\n  }\n\n  function set_monitor_values_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setUseOracle(true);\n    mgv.setNotify(true);\n    (P.Global.t config, ) = mgv.config(base, quote);\n    TestEvents.eq(\n      config.monitor(),\n      address(monitor),\n      \"monitor should be set\"\n    );\n    TestEvents.check(\n      config.useOracle(),\n      \"useOracle should be set\"\n    );\n    TestEvents.check(\n      config.notify(),\n      \"notify should be set\"\n    );\n  }\n\n  function set_oracle_density_with_useOracle_works_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setUseOracle(true);\n    mgv.setDensity(base, quote, 898);\n    monitor.setDensity(base, quote, 899);\n    (, P.Local.t config) = mgv.config(base, quote);\n    TestEvents.eq(\n      config.density(),\n      899,\n      \"density should be set oracle\"\n    );\n  }\n\n  function set_oracle_density_without_useOracle_fails_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setDensity(base, quote, 898);\n    monitor.setDensity(base, quote, 899);\n    (, P.Local.t config) = mgv.config(base, quote);\n    TestEvents.eq(\n      config.density(),\n      898,\n      \"density should be set by mgv\"\n    );\n  }\n\n  function set_oracle_gasprice_with_useOracle_works_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setUseOracle(true);\n    mgv.setGasprice(900);\n    monitor.setGasprice(901);\n    (P.Global.t config, ) = mgv.config(base, quote);\n    TestEvents.eq(\n      config.gasprice(),\n      901,\n      \"gasprice should be set by oracle\"\n    );\n  }\n\n  function set_oracle_gasprice_without_useOracle_fails_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setGasprice(900);\n    monitor.setGasprice(901);\n    (P.Global.t config, ) = mgv.config(base, quote);\n    TestEvents.eq(\n      config.gasprice(),\n      900,\n      \"gasprice should be set by mgv\"\n    );\n  }\n\n  function invalid_oracle_address_throws_test() public {\n    mgv.setMonitor(address(42));\n    mgv.setUseOracle(true);\n    try mgv.config(base, quote) {\n      TestEvents.fail(\"Call to invalid oracle address should throw\");\n    } catch {\n      TestEvents.succeed();\n    }\n  }\n\n  function notify_works_on_success_when_set_test() public {\n    mkr.approveMgv(IERC20(base), 1 ether);\n    mgv.setMonitor(address(monitor));\n    mgv.setNotify(true);\n    uint ofrId = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    P.Offer.t offer = mgv.offers(base, quote, ofrId);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofrId, 0.04 ether, 0.05 ether, 100_000];\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 1, \"snipe should succeed\");\n    (P.Global.t _global, P.Local.t _local) = mgv.config(base, quote);\n    _local = _local.best(1).lock(true);\n\n    ML.SingleOrder memory order = ML.SingleOrder({\n      outbound_tkn: base,\n      inbound_tkn: quote,\n      offerId: ofrId,\n      offer: offer,\n      wants: 0.04 ether,\n      gives: 0.04 ether, // wants has been updated to offer price\n      offerDetail: mgv.offerDetails(base, quote, ofrId),\n      global: _global,\n      local: _local\n    });\n\n    TestEvents.expectFrom(address(monitor));\n    emit L.TradeSuccess(order, address(this));\n  }\n\n  function notify_works_on_fail_when_set_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setNotify(true);\n    uint ofrId = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    P.Offer.t offer = mgv.offers(base, quote, ofrId);\n    P.OfferDetail.t offerDetail = mgv.offerDetails(base, quote, ofrId);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofrId, 0.04 ether, 0.05 ether, 100_000];\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 0, \"snipe should fail\");\n\n    (P.Global.t _global, P.Local.t _local) = mgv.config(base, quote);\n    // config sent during maker callback has stale best and, is locked\n    _local = _local.best(1).lock(true);\n\n    ML.SingleOrder memory order = ML.SingleOrder({\n      outbound_tkn: base,\n      inbound_tkn: quote,\n      offerId: ofrId,\n      offer: offer,\n      wants: 0.04 ether,\n      gives: 0.04 ether, // gives has been updated to offer price\n      offerDetail: offerDetail, // gasprice logged will still be as before failure\n      global: _global,\n      local: _local\n    });\n\n    TestEvents.expectFrom(address(monitor));\n    emit L.TradeFail(order, address(this));\n  }\n}\n"
    },
    "contracts/Tests/Agents/TestMonitor.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../../MgvLib.sol\";\n\nlibrary L {\n  event TradeSuccess(MgvLib.SingleOrder order, address taker);\n  event TradeFail(MgvLib.SingleOrder order, address taker);\n}\n\ncontract MgvMonitor is IMgvMonitor {\n  uint gasprice;\n  mapping(address => mapping(address => uint)) private densities;\n\n  function setGasprice(uint _gasprice) external {\n    gasprice = _gasprice;\n  }\n\n  function setDensity(\n    address base,\n    address quote,\n    uint _density\n  ) external {\n    densities[base][quote] = _density;\n  }\n\n  function read(address base, address quote)\n    external\n    view\n    override\n    returns (uint, uint)\n  {\n    return (gasprice, densities[base][quote]);\n  }\n\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    emit L.TradeSuccess(sor, taker);\n  }\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    emit L.TradeFail(sor, taker);\n  }\n}\n"
    },
    "contracts/Tests/MM1T_Test.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestTaker.sol\";\nimport \"./Agents/MM1.sol\";\n\ncontract MM1T_Test {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMaker mkr;\n  MM1 mm1;\n  address base;\n  address quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    tkr = TakerSetup.setup(mgv, base, quote);\n    mkr = MakerSetup.setup(mgv, base, quote);\n    mm1 = new MM1{value: 2 ether}(mgv, base, quote);\n\n    payable(tkr).transfer(10 ether);\n    payable(mkr).transfer(10 ether);\n\n    //bool noRevert;\n    //(noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    mkr.provisionMgv(5 ether);\n\n    baseT.mint(address(tkr), 10 ether);\n    baseT.mint(address(mkr), 10 ether);\n    baseT.mint(address(mm1), 2 ether);\n\n    quoteT.mint(address(tkr), 10 ether);\n    quoteT.mint(address(mkr), 10 ether);\n    quoteT.mint(address(mm1), 2 ether);\n\n    mm1.refresh();\n\n    //baseT.approve(address(mgv), 1 ether);\n    //quoteT.approve(address(mgv), 1 ether);\n    tkr.approveMgv(quoteT, 1000 ether);\n    tkr.approveMgv(baseT, 1000 ether);\n    mkr.approveMgv(quoteT, 1000 ether);\n    mkr.approveMgv(baseT, 1000 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(tkr), \"taker[$A,$B]\");\n    //Display.register(address(dual_mkr), \"maker[$B,$A]\");\n    Display.register(address(mkr), \"maker\");\n    Display.register(address(mm1), \"MM1\");\n  }\n\n  function ta_test() public {\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(base, quote, 1);\n    console.log(\"prev\", ofr.prev);\n    mkr.newOffer(base, quote, 0.05 ether, 0.1 ether, 200_000, 0);\n    mkr.newOffer(quote, base, 0.05 ether, 0.05 ether, 200_000, 0);\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n\n    tkr.marketOrder(0.01 ether, 0.01 ether);\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n\n    mkr.newOffer(base, quote, 0.05 ether, 0.1 ether, 200_000, 0);\n    mm1.refresh();\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n  }\n}\n"
    },
    "contracts/Tests/Agents/MM1.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {ITaker, IMaker, MgvLib as DC, HasMgvEvents, IMgvMonitor, P} from \"../../MgvLib.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport \"../Toolbox/TestUtils.sol\";\nimport \"hardhat/console.sol\";\n\n/* TODO\n * dans makerExecute: check oracle price to see if I'm still in reasonable spread\n * don't sell all liquidity otherwie what is my price when I have 0 balance ? at least check that.\n */\n\ncontract MM1 {\n  uint immutable sell_id;\n  uint immutable buy_id;\n  address immutable a_addr;\n  address immutable b_addr;\n  AbstractMangrove immutable mgv;\n\n  /* This MM has 1 offer on each side of a book. After each take, it updates both offers.\n     The new price is based on the midprice between each books, a base_spread,\n     and the ratio of a/b inventories normalized by the current midprice. */\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _a_addr,\n    address _b_addr\n  ) payable {\n    mgv = _mgv;\n    a_addr = _a_addr;\n    b_addr = _b_addr;\n\n    _mgv.fund{value: 1 ether}(address(this));\n\n    IERC20(_a_addr).approve(address(_mgv), 10000 ether);\n    IERC20(_b_addr).approve(address(_mgv), 10000 ether);\n\n    sell_id = _mgv.newOffer(_a_addr, _b_addr, 1, 1 ether, 40_000, 0, 0);\n    buy_id = _mgv.newOffer(_b_addr, _a_addr, 1, 1 ether, 40_000, 0, 0);\n  }\n\n  function refresh() external {\n    doMakerPosthook();\n  }\n\n  function makerExecute(DC.SingleOrder calldata) external pure returns (bytes32) {\n    return \"\";\n  }\n\n  function makerPosthook(DC.SingleOrder calldata, DC.OrderResult calldata)\n    external\n  {\n    doMakerPosthook();\n  }\n\n  /* Shifting to avoid overflows during intermediary steps */\n  /* TODO use a fixed point library */\n  uint constant SHF = 30;\n\n  function doMakerPosthook() internal {\n    // a&b must be k bits at most\n    uint b = IERC20(b_addr).balanceOf(address(this)) >> SHF;\n    uint a = IERC20(a_addr).balanceOf(address(this)) >> SHF;\n\n    //console.log(\"b\",b);\n    //console.log(\"a\",a);\n\n    uint base_spread = 500; // base_spread is in basis points\n    uint d_d = 10000; // delta = d_n / d_d\n\n    // best offers\n    uint best_sell_id = mgv.best(a_addr, b_addr);\n    (P.OfferStruct memory best_sell, ) = mgv.offerInfo(a_addr, b_addr, best_sell_id);\n\n    //console.log(\"initial bs.w\",best_sell.wants);\n    //console.log(\"initial bs.g\",best_sell.gives);\n\n    // if no offer on a/b pair\n    if (\n      best_sell_id == sell_id || (best_sell.wants == 0 && best_sell.gives == 0)\n    ) {\n      //console.log(\"no offer on a/b pair\");\n      best_sell.wants = b;\n      best_sell.gives = a;\n    } else {\n      best_sell.wants = best_sell.wants >> SHF;\n      best_sell.gives = best_sell.gives >> SHF;\n    }\n\n    //console.log(\"bs.w\",best_sell.wants);\n    //console.log(\"bs.g\",best_sell.gives);\n\n    uint best_buy_id = mgv.best(b_addr, a_addr);\n    (P.OfferStruct memory best_buy, ) = mgv.offerInfo(b_addr, a_addr, best_buy_id);\n\n    //console.log(\"initial bb.w\",best_buy.wants);\n    //console.log(\"initial bb.g\",best_buy.gives);\n\n    // if no offer on b/a pair\n    if (best_buy_id == buy_id || (best_buy.wants == 0 && best_buy.gives == 0)) {\n      //console.log(\"no offer on b/a pair\");\n      best_buy.wants = a;\n      best_buy.gives = b;\n    } else {\n      best_buy.wants = best_buy.wants >> SHF;\n      best_buy.gives = best_buy.gives >> SHF;\n    }\n\n    //console.log(\"bb.w\",best_buy.wants);\n    //console.log(\"bb.g\",best_buy.gives);\n\n    // average price numerator (same for buy&sell)\n    // at most (96-SHF)*2+1 bits\n    uint m_n = best_sell.wants *\n      best_buy.wants +\n      best_sell.gives *\n      best_buy.gives;\n    //console.log(\"m_n\",m_n);\n\n    uint d_n = 10000 + base_spread; // at most 14 bits\n\n    /* SELL */\n    /********/\n    {\n      // midprice of A in B is m_n/sell_m_d\n      // at most (96-SHF)*2+1 bits\n      uint sell_m_d = 2 * best_sell.gives * best_buy.wants;\n      //console.log(\"sell_m_d\",sell_m_d);\n\n      uint sell_gives = a << SHF;\n      //console.log(\"sell_gives\",sell_gives);\n      // normalized_BA_inv_ratio = b / (2 * a * b)\n      // skew = 0.5 + inv/2 = (m_n * a + sell_m_d * b) / (2 * m_n * a)\n      // sell_wants = delta * midprice * a * skew\n\n      uint sell_wants_n = (d_n * (m_n * a + sell_m_d * b)) << (3 * SHF);\n      //console.log(\"sell_wants_n\",sell_wants_n);\n      uint sell_wants_d = (2 * sell_m_d * d_d) << (3 * SHF);\n      //console.log(\"sell_wants_d\",sell_wants_d);\n      uint sell_wants = (sell_wants_n / sell_wants_d) << SHF;\n\n      //console.log(\"sell_wants\",sell_wants);\n      //console.log(\"sell_gives\",sell_gives);\n      Display.log(sell_wants, sell_gives);\n\n      mgv.updateOffer({\n        outbound_tkn: a_addr,\n        inbound_tkn: b_addr,\n        wants: sell_wants,\n        gives: sell_gives,\n        gasreq: 400_000,\n        gasprice: 0,\n        pivotId: sell_id,\n        offerId: sell_id\n      });\n    }\n\n    /* BUY */\n    /*******/\n\n    uint buy_m_d = 2 * best_sell.wants * best_buy.gives;\n\n    uint buy_gives = b << SHF;\n\n    // buy_wants = buy_delta * buy_midprice * b * buy_skew;\n    uint buy_wants_n = d_n * (m_n * b + buy_m_d * a);\n    uint buy_wants_d = 2 * buy_m_d * d_d;\n    uint buy_wants = (buy_wants_n / buy_wants_d) << SHF;\n\n    mgv.updateOffer({\n      outbound_tkn: b_addr,\n      inbound_tkn: a_addr,\n      wants: buy_wants,\n      gives: buy_gives,\n      gasreq: 400_000,\n      gasprice: 0,\n      pivotId: buy_id,\n      offerId: buy_id\n    });\n  }\n}\n"
    },
    "contracts/Tests/Toolbox/ThrowCatch.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// We can't even encode storage references without the experimental encoder\npragma abicoder v2;\n\npragma solidity ^0.8.10;\nimport {Test as T} from \"@mangrovedao/hardhat-test-solidity/test.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Throw_Test {\n  bool called;\n\n  receive() external payable {}\n\n  function throws() external {\n    bytes memory s = new bytes(1000); //spend some gas\n    s;\n    called = true;\n  }\n\n  function not_enough_gas_to_call_test() public {\n    try this.throws{gas: 100}() {\n      T.fail(\"Function should have failed\");\n    } catch {\n      T.check(!called, \"Function should not have been called\");\n    }\n  }\n\n  function enough_gas_to_call_test() public {\n    try this.throws{gas: 1000}() {\n      T.fail(\"Function should have failed\");\n    } catch {\n      T.check(!called, \"Function should have run out of gas\");\n    }\n  }\n}\n"
    },
    "contracts/Tests/Toolbox/StorageEncoding.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n/* Testing bad storage encoding */\n\n// We can't even encode storage references without the experimental encoder\npragma abicoder v2;\n\npragma solidity ^0.8.10;\nimport {Test as TestEvents} from \"@mangrovedao/hardhat-test-solidity/test.sol\";\nimport \"hardhat/console.sol\";\n\ncontract StorageEncoding {}\n\nstruct S {\n  uint a;\n}\n\nlibrary Lib {\n  function a(S storage s) public view {\n    s; // silence warning about unused parameter\n    console.log(\"in Lib.a: calldata received\");\n    console.logBytes(msg.data);\n  }\n}\n\ncontract Failer_Test {\n  receive() external payable {}\n\n  function exec() external view {\n    console.log(\"exec\");\n    require(false);\n  }\n\n  function execBig() external view {\n    console.log(\"execBig\");\n    string memory wtf = new string(100_000);\n    require(false, wtf);\n  }\n\n  function failed_yul_test() public {\n    bytes memory b = new bytes(100_000);\n    b;\n    uint g0 = gasleft();\n    bytes memory cd = abi.encodeWithSelector(this.execBig.selector);\n    bytes memory retdata = new bytes(32);\n    assembly {\n      let success := delegatecall(\n        500000,\n        address(),\n        add(cd, 32),\n        4,\n        add(retdata, 32),\n        0\n      )\n    }\n    console.log(\"GasUsed: %d\", g0 - gasleft());\n  }\n\n  function failer_small_test() public {\n    uint g0 = gasleft();\n    (bool success, bytes memory retdata) = address(this).delegatecall{\n      gas: 500_000\n    }(abi.encodeWithSelector(this.exec.selector));\n    success;\n    retdata;\n    console.log(\"GasUsed: %d\", g0 - gasleft());\n  }\n\n  function failer_big_with_retdata_bytes_test() public {\n    bytes memory b = new bytes(100_000);\n    b;\n    uint g0 = gasleft();\n    (bool success, bytes memory retdata) = address(this).delegatecall{\n      gas: 500_000\n    }(abi.encodeWithSelector(this.execBig.selector));\n    success;\n    retdata;\n\n    console.log(\"GasUsed: %d\", g0 - gasleft());\n  }\n}\n\ncontract StorageEncoding_Test {\n  receive() external payable {}\n\n  S sss; // We add some padding so the storage ref for s is not 0\n  S ss;\n  S s;\n\n  function _test() public {\n    console.log(\"Lib.a selector:\");\n    console.logBytes4(Lib.a.selector);\n    console.log(\"___________________\");\n\n    console.log(\"[Encoding s manually]\");\n    console.log(\"abi.encodeWithSelector(Lib.a.selector,s)):\");\n    bytes memory data = abi.encodeWithSelector(Lib.a.selector, s);\n    console.logBytes(data);\n    console.log(\"Calling address(Lib).delegatecall(u)...\");\n    bool success;\n    (success, ) = address(Lib).delegatecall(data);\n    console.log(\"___________________\");\n\n    console.log(\"[Encoding s with compiler]\");\n    console.log(\"Calling Lib.a(s)...\");\n    Lib.a(s);\n    console.log(\"___________________\");\n  }\n}\n\ncontract Abi_Test {\n  receive() external payable {}\n\n  function wordOfBytes(bytes memory data) internal pure returns (bytes32 w) {\n    assembly {\n      w := mload(add(data, 32))\n    }\n  }\n\n  function bytesOfWord(bytes32 w) internal pure returns (bytes memory data) {\n    data = new bytes(32);\n    assembly {\n      mstore(add(data, 32), w)\n    }\n  }\n\n  function wordOfUint(uint x) internal pure returns (bytes32 w) {\n    w = bytes32(x);\n  }\n\n  enum Arity {\n    N,\n    U,\n    B,\n    T\n  }\n  bytes32 constant MASKHEADER =\n    0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  bytes32 constant MASKFIRSTARG =\n    0x00000000000000000000000000ffffffffffffffffffffffffffffffffffffff;\n\n  function encode_decode_test() public {\n    bytes memory x = abi.encodePacked(\n      Arity.B,\n      uint96(1 ether),\n      uint96(2 ether)\n    );\n    bytes32 w = wordOfBytes(x);\n    console.logBytes32(w);\n    console.logBytes32(w >> (31 * 8));\n    bytes memory header = bytesOfWord(w >> (31 * 8)); // header is encode in the first byte\n    Arity t = abi.decode(header, (Arity));\n    TestEvents.check(t == Arity.B, \"Incorrect decoding of header\");\n    bytes memory arg1 = bytesOfWord((w & MASKHEADER) >> (19 * 8));\n    console.logBytes(arg1);\n    TestEvents.check(\n      uint96(1 ether) == abi.decode(arg1, (uint96)),\n      \"Incorrect decoding of arg1\"\n    );\n    bytes memory arg2 = bytesOfWord((w & MASKFIRSTARG) >> (7 * 8));\n    console.logBytes(arg2);\n    TestEvents.check(\n      uint96(2 ether) == abi.decode(arg2, (uint96)),\n      \"Incorrect decoding of arg2\"\n    );\n  }\n}\n\n// contract EncodeDecode_Test {\n//   receive() external payable {}\n//   enum T {U,B}\n\n//   function encode(uint192 x) internal view returns (bytes memory){\n//     console.log(\"encoding\",uint(x));\n//     bytes memory data = new bytes(32);\n//     data = abi.encode(T.U,abi.encode(x));\n//     console.logBytes(data);\n//     return data;\n//   }\n//   function encode(uint96 x, uint96 y) internal view returns (bytes memory){\n//     console.log(\"encoding\",uint(x),uint(y));\n\n//     bytes memory data = new bytes(32);\n//     data = abi.encode(T.B,abi.encode(x,y));\n//     console.logBytes(data);\n//     return data;\n//   }\n\n//   function decode(bytes memory data) internal view returns (uint[] memory) {\n//     console.log(\"Decoding\");\n//     console.logBytes(data);\n//     (T t,bytes memory data_) = abi.decode(data,(T,bytes));\n//     if (t==T.B) {\n//       console.log(\"Binary predicate detected\");\n//       uint[] memory args = new uint[](2);\n//       (uint96 x, uint96 y) = abi.decode(data_,(uint96,uint96));\n//       args[0] = uint(x);\n//       args[1] = uint(y);\n//       return args;\n//     }\n//     else{\n//       console.log(\"Unary predicate detected\");\n//       uint[] memory args = new uint[](1);\n//       args[0] = uint(abi.decode(data_,(uint192)));\n//       return args;\n//     }\n//   }\n\n//   function encode_decode(uint x) internal view {\n//     bytes memory data = encode(uint192(x));\n//     uint[] memory args = decode(data);\n//     for (uint i=0;i<args.length;i++){\n//       console.log(args[i]);\n//     }\n//   }\n\n//   function encode_decode(uint x, uint y) internal view {\n//     bytes memory data = encode(uint96(x), uint96(y));\n//     uint[] memory args = decode(data);\n//     for (uint i=0;i<args.length;i++){\n//       console.log(args[i]);\n//     }\n//   }\n\n//   function encode_decode_test() public view {\n//     encode_decode(123456789);\n//     encode_decode(1234,56789);\n//   }\n\n// }\n"
    },
    "contracts/Tests/MgvReader_Test.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\nimport {MgvReader} from \"../periphery/MgvReader.sol\";\n\ncontract Oracle {\n  function read(address /*base*/, address /*quote*/)\n    external\n    pure\n    returns (uint, uint)\n  {\n    return (23, 2);\n  }\n}\n\n// In these tests, the testing contract is the market maker.\ncontract MgvReader_Test is HasMgvEvents {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  MgvReader reader;\n  address base;\n  address quote;\n  Oracle oracle;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    oracle = new Oracle();\n\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    mkr = MakerSetup.setup(mgv, base, quote);\n    reader = new MgvReader(address(mgv));\n\n    payable(mkr).transfer(10 ether);\n\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    mkr.provisionMgv(5 ether);\n\n    baseT.mint(address(this), 2 ether);\n    quoteT.mint(address(mkr), 1 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  function read_packed_test() public {\n    (\n      uint currentId,\n      uint[] memory offerIds,\n      P.OfferStruct[] memory offers,\n      P.OfferDetailStruct[] memory details\n    ) = reader.offerList(base, quote, 0, 50);\n\n    TestEvents.eq(offerIds.length, 0, \"ids: wrong length on 2elem\");\n    TestEvents.eq(offers.length, 0, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 0, \"details: wrong length on 1elem\");\n    // test 1 elem\n    mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      50\n    );\n\n    TestEvents.eq(offerIds.length, 1, \"ids: wrong length on 1elem\");\n    TestEvents.eq(offers.length, 1, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 1, \"details: wrong length on 1elem\");\n\n    // test 2 elem\n    mkr.newOffer(0.9 ether, 1 ether, 10_000, 0);\n\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      50\n    );\n\n    TestEvents.eq(offerIds.length, 2, \"ids: wrong length on 2elem\");\n    TestEvents.eq(offers.length, 2, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 2, \"details: wrong length on 1elem\");\n\n    // test 2 elem read from elem 1\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      1,\n      50\n    );\n    TestEvents.eq(\n      offerIds.length,\n      1,\n      \"ids: wrong length 2elem start from id 1\"\n    );\n    TestEvents.eq(offers.length, 1, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 1, \"details: wrong length on 1elem\");\n\n    // test 3 elem read in chunks of 2\n    mkr.newOffer(0.8 ether, 1 ether, 10_000, 0);\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      2\n    );\n    TestEvents.eq(\n      offerIds.length,\n      2,\n      \"ids: wrong length on 3elem chunk size 2\"\n    );\n    TestEvents.eq(offers.length, 2, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 2, \"details: wrong length on 1elem\");\n\n    // test offer order\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      50\n    );\n    TestEvents.eq(offers[0].wants, 0.8 ether, \"wrong wants for offers[0]\");\n    TestEvents.eq(offers[1].wants, 0.9 ether, \"wrong wants for offers[0]\");\n    TestEvents.eq(offers[2].wants, 1 ether, \"wrong wants for offers[0]\");\n  }\n\n  function returns_zero_on_nonexisting_offer_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n    mkr.retractOffer(ofr);\n    (, uint[] memory offerIds, , ) = reader.offerList(base, quote, ofr, 50);\n    TestEvents.eq(\n      offerIds.length,\n      0,\n      \"should have 0 offers since starting point is out of the book\"\n    );\n  }\n\n  function no_wasted_time_test() public {\n    reader.offerList(base, quote, 0, 50); // warming up caches\n\n    uint g = gasleft();\n    reader.offerList(base, quote, 0, 50);\n    uint used1 = g - gasleft();\n\n    g = gasleft();\n    reader.offerList(base, quote, 0, 50000000);\n    uint used2 = g - gasleft();\n\n    TestEvents.eq(\n      used1,\n      used2,\n      \"gas spent should not depend on maxOffers when offers length < maxOffers\"\n    );\n  }\n\n  function correct_endpoints_0_test() public {\n    uint startId;\n    uint length;\n    (startId, length) = reader.offerListEndPoints(base, quote, 0, 100000);\n    TestEvents.eq(startId, 0, \"0.0 wrong startId\");\n    TestEvents.eq(length, 0, \"0.0 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 32, 100000);\n    TestEvents.eq(startId, 0, \"0.1 wrong startId\");\n    TestEvents.eq(length, 0, \"0.1 wrong length\");\n  }\n\n  function correct_endpoints_1_test() public {\n    uint startId;\n    uint length;\n    uint ofr;\n    ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 0, 0);\n    TestEvents.eq(startId, 1, \"1.0 wrong startId\");\n    TestEvents.eq(length, 0, \"1.0 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 1, 1);\n    TestEvents.eq(startId, 1, \"1.1 wrong startId\");\n    TestEvents.eq(length, 1, \"1.1 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 1, 1321);\n    TestEvents.eq(startId, 1, \"1.2 wrong startId\");\n    TestEvents.eq(length, 1, \"1.2 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 2, 12);\n    TestEvents.eq(startId, 0, \"1.0 wrong startId\");\n    TestEvents.eq(length, 0, \"1.0 wrong length\");\n  }\n\n  function try_provision() internal {\n    uint prov = reader.getProvision(base, quote, 0, 0);\n    uint bal1 = mgv.balanceOf(address(mkr));\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n    uint bal2 = mgv.balanceOf(address(mkr));\n    TestEvents.eq(bal1 - bal2, prov, \"provision computation is wrong\");\n  }\n\n  function provision_0_test() public {\n    try_provision();\n  }\n\n  function provision_1_test() public {\n    mgv.setGasbase(base, quote, 17_000);\n    try_provision();\n  }\n\n  function provision_oracle_test() public {\n    mgv.setMonitor(address(oracle));\n    mgv.setUseOracle(true);\n    try_provision();\n  }\n}\n"
    },
    "contracts/periphery/MgvReader.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvReader.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, P} from \"../MgvLib.sol\";\n\ninterface MangroveLike {\n  function best(address, address) external view returns (uint);\n\n  function offers(\n    address,\n    address,\n    uint\n  ) external view returns (P.Offer.t);\n\n  function offerDetails(\n    address,\n    address,\n    uint\n  ) external view returns (P.OfferDetail.t);\n\n  function offerInfo(\n    address,\n    address,\n    uint\n  ) external view returns (P.OfferStruct memory, P.OfferDetailStruct memory);\n\n  function config(address, address) external view returns (P.Global.t, P.Local.t);\n}\n\ncontract MgvReader {\n  using P.Offer for P.Offer.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  MangroveLike immutable mgv;\n\n  constructor(address _mgv) {\n    mgv = MangroveLike(payable(_mgv));\n  }\n\n  /*\n   * Returns two uints.\n   *\n   * `startId` is the id of the best live offer with id equal or greater than\n   * `fromId`, 0 if there is no such offer.\n   *\n   * `length` is 0 if `startId == 0`. Other it is the number of live offers as good or worse than the offer with\n   * id `startId`.\n   */\n  function offerListEndPoints(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  ) public view returns (uint startId, uint length) { unchecked {\n    if (fromId == 0) {\n      startId = mgv.best(outbound_tkn, inbound_tkn);\n    } else {\n      startId = mgv.offers(outbound_tkn, inbound_tkn, fromId).gives()\n      > 0\n        ? fromId\n        : 0;\n    }\n\n    uint currentId = startId;\n\n    while (currentId != 0 && length < maxOffers) {\n      currentId = mgv.offers(outbound_tkn, inbound_tkn, currentId).next();\n      length = length + 1;\n    }\n\n    return (startId, length);\n  }}\n\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in packed form. First number is id of next offer (0 is we're done). First array is ids, second is offers (as bytes32), third is offerDetails (as bytes32). Array will be of size `min(# of offers in out/in list, maxOffers)`.\n  function packedOfferList(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    public\n    view\n    returns (\n      uint,\n      uint[] memory,\n      P.Offer.t[] memory,\n      P.OfferDetail.t[] memory\n    )\n  { unchecked {\n    (uint currentId, uint length) = offerListEndPoints(\n      outbound_tkn,\n      inbound_tkn,\n      fromId,\n      maxOffers\n    );\n\n    uint[] memory offerIds = new uint[](length);\n    P.Offer.t[] memory offers = new P.Offer.t[](length);\n    P.OfferDetail.t[] memory details = new P.OfferDetail.t[](length);\n\n    uint i = 0;\n\n    while (currentId != 0 && i < length) {\n      offerIds[i] = currentId;\n      offers[i] = mgv.offers(outbound_tkn, inbound_tkn, currentId);\n      details[i] = mgv.offerDetails(outbound_tkn, inbound_tkn, currentId);\n      currentId = offers[i].next();\n      i = i + 1;\n    }\n\n    return (currentId, offerIds, offers, details);\n  }}\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in unpacked form. First number is id of next offer (0 if we're done). First array is ids, second is offers (as structs), third is offerDetails (as structs). Array will be of size `min(# of offers in out/in list, maxOffers)`.\n  function offerList(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    public\n    view\n    returns (\n      uint,\n      uint[] memory,\n      P.OfferStruct[] memory,\n      P.OfferDetailStruct[] memory\n    )\n  { unchecked {\n    (uint currentId, uint length) = offerListEndPoints(\n      outbound_tkn,\n      inbound_tkn,\n      fromId,\n      maxOffers\n    );\n\n    uint[] memory offerIds = new uint[](length);\n    P.OfferStruct[] memory offers = new P.OfferStruct[](length);\n    P.OfferDetailStruct[] memory details = new P.OfferDetailStruct[](length);\n\n    uint i = 0;\n    while (currentId != 0 && i < length) {\n      offerIds[i] = currentId;\n      (offers[i], details[i]) = mgv.offerInfo(\n        outbound_tkn,\n        inbound_tkn,\n        currentId\n      );\n      currentId = offers[i].next;\n      i = i + 1;\n    }\n\n    return (currentId, offerIds, offers, details);\n  }}\n\n  function getProvision(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint ofr_gasreq,\n    uint ofr_gasprice\n  ) external view returns (uint) { unchecked {\n    (P.Global.t global, P.Local.t local) = mgv.config(outbound_tkn, inbound_tkn);\n    uint _gp;\n    uint global_gasprice = global.gasprice();\n    if (global_gasprice > ofr_gasprice) {\n      _gp = global_gasprice;\n    } else {\n      _gp = ofr_gasprice;\n    }\n    return\n      (ofr_gasreq + local.offer_gasbase()) *\n      _gp *\n      10**9;\n  }}\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/MultiUser.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangroveOffer.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../MangroveOffer.sol\";\nimport \"../../../periphery/MgvReader.sol\";\nimport \"../../interfaces/IOfferLogicMulti.sol\";\n\nabstract contract MultiUser is IOfferLogicMulti, MangroveOffer {\n  mapping(address => mapping(address => mapping(uint => address)))\n    internal _offerOwners; // outbound_tkn => inbound_tkn => offerId => ownerAddress\n\n  mapping(address => uint) public mgvBalance; // owner => WEI balance on mangrove\n  mapping(address => mapping(address => uint)) public tokenBalanceOf; // erc20 => owner => balance on `this`\n\n  function tokenBalance(address token) external view override returns (uint) {\n    return tokenBalanceOf[token][msg.sender];\n  }\n\n  function balanceOnMangrove() external view override returns (uint) {\n    return mgvBalance[msg.sender];\n  }\n\n  function offerOwners(\n    address reader,\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    public\n    view\n    override\n    returns (\n      uint nextId,\n      uint[] memory offerIds,\n      address[] memory __offerOwners\n    )\n  {\n    (\n      nextId,\n      offerIds, /*offers*/ /*offerDetails*/\n      ,\n\n    ) = MgvReader(reader).offerList(\n      outbound_tkn,\n      inbound_tkn,\n      fromId,\n      maxOffers\n    );\n    __offerOwners = new address[](offerIds.length);\n    for (uint i = 0; i < offerIds.length; i++) {\n      __offerOwners[i] = ownerOf(outbound_tkn, inbound_tkn, offerIds[i]);\n    }\n  }\n\n  function creditOnMgv(address owner, uint balance) internal {\n    mgvBalance[owner] += balance;\n    emit CreditMgvUser(owner, balance);\n  }\n\n  function debitOnMgv(address owner, uint amount) internal {\n    require(mgvBalance[owner] >= amount, \"Multi/debitOnMgv/insufficient\");\n    mgvBalance[owner] -= amount;\n    emit DebitMgvUser(owner, amount);\n  }\n\n  function creditToken(\n    address token,\n    address owner,\n    uint amount\n  ) internal {\n    tokenBalanceOf[token][owner] += amount;\n    emit CreditUserTokenBalance(owner, token, amount);\n  }\n\n  function debitToken(\n    address token,\n    address owner,\n    uint amount\n  ) internal {\n    if (amount == 0) {\n      return;\n    }\n    require(\n      tokenBalanceOf[token][owner] >= amount,\n      \"Multi/debitToken/insufficient\"\n    );\n    tokenBalanceOf[token][owner] -= amount;\n    emit DebitUserTokenBalance(owner, token, amount);\n  }\n\n  function redeemToken(\n    address token,\n    address receiver,\n    uint amount\n  ) external override returns (bool success) {\n    require(msg.sender != address(this), \"Mutli/noReentrancy\");\n    debitToken(token, msg.sender, amount);\n    success = IEIP20(token).transfer(receiver, amount);\n  }\n\n  function depositToken(address token, uint amount)\n    external\n    override\n    returns (\n      //override\n      bool success\n    )\n  {\n    uint balBefore = IEIP20(token).balanceOf(address(this));\n    success = IEIP20(token).transferFrom(msg.sender, address(this), amount);\n    require(\n      IEIP20(token).balanceOf(address(this)) - balBefore == amount,\n      \"Multi/transferFail\"\n    );\n    creditToken(token, msg.sender, amount);\n  }\n\n  function addOwner(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    address owner\n  ) internal {\n    _offerOwners[outbound_tkn][inbound_tkn][offerId] = owner;\n    emit NewOwnedOffer(outbound_tkn, inbound_tkn, offerId, owner);\n  }\n\n  function ownerOf(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  ) public view override returns (address owner) {\n    owner = _offerOwners[outbound_tkn][inbound_tkn][offerId];\n    require(owner != address(0), \"multiUser/unkownOffer\");\n  }\n\n  /// withdraws ETH from the bounty vault of the Mangrove.\n  /// NB: `Mangrove.fund` function need not be called by `this` so is not included here.\n  /// Warning: this function should not be called internally for msg.sender provision is being checked\n  function withdrawFromMangrove(address payable receiver, uint amount)\n    external\n    override\n    returns (bool noRevert)\n  {\n    require(msg.sender != address(this), \"Mutli/noReentrancy\");\n    debitOnMgv(msg.sender, amount);\n    return _withdrawFromMangrove(receiver, amount);\n  }\n\n  function fundMangrove() external payable override // override\n  {\n    require(msg.sender != address(this), \"Mutli/noReentrancy\");\n    fundMangroveInternal(msg.sender, msg.value);\n  }\n\n  function fundMangroveInternal(address caller, uint provision) internal {\n    // increasing the provision of `this` contract\n    MGV.fund{value: provision}();\n    // increasing the virtual provision of owner\n    creditOnMgv(caller, provision);\n  }\n\n  function updateUserBalanceOnMgv(address user, uint mgvBalanceBefore)\n    internal\n  {\n    uint mgvBalanceAfter = MGV.balanceOf(address(this));\n    if (mgvBalanceAfter == mgvBalanceBefore) {\n      return;\n    }\n    if (mgvBalanceAfter > mgvBalanceBefore) {\n      creditOnMgv(user, mgvBalanceAfter - mgvBalanceBefore);\n    } else {\n      debitOnMgv(user, mgvBalanceBefore - mgvBalanceAfter);\n    }\n  }\n\n  function newOffer(\n    address outbound_tkn, // address of the ERC20 contract managing outbound tokens\n    address inbound_tkn, // address of the ERC20 contract managing outbound tokens\n    uint wants, // amount of `inbound_tkn` required for full delivery\n    uint gives, // max amount of `outbound_tkn` promised by the offer\n    uint gasreq, // max gas required by the offer when called. If maxUint256 is used here, default `OFR_GASREQ` will be considered instead\n    uint gasprice, // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\n    uint pivotId // identifier of an offer in the (`outbound_tkn,inbound_tkn`) Offer List after which the new offer should be inserted (gas cost of insertion will increase if the `pivotId` is far from the actual position of the new offer)\n  ) external payable override returns (uint offerId) {\n    require(msg.sender != address(this), \"Mutli/noReentrancy\");\n    offerId = newOfferInternal(\n      outbound_tkn,\n      inbound_tkn,\n      wants,\n      gives,\n      gasreq,\n      gasprice,\n      pivotId,\n      msg.sender,\n      msg.value\n    );\n  }\n\n  function newOfferInternal(\n    address outbound_tkn, // address of the ERC20 contract managing outbound tokens\n    address inbound_tkn, // address of the ERC20 contract managing outbound tokens\n    uint wants, // amount of `inbound_tkn` required for full delivery\n    uint gives, // max amount of `outbound_tkn` promised by the offer\n    uint gasreq, // max gas required by the offer when called. If maxUint256 is used here, default `OFR_GASREQ` will be considered instead\n    uint gasprice, // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\n    uint pivotId,\n    address caller,\n    uint provision\n  ) internal returns (uint) {\n    uint weiBalanceBefore = MGV.balanceOf(address(this));\n    if (gasreq > type(uint24).max) {\n      gasreq = OFR_GASREQ;\n    }\n    // this call could revert if this contract does not have the provision to cover the bounty\n    try\n      MGV.newOffer{value: provision}(\n        outbound_tkn,\n        inbound_tkn,\n        wants,\n        gives,\n        gasreq,\n        gasprice,\n        pivotId\n      )\n    returns (uint offerId) {\n      //setting owner of offerId\n      addOwner(outbound_tkn, inbound_tkn, offerId, caller);\n      //updating wei balance of owner will revert if msg.sender does not have the funds\n      updateUserBalanceOnMgv(caller, weiBalanceBefore);\n      return offerId;\n    } catch Error(string memory message) {\n      if (msg.sender == address(MGV)) {\n        // if `this` is executing a Mangrove trade do not throw by default\n        return 0;\n      } else {\n        // if `this` is executing an offchain tx, throw\n        revert(message);\n      }\n    }\n  }\n\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external payable override {\n    updateOfferInternal(\n      outbound_tkn,\n      inbound_tkn,\n      wants,\n      gives,\n      gasreq,\n      gasprice,\n      pivotId,\n      offerId,\n      msg.sender,\n      msg.value\n    );\n  }\n\n  function updateOfferInternal(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId,\n    address caller,\n    uint provision // dangerous to use msg.value in a internal call\n  ) internal returns (uint) {\n    require(\n      caller == ownerOf(outbound_tkn, inbound_tkn, offerId),\n      \"Multi/updateOffer/unauthorized\"\n    );\n    uint weiBalanceBefore = MGV.balanceOf(address(this));\n    if (gasreq > type(uint24).max) {\n      gasreq = OFR_GASREQ;\n    }\n    try\n      MGV.updateOffer{value: provision}(\n        outbound_tkn,\n        inbound_tkn,\n        wants,\n        gives,\n        gasreq,\n        gasprice,\n        pivotId,\n        offerId\n      )\n    {\n      updateUserBalanceOnMgv(caller, weiBalanceBefore);\n      return offerId;\n    } catch Error(string memory message) {\n      if (msg.sender == address(MGV)) {\n        return 0;\n      } else {\n        revert(message);\n      }\n    }\n  }\n\n  // Retracts `offerId` from the (`outbound_tkn`,`inbound_tkn`) Offer list of Mangrove. Function call will throw if `this` contract is not the owner of `offerId`.\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\n  ) external override returns (uint received) {\n    received = retractOfferInternal(\n      outbound_tkn,\n      inbound_tkn,\n      offerId,\n      deprovision,\n      msg.sender\n    );\n  }\n\n  function retractOfferInternal(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision,\n    address caller\n  ) internal returns (uint received) {\n    require(\n      _offerOwners[outbound_tkn][inbound_tkn][offerId] == caller,\n      \"Multi/retractOffer/unauthorized\"\n    );\n    received = MGV.retractOffer(\n      outbound_tkn,\n      inbound_tkn,\n      offerId,\n      deprovision\n    );\n    if (received > 0) {\n      creditOnMgv(caller, received);\n    }\n  }\n\n  function getMissingProvision(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq,\n    uint gasprice,\n    uint offerId\n  ) public view override returns (uint) {\n    uint balance;\n    if (offerId != 0) {\n      address owner = ownerOf(outbound_tkn, inbound_tkn, offerId);\n      balance = mgvBalance[owner];\n    }\n    return\n      _getMissingProvision(\n        balance,\n        outbound_tkn,\n        inbound_tkn,\n        gasreq,\n        gasprice,\n        offerId\n      );\n  }\n\n  // put received inbound tokens on offer owner account\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    creditToken(order.inbound_tkn, owner, amount);\n    return 0;\n  }\n\n  // get outbound tokens from offer owner account\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    uint ownerBalance = tokenBalanceOf[order.outbound_tkn][owner];\n    if (ownerBalance < amount) {\n      debitToken(order.outbound_tkn, owner, ownerBalance);\n      return (amount - ownerBalance);\n    } else {\n      debitToken(order.outbound_tkn, owner, amount);\n      return 0;\n    }\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/MangroveOffer.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangroveOffer.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../lib/AccessControlled.sol\";\nimport \"../interfaces/IOfferLogic.sol\";\nimport \"../interfaces/IMangrove.sol\";\nimport \"../interfaces/IEIP20.sol\";\n\n// Naming scheme:\n// `f() public`: can be used as is in all descendants of `this` contract\n// `_f() internal`: descendant of this contract should provide a public wrapper of this function\n// `__f__() virtual internal`: descendant of this contract may override this function to specialize the strat\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nabstract contract MangroveOffer is AccessControlled, IOfferLogic {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n\n  bytes32 immutable RENEGED = \"MangroveOffer/reneged\";\n  bytes32 immutable PUTFAILURE = \"MangroveOffer/putFailure\";\n  bytes32 immutable OUTOFLIQUIDITY = \"MangroveOffer/outOfLiquidity\";\n\n  // The deployed Mangrove contract\n  IMangrove public immutable MGV;\n\n  // `this` contract entypoint is `makerExecute` or `makerPosthook` if `msg.sender == address(MGV)`\n  // `this` contract was called on an admin function iff `msg.sender = admin`\n  modifier mgvOrAdmin() {\n    require(\n      msg.sender == admin || msg.sender == address(MGV),\n      \"AccessControlled/Invalid\"\n    );\n    _;\n  }\n  // default values\n  uint public override OFR_GASREQ = 100_000;\n\n  // necessary function to withdraw funds from Mangrove\n  receive() external payable virtual {}\n\n  constructor(address payable _mgv) {\n    MGV = IMangrove(_mgv);\n  }\n\n  /////// Mandatory callback functions\n\n  // `makerExecute` is the callback function to execute all offers that were posted on Mangrove by `this` contract.\n  // it may not be overriden although it can be customized using `__lastLook__`, `__put__` and `__get__` hooks.\n  // NB #1: When overriding the above hooks, the Offer Makers should make sure they do not revert in order if they wish to post logs in case of bad executions.\n  // NB #2: if `makerExecute` does revert, the offer will be considered to be refusing the trade.\n  // NB #3: `makerExecute` must return the empty bytes to signal to MGV it wishes to perform the trade. Any other returned byes will signal to MGV that `this` contract does not wish to proceed with the trade\n  // NB #4: Reneging on trade by either reverting or returning non empty bytes will have the following effects:\n  // * Offer is removed from the Order Book\n  // * Offer bounty will be withdrawn from offer provision and sent to the offer taker. The remaining provision will be credited to the maker account on Mangrove\n  function makerExecute(ML.SingleOrder calldata order)\n    external\n    override\n    onlyCaller(address(MGV))\n    returns (bytes32 ret)\n  {\n    if (!__lastLook__(order)) {\n      // hook to check order details and decide whether `this` contract should renege on the offer.\n      emit Reneged(order.outbound_tkn, order.inbound_tkn, order.offerId);\n      return RENEGED;\n    }\n    uint missingPut = __put__(order.gives, order); // implements what should be done with the liquidity that is flashswapped by the offer taker to `this` contract\n    if (missingPut > 0) {\n      emit PutFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        missingPut\n      );\n      return PUTFAILURE;\n    }\n    uint missingGet = __get__(order.wants, order); // implements how `this` contract should make the outbound tokens available\n    if (missingGet > 0) {\n      emit GetFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        missingGet\n      );\n      return OUTOFLIQUIDITY;\n    }\n  }\n\n  // `makerPosthook` is the callback function that is called by Mangrove *after* the offer execution.\n  // It may not be overriden although it can be customized via the post-hooks `__posthookSuccess__`, `__posthookGetFailure__`, `__posthookReneged__` and `__posthookFallback__` (see below).\n  // Offer Maker SHOULD make sure the overriden posthooks do not revert in order to be able to post logs in case of bad executions.\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override onlyCaller(address(MGV)) {\n    if (result.mgvData == \"mgv/tradeSuccess\") {\n      // if trade was a success\n      __posthookSuccess__(order);\n      return;\n    }\n    // if trade was aborted because of a lack of liquidity\n    if (result.makerData == OUTOFLIQUIDITY) {\n      __posthookGetFailure__(order);\n      return;\n    }\n    // if trade was reneged on during lastLook\n    if (result.makerData == RENEGED) {\n      __posthookReneged__(order);\n      return;\n    }\n    // if trade failed unexpectedly (`makerExecute` reverted or Mangrove failed to transfer the outbound tokens to the Offer Taker)\n    __posthookFallback__(order, result);\n    return;\n  }\n\n  // sets default gasreq for `new/updateOffer`\n  function setGasreq(uint gasreq) public override mgvOrAdmin {\n    require(uint24(gasreq) == gasreq, \"MangroveOffer/gasreq/overflow\");\n    OFR_GASREQ = gasreq;\n  }\n\n  /// `this` contract needs to approve Mangrove to let it perform outbound token transfer at the end of the `makerExecute` function\n  /// NB anyone can call this function\n  function approveMangrove(address outbound_tkn, uint amount) public {\n    require(\n      IEIP20(outbound_tkn).approve(address(MGV), amount),\n      \"mgvOffer/approve/Fail\"\n    );\n  }\n\n  /// withdraws ETH from the bounty vault of the Mangrove.\n  function _withdrawFromMangrove(address payable receiver, uint amount)\n    internal\n    returns (bool noRevert)\n  {\n    require(MGV.withdraw(amount), \"MangroveOffer/withdraw/transferFail\");\n    if (receiver != address(this)) {\n      (noRevert, ) = receiver.call{value: amount}(\"\");\n    } else {\n      noRevert = true;\n    }\n  }\n\n  // returns missing provision to repost `offerId` at given `gasreq` and `gasprice`\n  // if `offerId` is not in the Order Book, will simply return how much is needed to post\n  function _getMissingProvision(\n    uint balance, // offer owner balance on Mangrove\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq, // give > type(uint24).max to use `this.OFR_GASREQ()`\n    uint gasprice, // give 0 to use Mangrove's gasprice\n    uint offerId // set this to 0 if one is not reposting an offer\n  ) internal view returns (uint) {\n    (P.Global.t globalData, P.Local.t localData) = MGV.config(\n      outbound_tkn,\n      inbound_tkn\n    );\n    P.OfferDetail.t offerDetailData = MGV.offerDetails(\n      outbound_tkn,\n      inbound_tkn,\n      offerId\n    );\n    uint _gp;\n    if (globalData.gasprice() > gasprice) {\n      _gp = globalData.gasprice();\n    } else {\n      _gp = gasprice;\n    }\n    if (gasreq > type(uint24).max) {\n      gasreq = OFR_GASREQ;\n    }\n    uint bounty = (gasreq + localData.offer_gasbase()) * _gp * 10**9; // in WEI\n    // if `offerId` is not in the OfferList, all returned values will be 0\n    uint currentProvisionLocked = (offerDetailData.gasreq() +\n      offerDetailData.offer_gasbase()) *\n      offerDetailData.gasprice() *\n      10**9;\n    uint currentProvision = currentProvisionLocked + balance;\n    return (currentProvision >= bounty ? 0 : bounty - currentProvision);\n  }\n\n  ////// Default Customizable hooks for Taker Order'execution\n\n  // Define this hook to describe where the inbound token, which are brought by the Offer Taker, should go during Taker Order's execution.\n  // Usage of this hook is the following:\n  // * `amount` is the amount of `inbound` tokens whose deposit location is to be defined when entering this function\n  // * `order` is a recall of the taker order that is at the origin of the current trade.\n  // * Function must return `missingPut` (<=`amount`), which is the amount of `inbound` tokens whose deposit location has not been decided (possibly because of a failure) during this function execution\n  // NB in case of preceding executions of descendant specific `__put__` implementations, `amount` might be lower than `order.gives` (how much `inbound` tokens the taker gave)\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint missingPut);\n\n  // Define this hook to implement fetching `amount` of outbound tokens, possibly from another source than `this` contract during Taker Order's execution.\n  // Usage of this hook is the following:\n  // * `amount` is the amount of `outbound` tokens that still needs to be brought to the balance of `this` contract when entering this function\n  // * `order` is a recall of the taker order that is at the origin of the current trade.\n  // * Function must return `missingGet` (<=`amount`), which is the amount of `outbound` tokens still need to be fetched at the end of this function\n  // NB in case of preceding executions of descendant specific `__get__` implementations, `amount` might be lower than `order.wants` (how much `outbound` tokens the taker wants)\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint missingGet);\n\n  // Override this hook to implement a last look check during Taker Order's execution.\n  // Return value should be `true` if Taker Order is acceptable.\n  // Returning `false` will cause `MakerExecute` to return the \"RENEGED\" bytes, which are interpreted by MGV as a signal that `this` contract wishes to cancel the trade\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (bool proceed)\n  {\n    order; //shh\n    proceed = true;\n  }\n\n  ////// Customizable post-hooks.\n\n  // Override this post-hook to implement what `this` contract should do when called back after a successfully executed order.\n  function __posthookSuccess__(ML.SingleOrder calldata order) internal virtual {\n    order; // shh\n  }\n\n  // Override this post-hook to implement what `this` contract should do when called back after an order that failed to be executed because of a lack of liquidity (most inner call to `__get__` returned a non zero value).\n  function __posthookGetFailure__(ML.SingleOrder calldata order)\n    internal\n    virtual\n  {\n    order;\n  }\n\n  // Override this post-hook to implement what `this` contract should do when called back after an order that did not pass its last look (most inner call to `__lastLook__` returned `false`).\n  function __posthookReneged__(ML.SingleOrder calldata order) internal virtual {\n    order; //shh\n  }\n\n  // Override this post-hook to implement fallback behavior when Taker Order's execution failed unexpectedly. Information from Mangrove is accessible in `result.mgvData` for logging purpose.\n  function __posthookFallback__(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) internal virtual {\n    order;\n    result;\n  }\n}\n"
    },
    "contracts/Strategies/interfaces/IOfferLogicMulti.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// IOfferLogicMulti.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"./IOfferLogic.sol\";\n\ninterface IOfferLogicMulti is IOfferLogic {\n  /** Multi offer specific Events */\n  // Offer management\n  event NewOwnedOffer(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    address owner\n  );\n\n  // user provision on Mangrove has increased\n  event CreditMgvUser(address indexed user, uint amount);\n\n  // user provision on Mangrove has decreased\n  event DebitMgvUser(address indexed user, uint amount);\n\n  // user token balance on contract has increased\n  event CreditUserTokenBalance(\n    address indexed user,\n    address indexed token,\n    uint amount\n  );\n\n  // user token balance on contract has decreased\n  event DebitUserTokenBalance(\n    address indexed user,\n    address indexed token,\n    uint amount\n  );\n\n  function tokenBalance(address token) external view returns (uint);\n\n  function balanceOnMangrove() external view returns (uint);\n\n  function offerOwners(\n    address reader,\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    external\n    view\n    returns (\n      uint nextId,\n      uint[] memory offerIds,\n      address[] memory __offerOwners\n    );\n\n  function ownerOf(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  ) external view returns (address owner);\n\n  function depositToken(address token, uint amount)\n    external\n    returns (\n      //override\n      bool success\n    );\n\n  function fundMangrove() external payable;\n}\n"
    },
    "contracts/Strategies/lib/AccessControlled.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AccessedControlled.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\ncontract AccessControlled {\n  address public admin;\n\n  constructor() {\n    admin = msg.sender;\n  }\n\n  modifier onlyCaller(address caller) {\n    require(\n      caller == address(0) || msg.sender == caller,\n      \"AccessControlled/Invalid\"\n    );\n    _;\n  }\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"AccessControlled/Invalid\");\n    _;\n  }\n\n  function setAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n  }\n}\n"
    },
    "contracts/Strategies/interfaces/IOfferLogic.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SwingingMarketMaker.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity >=0.8.0;\npragma abicoder v2;\nimport \"./IMangrove.sol\";\n\ninterface IOfferLogic is IMaker {\n  ///////////////////\n  // MangroveOffer //\n  ///////////////////\n\n  /** @notice Events */\n\n  // Logged whenever something went wrong during `makerPosthook` execution\n  event PosthookFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId,\n    string message\n  );\n\n  // Logged whenever `__get__` hook failed to fetch the totality of the requested amount\n  event GetFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId,\n    uint missingAmount\n  );\n\n  // Logged whenever `__put__` hook failed to deposit the totality of the requested amount\n  event PutFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId,\n    uint missingAmount\n  );\n\n  // Logged whenever `__lastLook__` hook returned `false`\n  event Reneged(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId\n  );\n\n  // Log incident during pre/post trade execution\n  event LogIncident(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    bytes error_data\n  );\n\n  // Offer logic default gas required --value is used in update and new offer if maxUint is given\n  function OFR_GASREQ() external returns (uint);\n\n  // returns missing provision on Mangrove, should `offerId` be reposted using `gasreq` and `gasprice` parameters\n  // if `offerId` is not in the `outbound_tkn,inbound_tkn` offer list, the totality of the necessary provision is returned\n  function getMissingProvision(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq,\n    uint gasprice,\n    uint offerId\n  ) external view returns (uint);\n\n  // Changing OFR_GASREQ of the logic\n  function setGasreq(uint gasreq) external;\n\n  function redeemToken(\n    address token,\n    address receiver,\n    uint amount\n  ) external returns (bool success);\n\n  function approveMangrove(address outbound_tkn, uint amount) external;\n\n  function withdrawFromMangrove(address payable receiver, uint amount)\n    external\n    returns (bool noRevert);\n\n  function newOffer(\n    address outbound_tkn, // address of the ERC20 contract managing outbound tokens\n    address inbound_tkn, // address of the ERC20 contract managing outbound tokens\n    uint wants, // amount of `inbound_tkn` required for full delivery\n    uint gives, // max amount of `outbound_tkn` promised by the offer\n    uint gasreq, // max gas required by the offer when called. If maxUint256 is used here, default `OFR_GASREQ` will be considered instead\n    uint gasprice, // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\n    uint pivotId // identifier of an offer in the (`outbound_tkn,inbound_tkn`) Offer List after which the new offer should be inserted (gas cost of insertion will increase if the `pivotId` is far from the actual position of the new offer)\n  ) external payable returns (uint offerId);\n\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external payable; //returns 0 if updateOffer failed (for instance if offer is underprovisioned) otherwise returns `offerId`\n\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\n  ) external returns (uint received);\n}\n"
    },
    "contracts/Strategies/interfaces/IMangrove.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.2. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\nimport {MgvLib as ML, P, IMaker} from \"../../MgvLib.sol\";\n\ninterface IMangrove {\n  event Approval(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address owner,\n    address spender,\n    uint value\n  );\n  event Credit(address indexed maker, uint amount);\n  event Debit(address indexed maker, uint amount);\n  event Kill();\n  event NewMgv();\n  event OfferFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    address taker,\n    uint takerWants,\n    uint takerGives,\n    bytes32 mgvData\n  );\n  event OfferRetract(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id\n  );\n  event OfferSuccess(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    address taker,\n    uint takerWants,\n    uint takerGives\n  );\n  event OfferWrite(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address maker,\n    uint wants,\n    uint gives,\n    uint gasprice,\n    uint gasreq,\n    uint id,\n    uint prev\n  );\n  event OrderComplete(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address indexed taker,\n    uint takerGot,\n    uint takerGave,\n    uint penalty\n  );\n  event OrderStart();\n  event PosthookFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId\n  );\n  event SetActive(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    bool value\n  );\n  event SetDensity(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetFee(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasbase(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offer_gasbase\n  );\n  event SetGasmax(uint value);\n  event SetGasprice(uint value);\n  event SetGovernance(address value);\n  event SetMonitor(address value);\n  event SetNotify(bool value);\n  event SetUseOracle(bool value);\n  event SetVault(address value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function activate(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee,\n    uint density,\n    uint offer_gasbase\n  ) external;\n\n  function allowances(\n    address,\n    address,\n    address,\n    address\n  ) external view returns (uint);\n\n  function approve(\n    address outbound_tkn,\n    address inbound_tkn,\n    address spender,\n    uint value\n  ) external returns (bool);\n\n  function balanceOf(address) external view returns (uint);\n\n  function best(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint);\n\n  function config(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (P.Global.t, P.Local.t);\n\n  function configInfo(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (P.GlobalStruct memory global, P.LocalStruct memory local);\n\n  function deactivate(address outbound_tkn, address inbound_tkn) external;\n\n  function flashloan(ML.SingleOrder memory sor, address taker)\n    external\n    returns (uint gasused);\n\n  function fund(address maker) external payable;\n\n  function fund() external payable;\n\n  function governance() external view returns (address);\n\n  function isLive(uint offer) external pure returns (bool);\n\n  function kill() external;\n\n  function locked(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (bool);\n\n  function marketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants\n  )\n    external\n    returns (\n      uint,\n      uint,\n      uint\n    );\n\n  function marketOrderFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint takerGot,\n      uint takerGave,\n      uint bounty\n    );\n\n  function newOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) external payable returns (uint);\n\n  function nonces(address) external view returns (uint);\n\n  function offerDetails(\n    address,\n    address,\n    uint\n  ) external view returns (P.OfferDetail.t);\n\n  function offerInfo(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  )\n    external\n    view\n    returns (\n      P.OfferStruct memory offer,\n      P.OfferDetailStruct memory offerDetail\n    );\n\n  function offers(\n    address,\n    address,\n    uint\n  ) external view returns (P.Offer.t);\n\n  function permit(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision\n  ) external returns (uint provision);\n\n  function setDensity(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint density\n  ) external;\n\n  function setFee(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee\n  ) external;\n\n  function setGasbase(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offer_gasbase\n  ) external;\n\n  function setGasmax(uint gasmax) external;\n\n  function setGasprice(uint gasprice) external;\n\n  function setGovernance(address governanceAddress) external;\n\n  function setMonitor(address monitor) external;\n\n  function setNotify(bool notify) external;\n\n  function setUseOracle(bool useOracle) external;\n\n  function setVault(address vaultAddress) external;\n\n  function snipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] memory targets,\n    bool fillWants\n  )\n    external\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    );\n\n  function snipesFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] memory targets,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint bounty\n    );\n\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external payable;\n\n  function vault() external view returns (address);\n\n  function withdraw(uint amount) external returns (bool noRevert);\n\n  receive() external payable;\n}\n\n// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:\n/*\n[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasmax\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Credit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Debit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Kill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewMgv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mgvData\",\"type\":\"bytes32\"}],\"name\":\"OfferFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OfferRetract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"}],\"name\":\"OfferSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"}],\"name\":\"OfferWrite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGave\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"OrderComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OrderStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"PosthookFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetDensity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"}],\"name\":\"SetGasbase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetGasmax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetGasprice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"SetGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"SetMonitor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetNotify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetUseOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"SetVault\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"best\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"config\",\"outputs\":[{\"internalType\":\"Global.t\",\"name\":\"_global\",\"type\":\"uint256\"},{\"internalType\":\"Local.t\",\"name\":\"_local\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"configInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"monitor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useOracle\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"notify\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasmax\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"dead\",\"type\":\"bool\"}],\"internalType\":\"struct GlobalStruct\",\"name\":\"global\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"best\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last\",\"type\":\"uint256\"}],\"internalType\":\"struct LocalStruct\",\"name\":\"local\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"Offer.t\",\"name\":\"offer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"OfferDetail.t\",\"name\":\"offerDetail\",\"type\":\"uint256\"},{\"internalType\":\"Global.t\",\"name\":\"global\",\"type\":\"uint256\"},{\"internalType\":\"Local.t\",\"name\":\"local\",\"type\":\"uint256\"}],\"internalType\":\"struct MgvLib.SingleOrder\",\"name\":\"sor\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"flashloan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasused\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"}],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Offer.t\",\"name\":\"offer\",\"type\":\"uint256\"}],\"name\":\"isLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"}],\"name\":\"marketOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"marketOrderFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"takerGot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGave\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pivotId\",\"type\":\"uint256\"}],\"name\":\"newOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offerDetails\",\"outputs\":[{\"internalType\":\"OfferDetail.t\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"offerInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"next\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferStruct\",\"name\":\"offer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferDetailStruct\",\"name\":\"offerDetail\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"internalType\":\"Offer.t\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deprovision\",\"type\":\"bool\"}],\"name\":\"retractOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"provision\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"}],\"name\":\"setDensity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"}],\"name\":\"setGasbase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasmax\",\"type\":\"uint256\"}],\"name\":\"setGasmax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"}],\"name\":\"setGasprice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceAddress\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"monitor\",\"type\":\"address\"}],\"name\":\"setMonitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"notify\",\"type\":\"bool\"}],\"name\":\"setNotify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"useOracle\",\"type\":\"bool\"}],\"name\":\"setUseOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256[4][]\",\"name\":\"targets\",\"type\":\"uint256[4][]\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"}],\"name\":\"snipes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256[4][]\",\"name\":\"targets\",\"type\":\"uint256[4][]\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"snipesFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"successes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGave\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pivotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"updateOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"noRevert\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]\n*/\n"
    },
    "contracts/Strategies/interfaces/IEIP20.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// IERC20.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\ninterface IEIP20 {\n  function totalSupply() external view returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint);\n\n  function approve(address spender, uint amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n  /// for wETH contract\n  function deposit() external payable;\n\n  function withdraw(uint) external;\n\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/Persistent.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Persistent.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./MultiUser.sol\";\n\n//import \"hardhat/console.sol\";\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nabstract contract MultiUserPersistent is MultiUser {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n\n  function __residualWants__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.wants() - order.gives;\n  }\n\n  function __residualGives__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.gives() - order.wants;\n  }\n\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n  {\n    uint new_gives = __residualGives__(order);\n    uint new_wants = __residualWants__(order);\n    if (new_gives == 0) {\n      // gas saving\n      return;\n    }\n    try\n      MGV.updateOffer(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        new_wants,\n        new_gives,\n        order.offerDetail.gasreq(),\n        order.offerDetail.gasprice(),\n        order.offer.next(),\n        order.offerId\n      )\n    {} catch Error(string memory message) {\n      // density could be too low, or offer provision be insufficient\n      emit PosthookFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        message\n      );\n    }\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../AaveV3Lender.sol\";\nimport \"../Persistent.sol\";\n\ncontract OfferProxy is MultiUserAaveV3Lender, MultiUserPersistent {\n  constructor(address _addressesProvider, address payable _MGV)\n    AaveV3Module(_addressesProvider, 0)\n    MangroveOffer(_MGV)\n  {\n    setGasreq(800_000); // Offer proxy requires AAVE interactions\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    override(MultiUser, MultiUserAaveV3Lender)\n    returns (uint missing)\n  {\n    // puts amount inbound_tkn on AAVE\n    missing = MultiUserAaveV3Lender.__put__(amount, order);\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    override(MultiUser, MultiUserAaveV3Lender)\n    returns (uint)\n  {\n    // gets tokens from AAVE's owner deposit -- will transfer aTokens from owner first\n    return MultiUserAaveV3Lender.__get__(amount, order);\n  }\n\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    override(MangroveOffer, MultiUserPersistent)\n  {\n    // reposting residual if possible\n    MultiUserPersistent.__posthookSuccess__(order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/AaveV3Lender.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./MultiUser.sol\";\nimport \"../AaveV3Module.sol\";\n\nabstract contract MultiUserAaveV3Lender is MultiUser, AaveV3Module {\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  // tokens are fetched on Aave (on behalf of offer owner)\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    (\n      uint redeemable, /*maxBorrowAfterRedeem*/\n\n    ) = maxGettableUnderlying(order.outbound_tkn, false, owner);\n    if (amount > redeemable) {\n      return amount; // give up if amount is not redeemable (anti flashloan manipulation of AAVE)\n    }\n    // need to retreive overlyings from msg.sender (we suppose `this` is approved for that)\n    IEIP20 aToken = overlying(IEIP20(order.outbound_tkn));\n    try aToken.transferFrom(owner, address(this), amount) returns (\n      bool success\n    ) {\n      if (success) {\n        // amount overlying was transfered from `owner`'s wallet\n        // anything wrong beyond this point should revert\n        // trying to redeem from AAVE\n        require(aaveRedeem(amount, address(this), order) == 0); // throwing to cancel overlying transfer\n        return 0;\n      }\n    } catch {\n      // nothing to be done\n    }\n    emit LogIncident(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId,\n      \"aaveV3Lender/overlyingTransferFail\"\n    );\n    return amount; // nothing was fetched\n  }\n\n  // received inbound token are put on Aave on behalf of offer owner\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    // minted Atokens are sent to owner\n    return aaveMint(amount, owner, order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/AaveV3Module.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../interfaces/aave/V3/IPool.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/aave/V3/IPoolAddressesProvider.sol\";\nimport \"../interfaces/aave/V3/IPriceOracleGetter.sol\";\nimport {ReserveConfiguration as RC} from \"../lib/aave/V3/ReserveConfiguration.sol\";\nimport \"../interfaces/IMangrove.sol\";\nimport \"../interfaces/IEIP20.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract AaveV3Module {\n  event ErrorOnRedeem(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n  event ErrorOnMint(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n\n  // address of the lendingPool\n  IPool public immutable lendingPool;\n  IPriceOracleGetter public immutable priceOracle;\n  uint16 referralCode;\n\n  constructor(address _addressesProvider, uint _referralCode) {\n    require(\n      uint16(_referralCode) == _referralCode,\n      \"Referral code should be uint16\"\n    );\n\n    referralCode = uint16(referralCode); // for aave reference, put 0 for tests\n\n    address _priceOracle = IPoolAddressesProvider(_addressesProvider)\n      .getAddress(\"PRICE_ORACLE\");\n\n    address _lendingPool = IPoolAddressesProvider(_addressesProvider).getPool();\n\n    require(_lendingPool != address(0), \"Invalid lendingPool address\");\n    require(_priceOracle != address(0), \"Invalid priceOracle address\");\n    lendingPool = IPool(_lendingPool);\n    priceOracle = IPriceOracleGetter(_priceOracle);\n  }\n\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  ///@notice approval of overlying contract by the underlying is necessary for minting and repaying borrow\n  ///@notice user must use this function to do so.\n  function approveLender(address token, uint amount) public {\n    IEIP20(token).approve(address(lendingPool), amount);\n  }\n\n  ///@notice exits markets\n  function _exitMarket(IEIP20 underlying) internal {\n    lendingPool.setUserUseReserveAsCollateral(address(underlying), false);\n  }\n\n  function _enterMarkets(IEIP20[] calldata underlyings) internal {\n    for (uint i = 0; i < underlyings.length; i++) {\n      lendingPool.setUserUseReserveAsCollateral(address(underlyings[i]), true);\n    }\n  }\n\n  function overlying(IEIP20 asset) public view returns (IEIP20 aToken) {\n    aToken = IEIP20(lendingPool.getReserveData(address(asset)).aTokenAddress);\n  }\n\n  // structs to avoir stack too deep in maxGettableUnderlying\n  struct Underlying {\n    uint ltv;\n    uint liquidationThreshold;\n    uint decimals;\n    uint price;\n  }\n\n  struct Account {\n    uint collateral;\n    uint debt;\n    uint borrowPower;\n    uint redeemPower;\n    uint ltv;\n    uint liquidationThreshold;\n    uint health;\n    uint balanceOfUnderlying;\n  }\n\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\n  /// returns (R, B|R)\n\n  function maxGettableUnderlying(\n    address asset,\n    bool tryBorrow,\n    address onBehalf\n  ) public view returns (uint, uint) {\n    Underlying memory underlying; // asset parameters\n    Account memory account; // accound parameters\n    (\n      account.collateral,\n      account.debt,\n      account.borrowPower, // avgLtv * sumCollateralEth - sumDebtEth\n      account.liquidationThreshold,\n      account.ltv,\n      account.health // avgLiquidityThreshold * sumCollateralEth / sumDebtEth  -- should be less than 10**18\n    ) = lendingPool.getUserAccountData(onBehalf);\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      asset\n    );\n    (\n      underlying.ltv, // collateral factor for lending\n      underlying.liquidationThreshold, // collateral factor for borrowing\n      ,\n      /*liquidationBonus*/\n      underlying.decimals,\n      /*reserveFactor*/\n      /*emode_category*/\n      ,\n\n    ) = RC.getParams(reserveData.configuration);\n    account.balanceOfUnderlying = IEIP20(reserveData.aTokenAddress).balanceOf(\n      onBehalf\n    );\n\n    underlying.price = priceOracle.getAssetPrice(asset); // divided by 10**underlying.decimals\n\n    // account.redeemPower = account.liquidationThreshold * account.collateral - account.debt\n    account.redeemPower =\n      (account.liquidationThreshold * account.collateral) /\n      10**4 -\n      account.debt;\n    // max redeem capacity = account.redeemPower/ underlying.liquidationThreshold * underlying.price\n    // unless account doesn't have enough collateral in asset token (hence the min())\n\n    uint maxRedeemableUnderlying = (account.redeemPower * // in 10**underlying.decimals\n        10**(underlying.decimals) *\n        10**4) / (underlying.liquidationThreshold * underlying.price);\n\n    maxRedeemableUnderlying = (maxRedeemableUnderlying <\n      account.balanceOfUnderlying)\n      ? maxRedeemableUnderlying\n      : account.balanceOfUnderlying;\n\n    if (!tryBorrow) {\n      //gas saver\n      return (maxRedeemableUnderlying, 0);\n    }\n    // computing max borrow capacity on the premisses that maxRedeemableUnderlying has been redeemed.\n    // max borrow capacity = (account.borrowPower - (ltv*redeemed)) / underlying.ltv * underlying.price\n\n    uint borrowPowerImpactOfRedeemInUnderlying = (maxRedeemableUnderlying *\n      underlying.ltv) / 10**4;\n\n    uint borrowPowerInUnderlying = (account.borrowPower *\n      10**underlying.decimals) / underlying.price;\n\n    if (borrowPowerImpactOfRedeemInUnderlying > borrowPowerInUnderlying) {\n      // no more borrowPower left after max redeem operation\n      return (maxRedeemableUnderlying, 0);\n    }\n\n    // max borrow power in underlying after max redeem has been withdrawn\n    uint maxBorrowAfterRedeemInUnderlying = borrowPowerInUnderlying -\n      borrowPowerImpactOfRedeemInUnderlying;\n\n    return (maxRedeemableUnderlying, maxBorrowAfterRedeemInUnderlying);\n  }\n\n  function aaveRedeem(\n    uint amountToRedeem,\n    address onBehalf,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    try\n      lendingPool.withdraw(order.outbound_tkn, amountToRedeem, onBehalf)\n    returns (uint withdrawn) {\n      //aave redeem was a success\n      if (amountToRedeem == withdrawn) {\n        return 0;\n      } else {\n        return (amountToRedeem - withdrawn);\n      }\n    } catch Error(string memory message) {\n      emit ErrorOnRedeem(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amountToRedeem,\n        message\n      );\n      return amountToRedeem;\n    }\n  }\n\n  function _mint(\n    uint amount,\n    address token,\n    address onBehalf\n  ) internal {\n    lendingPool.deposit(token, amount, onBehalf, referralCode);\n  }\n\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\n  // utility to supply erc20 to compound\n  // NB `ctoken` contract MUST be approved to perform `transferFrom token` by `this` contract.\n  /// @notice user need to approve ctoken in order to mint\n  function aaveMint(\n    uint amount,\n    address onBehalf,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    // contract must haveallowance()to spend funds on behalf ofmsg.sender for at-leastamount for the asset being deposited. This can be done via the standard ERC20 approve() method.\n    try lendingPool.deposit(order.inbound_tkn, amount, onBehalf, referralCode) {\n      return 0;\n    } catch Error(string memory message) {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        message\n      );\n    } catch {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        \"unexpected\"\n      );\n    }\n    return amount;\n  }\n}\n"
    },
    "contracts/Strategies/interfaces/aave/V3/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../../../lib/aave/V3/DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n **/\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   **/\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   **/\n  event BackUnbacked(\n    address indexed reserve,\n    address indexed backer,\n    uint amount,\n    uint fee\n  );\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   **/\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(\n    address indexed reserve,\n    address indexed user,\n    address indexed to,\n    uint amount\n  );\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   **/\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint debtToCover,\n    uint liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint liquidityRate,\n    uint stableBorrowRate,\n    uint variableBorrowRate,\n    uint liquidityIndex,\n    uint variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   **/\n  event MintedToTreasury(address indexed reserve, uint amountMinted);\n\n  /**\n   * @dev Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function mintUnbacked(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   **/\n  function backUnbacked(\n    address asset,\n    uint amount,\n    uint fee\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function supply(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   **/\n  function supplyWithPermit(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint amount,\n    address to\n  ) external returns (uint);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    address onBehalfOf\n  ) external returns (uint);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   **/\n  function repayWithPermit(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    address onBehalfOf,\n    uint deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   **/\n  function repayWithATokens(\n    address asset,\n    uint amount,\n    uint interestRateMode\n  ) external returns (uint);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  function swapBorrowRateMode(address asset, uint interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n    external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint[] calldata amounts,\n    uint[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint totalCollateralBase,\n      uint totalDebtBase,\n      uint availableBorrowsBase,\n      uint currentLiquidationThreshold,\n      uint ltv,\n      uint healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    view\n    returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint amount,\n    uint balanceFromBefore,\n    uint balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   **/\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   **/\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   **/\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(\n    uint8 id,\n    DataTypes.EModeCategory memory config\n  ) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id)\n    external\n    view\n    returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   **/\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "contracts/Strategies/interfaces/aave/V3/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n **/\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(\n    bytes32 indexed id,\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   **/\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress)\n    external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   **/\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   **/\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   **/\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   **/\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   **/\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   **/\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   **/\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/Strategies/interfaces/aave/V3/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n **/\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   **/\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   **/\n  function BASE_CURRENCY_UNIT() external view returns (uint);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint);\n}\n"
    },
    "contracts/Strategies/lib/aave/V3/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {Errors} from \"./Errors.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint internal constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint internal constant IS_PAUSED_START_BIT_POSITION = 60;\n  uint internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n  uint internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n  /// @dev bit 63 reserved\n\n  uint internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n  uint internal constant BORROW_CAP_START_BIT_POSITION = 80;\n  uint internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n  uint internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n  uint internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n  uint internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n  uint internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n\n  uint internal constant MAX_VALID_LTV = 65535;\n  uint internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n  uint internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n  uint internal constant MAX_VALID_DECIMALS = 255;\n  uint internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n  uint internal constant MAX_VALID_BORROW_CAP = 68719476735;\n  uint internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n  uint internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n  uint internal constant MAX_VALID_EMODE_CATEGORY = 255;\n  uint internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n  uint internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n  uint public constant DEBT_CEILING_DECIMALS = 2;\n  uint16 public constant MAX_RESERVES_COUNT = 128;\n\n  /**\n   * @notice Sets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @param ltv The new ltv\n   **/\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint ltv)\n    internal\n    pure\n  {\n    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @notice Gets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @return The loan to value\n   **/\n  function getLtv(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @notice Sets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @param threshold The new liquidation threshold\n   **/\n  function setLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint threshold\n  ) internal pure {\n    require(\n      threshold <= MAX_VALID_LIQUIDATION_THRESHOLD,\n      Errors.INVALID_LIQ_THRESHOLD\n    );\n\n    self.data =\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation threshold\n   **/\n  function getLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint) {\n    return\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >>\n      LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @param bonus The new liquidation bonus\n   **/\n  function setLiquidationBonus(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint bonus\n  ) internal pure {\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n    self.data =\n      (self.data & LIQUIDATION_BONUS_MASK) |\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation bonus\n   **/\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~LIQUIDATION_BONUS_MASK) >>\n      LIQUIDATION_BONUS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @param decimals The decimals\n   **/\n  function setDecimals(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint decimals\n  ) internal pure {\n    require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n    self.data =\n      (self.data & DECIMALS_MASK) |\n      (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @return The decimals of the asset\n   **/\n  function getDecimals(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the active state of the reserve\n   * @param self The reserve configuration\n   * @param active The active state\n   **/\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & ACTIVE_MASK) |\n      (uint(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the active state of the reserve\n   * @param self The reserve configuration\n   * @return The active state\n   **/\n  function getActive(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~ACTIVE_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @param frozen The frozen state\n   **/\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & FROZEN_MASK) |\n      (uint(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @return The frozen state\n   **/\n  function getFrozen(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~FROZEN_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the paused state of the reserve\n   * @param self The reserve configuration\n   * @param paused The paused state\n   **/\n  function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & PAUSED_MASK) |\n      (uint(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the paused state of the reserve\n   * @param self The reserve configuration\n   * @return The paused state\n   **/\n  function getPaused(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~PAUSED_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n   * amount will be accumulated in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @param borrowable True if the asset is borrowable\n   **/\n  function setBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool borrowable\n  ) internal pure {\n    self.data =\n      (self.data & BORROWABLE_IN_ISOLATION_MASK) |\n      (uint(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowable in isolation flag for the reserve.\n   * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n   * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @return The borrowable in isolation flag\n   **/\n  function getBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @param siloed True if the asset is siloed\n   **/\n  function setSiloedBorrowing(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool siloed\n  ) internal pure {\n    self.data =\n      (self.data & SILOED_BORROWING_MASK) |\n      (uint(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @return The siloed borrowing flag\n   **/\n  function getSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~SILOED_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\n   **/\n  function setBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & BORROWING_MASK) |\n      (uint(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The borrowing state\n   **/\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables stable rate borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n   **/\n  function setStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & STABLE_BORROWING_MASK) |\n      (uint(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the stable rate borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The stable rate borrowing state\n   **/\n  function getStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @param reserveFactor The reserve factor\n   **/\n  function setReserveFactor(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint reserveFactor\n  ) internal pure {\n    require(\n      reserveFactor <= MAX_VALID_RESERVE_FACTOR,\n      Errors.INVALID_RESERVE_FACTOR\n    );\n\n    self.data =\n      (self.data & RESERVE_FACTOR_MASK) |\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @return The reserve factor\n   **/\n  function getReserveFactor(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @param borrowCap The borrow cap\n   **/\n  function setBorrowCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint borrowCap\n  ) internal pure {\n    require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n    self.data =\n      (self.data & BORROW_CAP_MASK) |\n      (borrowCap << BORROW_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @return The borrow cap\n   **/\n  function getBorrowCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @param supplyCap The supply cap\n   **/\n  function setSupplyCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint supplyCap\n  ) internal pure {\n    require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n    self.data =\n      (self.data & SUPPLY_CAP_MASK) |\n      (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @return The supply cap\n   **/\n  function getSupplyCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the debt ceiling in isolation mode for the asset\n   * @param self The reserve configuration\n   * @param ceiling The maximum debt ceiling for the asset\n   **/\n  function setDebtCeiling(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint ceiling\n  ) internal pure {\n    require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n    self.data =\n      (self.data & DEBT_CEILING_MASK) |\n      (ceiling << DEBT_CEILING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n   * @param self The reserve configuration\n   * @return The debt ceiling (0 = isolation mode disabled)\n   **/\n  function getDebtCeiling(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation protocol fee of the reserve\n   * @param self The reserve configuration\n   * @param liquidationProtocolFee The liquidation protocol fee\n   **/\n  function setLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint liquidationProtocolFee\n  ) internal pure {\n    require(\n      liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,\n      Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n    );\n\n    self.data =\n      (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |\n      (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the liquidation protocol fee\n   * @param self The reserve configuration\n   * @return The liquidation protocol fee\n   **/\n  function getLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint) {\n    return\n      (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >>\n      LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @param unbackedMintCap The unbacked mint cap\n   **/\n  function setUnbackedMintCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint unbackedMintCap\n  ) internal pure {\n    require(\n      unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP,\n      Errors.INVALID_UNBACKED_MINT_CAP\n    );\n\n    self.data =\n      (self.data & UNBACKED_MINT_CAP_MASK) |\n      (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @return The unbacked mint cap\n   **/\n  function getUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~UNBACKED_MINT_CAP_MASK) >>\n      UNBACKED_MINT_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the eMode asset category\n   * @param self The reserve configuration\n   * @param category The asset category when the user selects the eMode\n   **/\n  function setEModeCategory(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint category\n  ) internal pure {\n    require(\n      category <= MAX_VALID_EMODE_CATEGORY,\n      Errors.INVALID_EMODE_CATEGORY\n    );\n\n    self.data =\n      (self.data & EMODE_CATEGORY_MASK) |\n      (category << EMODE_CATEGORY_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the eMode asset category\n   * @param self The reserve configuration\n   * @return The eMode category for the asset\n   **/\n  function getEModeCategory(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Gets the configuration flags of the reserve\n   * @param self The reserve configuration\n   * @return The state flag representing active\n   * @return The state flag representing frozen\n   * @return The state flag representing borrowing enabled\n   * @return The state flag representing stableRateBorrowing enabled\n   * @return The state flag representing paused\n   **/\n  function getFlags(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      bool,\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    uint dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) != 0,\n      (dataLocal & ~FROZEN_MASK) != 0,\n      (dataLocal & ~BORROWING_MASK) != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n      (dataLocal & ~PAUSED_MASK) != 0\n    );\n  }\n\n  /**\n   * @notice Gets the configuration parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing ltv\n   * @return The state param representing liquidation threshold\n   * @return The state param representing liquidation bonus\n   * @return The state param representing reserve decimals\n   * @return The state param representing reserve factor\n   * @return The state param representing eMode category\n   **/\n  function getParams(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      uint,\n      uint,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    uint dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\n        LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\n        LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,\n      (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n    );\n  }\n\n  /**\n   * @notice Gets the caps parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing borrow cap\n   * @return The state param representing supply cap.\n   **/\n  function getCaps(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint, uint)\n  {\n    uint dataLocal = self.data;\n\n    return (\n      (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n      (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n    );\n  }\n}\n"
    },
    "contracts/Strategies/lib/aave/V3/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint currScaledVariableDebt;\n    uint nextScaledVariableDebt;\n    uint currPrincipalStableDebt;\n    uint currAvgStableBorrowRate;\n    uint currTotalStableDebt;\n    uint nextAvgStableBorrowRate;\n    uint nextTotalStableDebt;\n    uint currLiquidityIndex;\n    uint nextLiquidityIndex;\n    uint currVariableBorrowIndex;\n    uint nextVariableBorrowIndex;\n    uint currLiquidityRate;\n    uint currVariableBorrowRate;\n    uint reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint reservesCount;\n    uint debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint maxStableRateBorrowSizePercent;\n    uint reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint amount;\n    address to;\n    uint reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint amount;\n    uint balanceFromBefore;\n    uint balanceToBefore;\n    uint reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint[] amounts;\n    uint[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint flashLoanPremiumToProtocol;\n    uint flashLoanPremiumTotal;\n    uint maxStableRateBorrowSizePercent;\n    uint reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint amount;\n    bytes params;\n    uint16 referralCode;\n    uint flashLoanPremiumToProtocol;\n    uint flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint amount;\n    uint totalPremium;\n    uint flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint amount;\n    InterestRateMode interestRateMode;\n    uint maxStableLoanPercent;\n    uint reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint totalDebt;\n    uint healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint unbacked;\n    uint liquidityAdded;\n    uint liquidityTaken;\n    uint totalStableDebt;\n    uint totalVariableDebt;\n    uint averageStableBorrowRate;\n    uint reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "contracts/Strategies/lib/aave/V3/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_ADMIN = \"1\"; // 'The caller of the function is not a pool admin'\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = \"2\"; // 'The caller of the function is not an emergency admin'\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = \"3\"; // 'The caller of the function is not a pool or emergency admin'\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = \"4\"; // 'The caller of the function is not a risk or pool admin'\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = \"5\"; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant CALLER_NOT_BRIDGE = \"6\"; // 'The caller of the function is not a bridge'\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = \"7\"; // 'Pool addresses provider is not registered'\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = \"8\"; // 'Invalid id for the pool addresses provider'\n  string public constant NOT_CONTRACT = \"9\"; // 'Address is not a contract'\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = \"10\"; // 'The caller of the function is not the pool configurator'\n  string public constant CALLER_NOT_ATOKEN = \"11\"; // 'The caller of the function is not an AToken'\n  string public constant INVALID_ADDRESSES_PROVIDER = \"12\"; // 'The address of the pool addresses provider is invalid'\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = \"13\"; // 'Invalid return value of the flashloan executor function'\n  string public constant RESERVE_ALREADY_ADDED = \"14\"; // 'Reserve has already been added to reserve list'\n  string public constant NO_MORE_RESERVES_ALLOWED = \"15\"; // 'Maximum amount of reserves in the pool reached'\n  string public constant EMODE_CATEGORY_RESERVED = \"16\"; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = \"17\"; // 'Invalid eMode category assignment to asset'\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = \"18\"; // 'The liquidity of the reserve needs to be 0'\n  string public constant FLASHLOAN_PREMIUM_INVALID = \"19\"; // 'Invalid flashloan premium'\n  string public constant INVALID_RESERVE_PARAMS = \"20\"; // 'Invalid risk parameters for the reserve'\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = \"21\"; // 'Invalid risk parameters for the eMode category'\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = \"22\"; // 'Invalid bridge protocol fee'\n  string public constant CALLER_MUST_BE_POOL = \"23\"; // 'The caller of this function must be a pool'\n  string public constant INVALID_MINT_AMOUNT = \"24\"; // 'Invalid amount to mint'\n  string public constant INVALID_BURN_AMOUNT = \"25\"; // 'Invalid amount to burn'\n  string public constant INVALID_AMOUNT = \"26\"; // 'Amount must be greater than 0'\n  string public constant RESERVE_INACTIVE = \"27\"; // 'Action requires an active reserve'\n  string public constant RESERVE_FROZEN = \"28\"; // 'Action cannot be performed because the reserve is frozen'\n  string public constant RESERVE_PAUSED = \"29\"; // 'Action cannot be performed because the reserve is paused'\n  string public constant BORROWING_NOT_ENABLED = \"30\"; // 'Borrowing is not enabled'\n  string public constant STABLE_BORROWING_NOT_ENABLED = \"31\"; // 'Stable borrowing is not enabled'\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = \"32\"; // 'User cannot withdraw more than the available balance'\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = \"33\"; // 'Invalid interest rate mode selected'\n  string public constant COLLATERAL_BALANCE_IS_ZERO = \"34\"; // 'The collateral balance is 0'\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \"35\"; // 'Health factor is lesser than the liquidation threshold'\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = \"36\"; // 'There is not enough collateral to cover a new borrow'\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = \"37\"; // 'Collateral is (mostly) the same currency that is being borrowed'\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \"38\"; // 'The requested amount is greater than the max loan size in stable rate mode'\n  string public constant NO_DEBT_OF_SELECTED_TYPE = \"39\"; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \"40\"; // 'To repay on behalf of a user an explicit amount to repay is needed'\n  string public constant NO_OUTSTANDING_STABLE_DEBT = \"41\"; // 'User does not have outstanding stable rate debt on this reserve'\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = \"42\"; // 'User does not have outstanding variable rate debt on this reserve'\n  string public constant UNDERLYING_BALANCE_ZERO = \"43\"; // 'The underlying balance needs to be greater than 0'\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \"44\"; // 'Interest rate rebalance conditions were not met'\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \"45\"; // 'Health factor is not below the threshold'\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = \"46\"; // 'The collateral chosen cannot be liquidated'\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \"47\"; // 'User did not borrow the specified currency'\n  string public constant SAME_BLOCK_BORROW_REPAY = \"48\"; // 'Borrow and repay in same block is not allowed'\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = \"49\"; // 'Inconsistent flashloan parameters'\n  string public constant BORROW_CAP_EXCEEDED = \"50\"; // 'Borrow cap is exceeded'\n  string public constant SUPPLY_CAP_EXCEEDED = \"51\"; // 'Supply cap is exceeded'\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = \"52\"; // 'Unbacked mint cap is exceeded'\n  string public constant DEBT_CEILING_EXCEEDED = \"53\"; // 'Debt ceiling is exceeded'\n  string public constant ATOKEN_SUPPLY_NOT_ZERO = \"54\"; // 'AToken supply is not zero'\n  string public constant STABLE_DEBT_NOT_ZERO = \"55\"; // 'Stable debt supply is not zero'\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = \"56\"; // 'Variable debt supply is not zero'\n  string public constant LTV_VALIDATION_FAILED = \"57\"; // 'Ltv validation failed'\n  string public constant INCONSISTENT_EMODE_CATEGORY = \"58\"; // 'Inconsistent eMode category'\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = \"59\"; // 'Price oracle sentinel validation failed'\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = \"60\"; // 'Asset is not borrowable in isolation mode'\n  string public constant RESERVE_ALREADY_INITIALIZED = \"61\"; // 'Reserve has already been initialized'\n  string public constant USER_IN_ISOLATION_MODE = \"62\"; // 'User is in isolation mode'\n  string public constant INVALID_LTV = \"63\"; // 'Invalid ltv parameter for the reserve'\n  string public constant INVALID_LIQ_THRESHOLD = \"64\"; // 'Invalid liquidity threshold parameter for the reserve'\n  string public constant INVALID_LIQ_BONUS = \"65\"; // 'Invalid liquidity bonus parameter for the reserve'\n  string public constant INVALID_DECIMALS = \"66\"; // 'Invalid decimals parameter of the underlying asset of the reserve'\n  string public constant INVALID_RESERVE_FACTOR = \"67\"; // 'Invalid reserve factor parameter for the reserve'\n  string public constant INVALID_BORROW_CAP = \"68\"; // 'Invalid borrow cap for the reserve'\n  string public constant INVALID_SUPPLY_CAP = \"69\"; // 'Invalid supply cap for the reserve'\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = \"70\"; // 'Invalid liquidation protocol fee for the reserve'\n  string public constant INVALID_EMODE_CATEGORY = \"71\"; // 'Invalid eMode category for the reserve'\n  string public constant INVALID_UNBACKED_MINT_CAP = \"72\"; // 'Invalid unbacked mint cap for the reserve'\n  string public constant INVALID_DEBT_CEILING = \"73\"; // 'Invalid debt ceiling for the reserve\n  string public constant INVALID_RESERVE_INDEX = \"74\"; // 'Invalid reserve index'\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = \"75\"; // 'ACL admin cannot be set to the zero address'\n  string public constant INCONSISTENT_PARAMS_LENGTH = \"76\"; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = \"77\"; // 'Zero address not valid'\n  string public constant INVALID_EXPIRATION = \"78\"; // 'Invalid expiration'\n  string public constant INVALID_SIGNATURE = \"79\"; // 'Invalid signature'\n  string public constant OPERATION_NOT_SUPPORTED = \"80\"; // 'Operation not supported'\n  string public constant DEBT_CEILING_NOT_ZERO = \"81\"; // 'Debt ceiling is not zero'\n  string public constant ASSET_NOT_LISTED = \"82\"; // 'Asset is not listed'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = \"83\"; // 'Invalid optimal usage ratio'\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = \"84\"; // 'Invalid optimal stable to total debt ratio'\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = \"85\"; // 'The underlying asset cannot be rescued'\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = \"86\"; // 'Reserve has already been added to reserve list'\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = \"87\"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n  string public constant STABLE_BORROWING_ENABLED = \"88\"; // 'Stable borrowing is enabled'\n  string public constant SILOED_BORROWING_VIOLATION = \"89\"; // 'User is trying to borrow multiple assets including a siloed one'\n  string public constant RESERVE_DEBT_NOT_ZERO = \"90\"; // the total debt of the reserve needs to be 0\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/AaveV3Trader.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AaveV3Trader.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./AaveV3Lender.sol\";\n\nabstract contract MultiUserAaveV3Trader is MultiUser, AaveV3Module {\n  uint public immutable interestRateMode;\n\n  constructor(uint _interestRateMode) {\n    interestRateMode = _interestRateMode;\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    // 1. Computing total borrow and redeem capacities of underlying asset\n    (uint redeemable, uint liquidity_after_redeem) = maxGettableUnderlying(\n      order.outbound_tkn,\n      true,\n      owner\n    );\n    // Fail early to prevent AAVE manipulation by flashloans\n    if (redeemable + liquidity_after_redeem < amount) {\n      return amount;\n    }\n    // 2. trying to redeem liquidity from AAVE\n    uint toRedeem = redeemable < amount ? redeemable : amount;\n    if (toRedeem == 0) {\n      return amount;\n    }\n    IEIP20 aToken = overlying(IEIP20(order.outbound_tkn));\n    try aToken.transferFrom(owner, address(this), amount) returns (\n      bool success\n    ) {\n      if (!success) {\n        // notRedeemed > 0 should not happen unless lender is out of cash, thus no need to try to borrow\n        // log already emitted by `aaveRedeem`\n        emit LogIncident(\n          order.outbound_tkn,\n          order.inbound_tkn,\n          order.offerId,\n          \"Multi/aaveTrader/aTkn/TransferFail\"\n        );\n        return amount;\n      }\n      // overlying transfer has succeeded, anything wrong beyond this point should revert\n      require(aaveRedeem(toRedeem, address(this), order) == 0); // throwing to cancel transfer of overlying\n      amount = amount - toRedeem;\n      if (amount == 0) {\n        return 0;\n      }\n      uint toBorrow = (liquidity_after_redeem < amount)\n        ? liquidity_after_redeem\n        : amount;\n      // 3. trying to borrow missing liquidity, failure to borrow will revert\n      // not encapsulating this external call to make sure aToken transfer is also reverted\n      lendingPool.borrow(\n        order.outbound_tkn,\n        toBorrow,\n        interestRateMode,\n        referralCode,\n        address(this)\n      );\n      // if this point is reached, borrow has succeeded.\n      return 0;\n    } catch {\n      // overlying transfer reverted.\n      emit LogIncident(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        \"Multi/AaveV3Trader/aTkn/transferRevert\"\n      );\n      return amount;\n    }\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    // trying to repay debt if user is in borrow position for inbound_tkn token\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      order.inbound_tkn\n    );\n\n    uint debtOfUnderlying;\n    if (interestRateMode == 1) {\n      debtOfUnderlying = IEIP20(reserveData.stableDebtTokenAddress).balanceOf(\n        address(this)\n      );\n    } else {\n      debtOfUnderlying = IEIP20(reserveData.variableDebtTokenAddress).balanceOf(\n          address(this)\n        );\n    }\n\n    uint toRepay = (debtOfUnderlying < amount) ? debtOfUnderlying : amount;\n\n    uint toMint;\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    try lendingPool.repay(order.inbound_tkn, toRepay, interestRateMode, owner) {\n      toMint = amount - toRepay;\n    } catch (bytes memory message) {\n      emit LogIncident(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        message\n      );\n      toMint = amount;\n    }\n    return aaveMint(toMint, owner, order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/AaveV3Lender.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./SingleUser.sol\";\nimport \"../AaveV3Module.sol\";\n\nabstract contract AaveV3Lender is SingleUser, AaveV3Module {\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  ///@notice exits markets\n  function exitMarket(IEIP20 underlying) external onlyAdmin {\n    _exitMarket(underlying);\n  }\n\n  function enterMarkets(IEIP20[] calldata underlyings) external onlyAdmin {\n    _enterMarkets(underlyings);\n  }\n\n  function mint(\n    uint amount,\n    address token,\n    address onBehalf\n  ) external onlyAdmin {\n    _mint(amount, token, onBehalf);\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    (\n      uint redeemable, /*maxBorrowAfterRedeem*/\n\n    ) = maxGettableUnderlying(order.outbound_tkn, false, address(this));\n    if (amount > redeemable) {\n      return amount; // give up if amount is not redeemable (anti flashloan manipulation of AAVE)\n    }\n\n    if (aaveRedeem(amount, address(this), order) == 0) {\n      // amount was transfered to `this`\n      return 0;\n    }\n    return amount;\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    return aaveMint(amount, address(this), order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/SingleUser.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangroveOffer.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../MangroveOffer.sol\";\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nabstract contract SingleUser is MangroveOffer {\n  /// transfers token stored in `this` contract to some recipient address\n  function redeemToken(\n    address token,\n    address receiver,\n    uint amount\n  ) external override onlyAdmin returns (bool success) {\n    require(receiver != address(0), \"SingleUser/redeemToken/0xReceiver\");\n    success = IEIP20(token).transfer(receiver, amount);\n  }\n\n  /// withdraws ETH from the bounty vault of the Mangrove.\n  /// ETH are sent to `receiver`\n  function withdrawFromMangrove(address payable receiver, uint amount)\n    external\n    override\n    onlyAdmin\n    returns (bool)\n  {\n    require(receiver != address(0), \"SingleUser/withdrawMGV/0xReceiver\");\n    return _withdrawFromMangrove(receiver, amount);\n  }\n\n  // Posting a new offer on the (`outbound_tkn,inbound_tkn`) Offer List of Mangrove.\n  // NB #1: Offer maker maker MUST:\n  // * Approve Mangrove for at least `gives` amount of `outbound_tkn`.\n  // * Make sure that `this` contract has enough WEI provision on Mangrove to cover for the new offer bounty (function is payable so that caller can increase provision prior to posting the new offer)\n  // * Make sure that `gasreq` and `gives` yield a sufficient offer density\n  // NB #2: This function will revert when the above points are not met\n  function newOffer(\n    address outbound_tkn, // address of the ERC20 contract managing outbound tokens\n    address inbound_tkn, // address of the ERC20 contract managing outbound tokens\n    uint wants, // amount of `inbound_tkn` required for full delivery\n    uint gives, // max amount of `outbound_tkn` promised by the offer\n    uint gasreq, // max gas required by the offer when called. If maxUint256 is used here, default `OFR_GASREQ` will be considered instead\n    uint gasprice, // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\n    uint pivotId // identifier of an offer in the (`outbound_tkn,inbound_tkn`) Offer List after which the new offer should be inserted (gas cost of insertion will increase if the `pivotId` is far from the actual position of the new offer)\n  ) external payable override onlyAdmin returns (uint offerId) {\n    return\n      MGV.newOffer{value: msg.value}(\n        outbound_tkn,\n        inbound_tkn,\n        wants,\n        gives,\n        gasreq,\n        gasprice,\n        pivotId\n      );\n  }\n\n  // Updates offer `offerId` on the (`outbound_tkn,inbound_tkn`) Offer List of Mangrove.\n  // NB #1: Offer maker MUST:\n  // * Make sure that offer maker has enough WEI provision on Mangrove to cover for the new offer bounty in case Mangrove gasprice has increased (function is payable so that caller can increase provision prior to updating the offer)\n  // * Make sure that `gasreq` and `gives` yield a sufficient offer density\n  // NB #2: This function will revert when the above points are not met\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external payable override onlyAdmin {\n    return\n      MGV.updateOffer{value: msg.value}(\n        outbound_tkn,\n        inbound_tkn,\n        wants,\n        gives,\n        gasreq,\n        gasprice,\n        pivotId,\n        offerId\n      );\n  }\n\n  // Retracts `offerId` from the (`outbound_tkn`,`inbound_tkn`) Offer list of Mangrove.\n  // Function call will throw if `this` contract is not the owner of `offerId`.\n  // Returned value is the amount of ethers that have been credited to `this` contract balance on Mangrove (always 0 if `deprovision=false`)\n  // NB `mgvOrAdmin` modifier guarantees that this function is either called by contract admin or during trade execution by Mangrove\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\n  ) public override mgvOrAdmin returns (uint) {\n    return MGV.retractOffer(outbound_tkn, inbound_tkn, offerId, deprovision);\n  }\n\n  function getMissingProvision(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq,\n    uint gasprice,\n    uint offerId\n  ) public view override returns (uint) {\n    return\n      _getMissingProvision(\n        MGV.balanceOf(address(this)), // current provision of offer maker is simply the current provision of `this` contract on Mangrove\n        outbound_tkn,\n        inbound_tkn,\n        gasreq,\n        gasprice,\n        offerId\n      );\n  }\n\n  // default `__put__` hook for `SingleUser` strats: received tokens are juste stored in `this` contract balance of `inbound` tokens.\n  function __put__(\n    uint, /*amount*/\n    ML.SingleOrder calldata\n  ) internal virtual override returns (uint) {\n    return 0;\n  }\n\n  // default `__get__` hook for `SingleUser` strats: promised liquidity is obtained from `this` contract balance of `outbound` tokens\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint balance = IEIP20(order.outbound_tkn).balanceOf(address(this));\n    if (balance >= amount) {\n      return 0;\n    } else {\n      return (amount - balance);\n    }\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/Defensive/PriceFed.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// PriceFed.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../../Defensive.sol\";\nimport \"../../AaveV3Lender.sol\";\n\ncontract PriceFed is Defensive, AaveV3Lender {\n  constructor(\n    address _oracle,\n    address _addressesProvider,\n    address payable _MGV\n  ) Defensive(_oracle) AaveV3Module(_addressesProvider, 0) MangroveOffer(_MGV) {\n    setGasreq(800_000);\n  }\n\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n\n  event Slippage(uint indexed offerId, uint old_wants, uint new_wants);\n\n  // reposts only if offer was reneged due to a price slippage\n  function __posthookReneged__(ML.SingleOrder calldata order)\n    internal\n    override\n  {\n    uint old_wants = order.offer.wants();\n    uint old_gives = order.offer.gives();\n    uint price_quote = oracle.getPrice(order.inbound_tkn);\n    uint price_base = oracle.getPrice(order.outbound_tkn);\n\n    uint new_offer_wants = (old_gives * price_base) / price_quote;\n    emit Slippage(order.offerId, old_wants, new_offer_wants);\n    // since offer is persistent it will auto refill if contract does not have enough provision on the Mangrove\n    try\n      MGV.updateOffer(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        new_offer_wants,\n        old_gives,\n        OFR_GASREQ,\n        0,\n        0,\n        order.offerId\n      )\n    {} catch Error(string memory message) {\n      emit PosthookFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        message\n      );\n    }\n  }\n\n  // Closing diamond inheritance for solidity compiler\n  // get/put and lender strat's functions\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    override(SingleUser, AaveV3Lender)\n    returns (uint)\n  {\n    return AaveV3Lender.__get__(amount, order);\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    override(SingleUser, AaveV3Lender)\n    returns (uint)\n  {\n    return AaveV3Lender.__put__(amount, order);\n  }\n\n  // lastlook is defensive strat's function\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override(MangroveOffer, Defensive)\n    returns (bool)\n  {\n    return Defensive.__lastLook__(order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Defensive.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Defensive.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./SingleUser.sol\";\nimport \"../../interfaces/IOracle.sol\";\n\n/** Strat class with simple oracle based last-look management */\n/** (Single user variant) */\n\nabstract contract Defensive is SingleUser {\n  uint16 slippage_num;\n  uint16 constant slippage_den = 10**4;\n  IOracle public oracle;\n\n  // emitted when no price data is available for given token\n  event MissingPrice(address token);\n\n  constructor(address _oracle) {\n    require(!(_oracle == address(0)), \"SingleUser/Defensive/0xOracle\");\n    oracle = IOracle(_oracle);\n  }\n\n  function setSlippage(uint _slippage) external onlyAdmin {\n    require(\n      uint16(_slippage) == _slippage && uint16(_slippage) <= slippage_den,\n      \"SingelUser/Defensive/SlippageInvalid\"\n    );\n    slippage_num = uint16(_slippage);\n  }\n\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool)\n  {\n    uint offer_gives_REF = order.wants * oracle.getPrice(order.outbound_tkn); // returns price in oracle base units (i.e ETH or USD)\n    uint offer_wants_REF = order.gives * oracle.getPrice(order.inbound_tkn); // returns price is oracle base units (i.e ETH or USD)\n    // abort trade if price data is not available\n    if (offer_gives_REF == 0) {\n      emit MissingPrice(order.outbound_tkn);\n      return false;\n    }\n    if (offer_wants_REF == 0) {\n      emit MissingPrice(order.inbound_tkn);\n      return false;\n    }\n    // if offer_gives_REF * (1-slippage) > offer_wants_REF one is getting arb'ed\n    // i.e slippage_den * OGR - slippage_num * OGR > OWR * slippage_den\n    return\n      offer_gives_REF * slippage_den - offer_gives_REF * slippage_num <=\n      offer_wants_REF * slippage_den;\n  }\n}\n"
    },
    "contracts/Strategies/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// IOracle.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\npragma solidity ^0.8.10;\npragma abicoder v2;\n\ninterface IOracle {\n  function decimals() external view returns (uint8);\n\n  function getPrice(address token) external view returns (uint96);\n\n  function setPrice(address token, uint price) external;\n}\n"
    },
    "contracts/Strategies/lib/SimpleOracle.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleOrale.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../interfaces/IOracle.sol\";\nimport \"./AccessControlled.sol\";\nimport {IERC20} from \"../../MgvLib.sol\";\n\ncontract SimpleOracle is IOracle, AccessControlled {\n  address reader; // if unset, anyone can read price\n  IERC20 public immutable base_token;\n  mapping(address => uint96) internal priceData;\n\n  constructor(address _base) {\n    try IERC20(_base).decimals() returns (uint8 d) {\n      require(d != 0, \"Invalid decimals number for Oracle base\");\n      base_token = IERC20(_base);\n    } catch {\n      revert(\"Invalid Oracle base address\");\n    }\n  }\n\n  function decimals() external view override returns (uint8) {\n    return base_token.decimals();\n  }\n\n  function setReader(address _reader) external onlyAdmin {\n    reader = _reader;\n  }\n\n  function setPrice(address token, uint price) external override onlyAdmin {\n    require(uint96(price) == price, \"price overflow\");\n    priceData[token] = uint96(price);\n  }\n\n  function getPrice(address token)\n    external\n    view\n    override\n    onlyCaller(reader)\n    returns (uint96 price)\n  {\n    price = priceData[token];\n    require(price != 0, \"missing price data\");\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/SimpleMaker.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleMaker.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../SingleUser.sol\";\n\n/* Simply inherits SingleUser and is deployable. No internal logic. */\ncontract SimpleMaker is SingleUser {\n  constructor(address payable _MGV) MangroveOffer(_MGV) {}\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Persistent.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Persistent.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./SingleUser.sol\";\n\n/** Strat class with specialized hooks that repost offer residual after a partial fill */\n/** (Single user variant) */\n\nabstract contract Persistent is SingleUser {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n\n  /** Persistent class specific hooks. */\n\n  // Hook that defines how much inbound tokens the residual offer should ask for when repositing itself on the Offer List.\n  // default is to repost the old amount minus the partial fill\n  function __residualWants__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.wants() - order.gives;\n  }\n\n  // Hook that defines how much outbound tokens the residual offer should promise for when repositing itself on the Offer List.\n  // default is to repost the old required amount minus the partial fill\n  // NB this could produce an offer below the density. Offer Maker should perform a density check at repost time if not willing to fail reposting.\n  function __residualGives__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.gives() - order.wants;\n  }\n\n  // Specializing this hook to repost offer residual when trade was a success\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n  {\n    uint new_gives = __residualGives__(order);\n    // Density check would be too gas costly.\n    // We only treat the special case of `gives==0` (total fill).\n    // Offer below the density will cause Mangrove to throw (revert is catched to log information)\n    if (new_gives == 0) {\n      return;\n    }\n    uint new_wants = __residualWants__(order);\n    try\n      MGV.updateOffer(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        new_wants,\n        new_gives,\n        order.offerDetail.gasreq(),\n        order.offerDetail.gasprice(),\n        order.offer.next(),\n        order.offerId\n      )\n    {} catch Error(string memory message) {\n      // Two possible reasons to reach this code:\n      // * Offer was reposted below density\n      // * Offer is not sufficiently provisioned (because Mangrove gas price was updated)\n      emit PosthookFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        message\n      );\n    }\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/Reposting.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Reposting.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../Persistent.sol\";\n\n/* Simply inherits Persistent and is deployable. No additional internal logic. */\ncontract Reposting is Persistent {\n  constructor(address payable _MGV) MangroveOffer(_MGV) {}\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/MarketMaking/Mango.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Mango.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../Persistent.sol\";\n\n/** Discrete automated market making strat */\n/** This AMM is headless (no price model) and market makes on `NSLOTS` price ranges*/\n/** current `Pmin` is the price of an offer at position `0`, current `Pmax` is the price of an offer at position `NSLOTS-1`*/\n/** Initially `Pmin = P(0) = QUOTE_0/BASE_0` and the general term is P(i) = __quote_progression__(i)/BASE_0 */\n/** NB `__quote_progression__` is a hook that defines how price increases with positions and is by default an arithmetic progression, i.e __quote_progression__(i) = QUOTE_0 + `current_delta`*i */\n/** When one of its offer is matched on Mangrove, the headless strat does the following: */\n/** Each time this strat receives b `BASE` tokens (bid was taken) at price position i, it increases the offered (`BASE`) volume of the ask at position i+1 of 'b'*/\n/** Each time this strat receives q `QUOTE` tokens (ask was taken) at price position i, it increases the offered (`QUOTE`) volume of the bid at position i-1 of 'q'*/\n/** In case of a partial fill of an offer at position i, the offer residual is reposted (see `Persistent` strat class)*/\n\ncontract Mango is Persistent {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n\n  /** Strat specific events */\n\n  // emitted when strat has reached max amount of Bids and needs rebalancing (should shift of x>0 positions in order to have bid prices that are better for the taker)\n  event BidAtMaxPosition(address quote, address base, uint offerId);\n\n  // emitted when strat has reached max amount of Asks and needs rebalancing (should shift of x<0 positions in order to have ask prices that are better for the taker)\n  event AskAtMinPosition(address quote, address base, uint offerId);\n\n  // emitted when init function has been called and AMM becomes active\n  event Initialized(uint from, uint to);\n\n  /** Immutable fields */\n  // total number of Asks (resp. Bids)\n  uint16 public immutable NSLOTS;\n\n  // initial min price given by `QUOTE_0/BASE_0`\n  uint96 immutable BASE_0;\n  uint96 immutable QUOTE_0;\n\n  address public immutable BASE;\n  address public immutable QUOTE;\n\n  /** Mutable fields */\n  // Asks and bids offer Ids are stored in `ASKS` and `BIDS` arrays respectively.\n  uint[] ASKS;\n  uint[] BIDS;\n  mapping(uint => uint) index_of_bid; // bidId -> index\n  mapping(uint => uint) index_of_ask; // askId -> index\n\n  // Price shift is in number of price increments (or decrements when current_shift < 0) since deployment of the strat.\n  // e.g. for arithmetic progression, `current_shift = -3` indicates that Pmin is now (`QUOTE_0` - 3*`current_delta`)/`BASE_0`\n  int current_shift;\n\n  // parameter for price progression\n  // NB for arithmetic progression, price(i+1) = price(i) + current_delta/`BASE_0`\n  uint current_delta; // quote increment\n\n  // triggers `__boundariesReached__` whenever amounts of bids/asks is below `current_min_buffer`\n  uint current_min_buffer;\n\n  // puts the strat into a (cancellable) state where it reneges on all incoming taker orders.\n  // NB reneged offers are removed from Mangrove's OB\n  bool paused = false;\n\n  // Base and quote token treasuries\n  // default is `this` for both\n  address current_base_treasury;\n  address current_quote_treasury;\n\n  constructor(\n    address payable mgv,\n    address base,\n    address quote,\n    uint base_0,\n    uint quote_0,\n    uint nslots,\n    uint delta\n  ) MangroveOffer(mgv) {\n    // sanity check\n    require(\n      nslots > 0 &&\n        mgv != address(0) &&\n        uint16(nslots) == nslots &&\n        uint96(base_0) == base_0 &&\n        uint96(quote_0) == quote_0,\n      \"Mango/constructor/invalidArguments\"\n    );\n    BASE = base;\n    QUOTE = quote;\n    NSLOTS = uint16(nslots);\n    ASKS = new uint[](nslots);\n    BIDS = new uint[](nslots);\n    BASE_0 = uint96(base_0);\n    QUOTE_0 = uint96(quote_0);\n    current_delta = delta;\n    current_min_buffer = 1;\n    current_quote_treasury = msg.sender;\n    current_base_treasury = msg.sender;\n    OFR_GASREQ = 400_000; // dry run OK with 200_000\n  }\n\n  // populate mangrove order book with bids or/and asks in the price range R = [`from`, `to`[\n  function initialize(\n    uint lastBidPosition, // if `lastBidPosition` is in R, then all offers before `lastBidPosition` (included) will be bids, offers strictly after will be asks.\n    bool withBaseWhenBidding,\n    uint from, // first price position to be populated\n    uint to, // last price position to be populated\n    uint[][2] calldata pivotIds, // `pivotIds[0][i]` ith pivots for bids, `pivotIds[1][i]` ith pivot for asks\n    uint[] calldata tokenAmounts // `tokenAmounts[i]` is the amount of `BASE` or `QUOTE` tokens (depending on `withBase` flag) that is used to fixed one parameter of the price at position `from+i`.\n  ) public mgvOrAdmin {\n    /** Initializing Asks and Bids */\n    /** NB we assume Mangrove is already provisioned for posting NSLOTS asks and NSLOTS bids*/\n    /** NB cannot post newOffer with infinite gasreq since fallback OFR_GASREQ is not defined yet (and default is likely wrong) */\n    require(to > from, \"Mango/initialize/invalidSlice\");\n    require(\n      tokenAmounts.length == NSLOTS &&\n        pivotIds.length == 2 &&\n        pivotIds[0].length == NSLOTS &&\n        pivotIds[1].length == NSLOTS,\n      \"Mango/initialize/invalidArrayLength\"\n    );\n    require(lastBidPosition < NSLOTS - 1, \"Mango/initialize/NoSlotForAsks\"); // bidding => slice doesn't fill the book\n    uint pos;\n    for (pos = from; pos < to; pos++) {\n      // if shift is not 0, must convert\n      uint i = index_of_position(pos);\n      if (pos <= lastBidPosition) {\n        uint bidPivot = pivotIds[0][pos];\n        bidPivot = bidPivot > 0\n          ? bidPivot // taking pivot from the user\n          : pos > 0\n          ? BIDS[index_of_position(pos - 1)]\n          : 0; // otherwise getting last inserted offer as pivot\n        updateBid({\n          index: i,\n          withBase: withBaseWhenBidding,\n          reset: true, // overwrites old value\n          amount: tokenAmounts[pos],\n          pivotId: bidPivot\n        });\n        if (ASKS[i] > 0) {\n          // if an ASK is also positioned, remove it to prevent spread crossing\n          // (should not happen if this is the first initialization of the strat)\n          retractOffer(BASE, QUOTE, ASKS[i], false);\n        }\n      } else {\n        uint askPivot = pivotIds[1][pos];\n        askPivot = askPivot > 0\n          ? askPivot // taking pivot from the user\n          : pos > 0\n          ? ASKS[index_of_position(pos - 1)]\n          : 0; // otherwise getting last inserted offer as pivot\n        updateAsk({\n          index: i,\n          withBase: !withBaseWhenBidding,\n          reset: true,\n          amount: tokenAmounts[pos],\n          pivotId: askPivot\n        });\n        if (BIDS[i] > 0) {\n          // if a BID is also positioned, remove it to prevent spread crossing\n          // (should not happen if this is the first initialization of the strat)\n          retractOffer(QUOTE, BASE, BIDS[i], false);\n        }\n      }\n    }\n    emit Initialized({from: from, to: to});\n  }\n\n  /** Sets the account from which base (resp. quote) tokens need to be fetched or put during trade execution*/\n  function set_treasury(bool base, address treasury) external onlyAdmin {\n    require(treasury != address(0), \"Mango/set_treasury/0xTreasury\");\n    if (base) {\n      current_base_treasury = treasury;\n    } else {\n      current_quote_treasury = treasury;\n    }\n  }\n\n  function get_treasury(bool base) external view onlyAdmin returns (address) {\n    return base ? current_base_treasury : current_quote_treasury;\n  }\n\n  function putInternal(\n    address erc_,\n    uint amount,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    IEIP20 erc;\n    address treasury;\n    if (erc_ == BASE) {\n      erc = IEIP20(BASE);\n      treasury = current_base_treasury;\n    } else {\n      erc = IEIP20(QUOTE);\n      treasury = current_quote_treasury;\n    }\n    try erc.transfer(treasury, amount) returns (bool success) {\n      if (success) {\n        return 0;\n      } else {\n        emit LogIncident(\n          order.outbound_tkn,\n          order.inbound_tkn,\n          order.offerId,\n          \"Mango/transferFailed\"\n        );\n        return amount;\n      }\n    } catch (bytes memory reason) {\n      emit LogIncident(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        reason\n      );\n      return amount;\n    }\n  }\n\n  /** Deposits received tokens into the corresponding treasury*/\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    if (order.inbound_tkn == BASE && current_base_treasury != address(this)) {\n      return putInternal(BASE, amount, order);\n    }\n    if (current_quote_treasury != address(this)) {\n      return putInternal(QUOTE, amount, order);\n    }\n    // order.inbound_tkn has to be either BASE or QUOTE so only possibility is `this` is treasury\n    return 0;\n  }\n\n  function getInternal(\n    address erc_,\n    uint amount,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    IEIP20 erc;\n    address treasury;\n    if (erc_ == BASE) {\n      erc = IEIP20(BASE);\n      treasury = current_base_treasury;\n    } else {\n      erc = IEIP20(QUOTE);\n      treasury = current_quote_treasury;\n    }\n    try erc.transferFrom(treasury, address(this), amount) returns (\n      bool success\n    ) {\n      if (success) {\n        return 0;\n      } else {\n        emit LogIncident(\n          order.outbound_tkn,\n          order.inbound_tkn,\n          order.offerId,\n          \"Mango/transferFromFailed\"\n        );\n        return amount;\n      }\n    } catch (bytes memory reason) {\n      emit LogIncident(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        reason\n      );\n      return amount;\n    }\n  }\n\n  /** Fetches required tokens from the corresponding treasury*/\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    if (order.outbound_tkn == BASE && current_base_treasury != address(this)) {\n      return getInternal(BASE, amount, order);\n    }\n    if (current_quote_treasury != address(this)) {\n      return getInternal(QUOTE, amount, order);\n    }\n    // order.outbound_tkn has to be either BASE or QUOTE so only possibility is `this` is treasury\n    return super.__get__(amount, order);\n  }\n\n  // with ba=0:bids only, ba=1: asks only ba>1 all\n  function retractOffers(\n    uint ba,\n    uint from,\n    uint to\n  ) external onlyAdmin returns (uint collected) {\n    for (uint i = from; i < to; i++) {\n      if (ba > 0) {\n        // asks or bids+asks\n        collected += ASKS[i] > 0 ? retractOffer(BASE, QUOTE, ASKS[i], true) : 0;\n      }\n      if (ba == 0 || ba > 1) {\n        // bids or bids + asks\n        collected += BIDS[i] > 0 ? retractOffer(QUOTE, BASE, BIDS[i], true) : 0;\n      }\n    }\n  }\n\n  /** Setters and getters */\n  function get_delta() external view onlyAdmin returns (uint) {\n    return current_delta;\n  }\n\n  function set_delta(uint delta) public mgvOrAdmin {\n    current_delta = delta;\n  }\n\n  function get_shift() external view onlyAdmin returns (int) {\n    return current_shift;\n  }\n\n  /** Shift the price (induced by quote amount) of n slots down or up */\n  /** price at position i will be shifted (up or down depending on the sign of `shift`) */\n  /** New positions 0<= i < s are initialized with amount[i] in base tokens if `withBase`. In quote tokens otherwise*/\n  function set_shift(\n    int s,\n    bool withBase,\n    uint[] calldata amounts\n  ) public mgvOrAdmin {\n    require(\n      amounts.length == (s < 0 ? uint(-s) : uint(s)),\n      \"Mango/set_shift/notEnoughAmounts\"\n    );\n    if (s < 0) {\n      negative_shift(uint(-s), withBase, amounts);\n    } else {\n      positive_shift(uint(s), withBase, amounts);\n    }\n  }\n\n  function set_min_offer_type(uint m) public mgvOrAdmin {\n    current_min_buffer = m;\n  }\n\n  // return Mango offer Ids on Mangrove. If `liveOnly` will only return offer Ids that are live (0 otherwise).\n  function get_offers(bool liveOnly)\n    external\n    view\n    returns (uint[][2] memory offers)\n  {\n    offers[0] = new uint[](NSLOTS);\n    offers[1] = new uint[](NSLOTS);\n    for (uint i = 0; i < NSLOTS; i++) {\n      uint askId = ASKS[index_of_position(i)];\n      uint bidId = BIDS[index_of_position(i)];\n\n      offers[0][i] = (MGV.offers(QUOTE, BASE, bidId).gives() > 0 || !liveOnly)\n        ? BIDS[index_of_position(i)]\n        : 0;\n      offers[1][i] = (MGV.offers(BASE, QUOTE, askId).gives() > 0 || !liveOnly)\n        ? ASKS[index_of_position(i)]\n        : 0;\n    }\n  }\n\n  // starts reneging all offers\n  // NB reneged offers will not be reposted\n  function pause() public mgvOrAdmin {\n    paused = true;\n  }\n\n  function restart() external onlyAdmin {\n    paused = false;\n  }\n\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool proceed)\n  {\n    order; //shh\n    proceed = !paused;\n  }\n\n  function writeOffer(\n    uint index,\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint pivotId\n  ) internal {\n    inbound_tkn; // shh\n    if (outbound_tkn == BASE) {\n      // Asks\n      if (ASKS[index] == 0) {\n        // offer slot not initialized yet\n        ASKS[index] = MGV.newOffer({\n          outbound_tkn: BASE,\n          inbound_tkn: QUOTE,\n          wants: wants,\n          gives: gives,\n          gasreq: OFR_GASREQ,\n          gasprice: 0,\n          pivotId: pivotId\n        });\n        index_of_ask[ASKS[index]] = index;\n      } else {\n        MGV.updateOffer({\n          outbound_tkn: BASE,\n          inbound_tkn: QUOTE,\n          wants: wants,\n          gives: gives,\n          gasreq: OFR_GASREQ,\n          gasprice: 0,\n          pivotId: pivotId,\n          offerId: ASKS[index]\n        });\n      }\n      if (position_of_index(index) <= current_min_buffer) {\n        __boundariesReached__(false, ASKS[index]);\n      }\n    } else {\n      // Bids\n      if (BIDS[index] == 0) {\n        BIDS[index] = MGV.newOffer({\n          outbound_tkn: QUOTE,\n          inbound_tkn: BASE,\n          wants: wants,\n          gives: gives,\n          gasreq: OFR_GASREQ,\n          gasprice: 0,\n          pivotId: pivotId\n        });\n        index_of_bid[BIDS[index]] = index;\n      } else {\n        MGV.updateOffer({\n          outbound_tkn: QUOTE,\n          inbound_tkn: BASE,\n          wants: wants,\n          gives: gives,\n          gasreq: OFR_GASREQ,\n          gasprice: 0,\n          pivotId: pivotId,\n          offerId: BIDS[index]\n        });\n      }\n      if (position_of_index(index) >= NSLOTS - 1 - current_min_buffer) {\n        __boundariesReached__(true, BIDS[index]);\n      }\n    }\n  }\n\n  // returns the value of x in the ring [0,m]\n  // i.e if x>=0 this is just x % m\n  // if x<0 this is m + (x % m)\n  function modulo(int x, uint m) internal pure returns (uint) {\n    if (x >= 0) {\n      return uint(x) % m;\n    } else {\n      return uint(int(m) + (x % int(m)));\n    }\n  }\n\n  /** Minimal amount of quotes for the general term of the `__quote_progression__` */\n  /** If min price was not shifted this is just `QUOTE_0` */\n  /** In general this is QUOTE_0 + shift*delta */\n  function quote_min() internal view returns (uint) {\n    int qm = int(uint(QUOTE_0)) + current_shift * int(current_delta);\n    require(qm > 0, \"Mango/quote_min/ShiftUnderflow\");\n    return (uint(qm));\n  }\n\n  /** Returns the position in the order book of the offer associated to this index `i` */\n  function position_of_index(uint i) internal view returns (uint) {\n    // position(i) = (i+shift) % N\n    return modulo(int(i) - current_shift, NSLOTS);\n  }\n\n  /** Returns the index in the ring of offers at which the offer Id at position `p` in the book is stored */\n  function index_of_position(uint p) internal view returns (uint) {\n    return modulo(int(p) + current_shift, NSLOTS);\n  }\n\n  /**Next index in the ring of offers */\n  function next_index(uint i) internal view returns (uint) {\n    return (i + 1) % NSLOTS;\n  }\n\n  /**Previous index in the ring of offers */\n  function prev_index(uint i) internal view returns (uint) {\n    return i > 0 ? i - 1 : NSLOTS - 1;\n  }\n\n  /** Function that determines the amount of quotes that are offered at position i of the OB depending on initial_price and paramater delta*/\n  /** Here the default is an arithmetic progression */\n  function __quote_progression__(uint position)\n    internal\n    view\n    virtual\n    returns (uint)\n  {\n    return current_delta * position + quote_min();\n  }\n\n  /** Returns the quantity of quote tokens for an offer at position `p` given an amount of Base tokens (eq. 2)*/\n  function quotes_of_position(uint p, uint base_amount)\n    internal\n    view\n    returns (uint)\n  {\n    return (__quote_progression__(p) * base_amount) / BASE_0;\n  }\n\n  /** Returns the quantity of base tokens for an offer at position `p` given an amount of quote tokens (eq. 3)*/\n  function bases_of_position(uint p, uint quote_amount)\n    internal\n    view\n    returns (uint)\n  {\n    return (quote_amount * BASE_0) / __quote_progression__(p);\n  }\n\n  /** Recenter the order book by shifting min price up `s` positions in the book */\n  /** As a consequence `s` Bids will be cancelled and `s` new asks will be posted */\n  function positive_shift(\n    uint s,\n    bool withBase,\n    uint[] calldata amounts\n  ) internal {\n    require(s < NSLOTS, \"Mango/shift/positiveShiftTooLarge\");\n    uint index = index_of_position(0);\n    current_shift += int(s); // updating new shift\n    // Warning: from now on position_of_index reflects the new shift\n    // One must progress relative to index when retracting offers\n    uint cpt = 0;\n    while (cpt < s) {\n      // slots occupied by [Bids[index],..,Bids[index+`s` % N]] are retracted\n      if (BIDS[index] != 0) {\n        retractOffer({\n          outbound_tkn: QUOTE,\n          inbound_tkn: BASE,\n          offerId: BIDS[index],\n          deprovision: false\n        });\n      }\n      // slots are replaced by `s` Asks.\n      // NB the price of Ask[index] is computed given the new position associated to `index`\n      // because the shift has been updated above\n\n      // `pos` is the offer position in the OB (not the array)\n      uint pos = position_of_index(index);\n      uint new_gives;\n      uint new_wants;\n      if (withBase) {\n        // posting new ASKS with base amount fixed\n        new_gives = amounts[cpt];\n        new_wants = quotes_of_position(pos, amounts[cpt]);\n      } else {\n        // posting new ASKS with quote amount fixed\n        new_wants = amounts[cpt];\n        new_gives = bases_of_position(pos, amounts[cpt]);\n      }\n      writeOffer({\n        index: index,\n        outbound_tkn: BASE,\n        inbound_tkn: QUOTE,\n        wants: new_wants,\n        gives: new_gives,\n        pivotId: pos > 0 ? ASKS[index_of_position(pos - 1)] : 0\n      });\n      cpt++;\n      index = next_index(index);\n    }\n  }\n\n  /** Recenter the order book by shifting max price down `s` positions in the book */\n  /** As a consequence `s` Asks will be cancelled and `s` new Bids will be posted */\n  function negative_shift(\n    uint s,\n    bool withBase,\n    uint[] calldata amounts\n  ) internal {\n    require(s < NSLOTS, \"Mango/shift/NegativeShiftTooLarge\");\n    uint index = index_of_position(NSLOTS - 1);\n    current_shift -= int(s); // updating new shift\n    // Warning: from now on position_of_index reflects the new shift\n    // One must progress relative to index when retracting offers\n    uint cpt;\n    while (cpt < s) {\n      // slots occupied by [Asks[index-`s` % N],..,Asks[index]] are retracted\n      if (ASKS[index] != 0) {\n        retractOffer({\n          outbound_tkn: BASE,\n          inbound_tkn: QUOTE,\n          offerId: ASKS[index],\n          deprovision: false\n        });\n      }\n      // slots are replaced by `s` Bids.\n      // NB the price of Bids[index] is computed given the new position associated to `index`\n      // because the shift has been updated above\n\n      // `pos` is the offer position in the OB (not the array)\n      uint pos = position_of_index(index);\n      uint new_gives;\n      uint new_wants;\n      if (withBase) {\n        // amounts in base\n        new_wants = amounts[cpt];\n        new_gives = quotes_of_position(pos, amounts[cpt]);\n      } else {\n        // amounts in quote\n        new_wants = bases_of_position(pos, amounts[cpt]);\n        new_gives = amounts[cpt];\n      }\n      writeOffer({\n        index: index,\n        outbound_tkn: QUOTE,\n        inbound_tkn: BASE,\n        wants: new_wants,\n        gives: new_gives,\n        pivotId: pos < NSLOTS - 1 ? BIDS[index_of_position(pos + 1)] : 0\n      });\n      cpt++;\n      index = prev_index(index);\n    }\n  }\n\n  // for reposting partial filled offers one always gives the residual (default behavior)\n  // and adapts wants to the new price (if different).\n  function __residualWants__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    if (order.outbound_tkn == BASE) {\n      // Ask offer (wants QUOTE)\n      uint index = index_of_ask[order.offerId];\n      uint residual_base = __residualGives__(order); // default\n      if (residual_base == 0) {\n        return 0;\n      }\n      return quotes_of_position(position_of_index(index), residual_base);\n    } else {\n      // Bid order (wants BASE)\n      uint index = index_of_bid[order.offerId];\n      uint residual_quote = __residualGives__(order); // default\n      if (residual_quote == 0) {\n        return 0;\n      }\n      return bases_of_position(position_of_index(index), residual_quote);\n    }\n  }\n\n  /** Define what to do when the AMM boundaries are reached (either when reposting a bid or a ask) */\n  function __boundariesReached__(bool bid, uint offerId) internal virtual {\n    if (bid) {\n      emit BidAtMaxPosition(QUOTE, BASE, offerId);\n    } else {\n      emit AskAtMinPosition(BASE, QUOTE, offerId);\n    }\n  }\n\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n  {\n    // reposting residual of offer using override `__newWants__` and default `__newGives` for new price\n    super.__posthookSuccess__(order);\n    if (order.outbound_tkn == BASE) {\n      // Ask Offer (`this` contract just sold some BASE @ pos)\n      uint index = index_of_ask[order.offerId];\n      if (index == 0) {\n        // offer was posted using newOffer, not during initialization\n        return;\n      }\n      uint pos = position_of_index(index);\n      // bid for some BASE token with the received QUOTE tokens @ pos-1\n      if (pos > 0) {\n        updateBid({\n          index: index_of_position(pos - 1),\n          withBase: false, // order gave QUOTES\n          reset: false, // top up old value with received amount\n          amount: order.gives, // in QUOTES\n          pivotId: 0\n        });\n      } else {\n        // Ask cannot be at Pmin unless a shift has eliminated all bids\n        emit PosthookFail(\n          order.outbound_tkn,\n          order.inbound_tkn,\n          order.offerId,\n          \"Mango/posthook/BuyingOutOfPriceRange\"\n        );\n        return;\n      }\n    } else {\n      // Bid offer (`this` contract just bought some BASE)\n      uint index = index_of_bid[order.offerId];\n      if (index == 0) {\n        // offer was posted using newOffer, not during initialization\n        return;\n      }\n      uint pos = position_of_index(index);\n      // ask for some QUOTE tokens in exchange of the received BASE tokens @ pos+1\n      if (pos < NSLOTS - 1) {\n        updateAsk({\n          index: index_of_position(pos + 1),\n          withBase: true, // order gave BASE\n          reset: false, // top up old value with received amount\n          amount: order.gives, // in BASE\n          pivotId: 0\n        });\n      } else {\n        // Take profit\n        emit PosthookFail(\n          order.outbound_tkn,\n          order.inbound_tkn,\n          order.offerId,\n          \"Mango/posthook/SellingOutOfPriceRange\"\n        );\n        return;\n      }\n    }\n  }\n\n  function updateBid(\n    uint index,\n    bool withBase,\n    bool reset,\n    uint amount,\n    uint pivotId\n  ) internal {\n    // outbound : QUOTE, inbound: BASE\n    P.Offer.t offer = MGV.offers(QUOTE, BASE, BIDS[index]);\n\n    uint position = position_of_index(index);\n    uint new_wants;\n    uint new_gives;\n    if (withBase) {\n      // amount: BASE\n      new_wants = reset ? amount : amount + offer.wants();\n      new_gives = quotes_of_position(position, new_wants);\n    } else {\n      // amount: QUOTE\n      new_gives = reset ? amount : amount + offer.gives();\n      new_wants = bases_of_position(position, new_gives);\n    }\n    uint pivot;\n    if (offer.gives() == 0) {\n      // offer was not live\n      if (pivotId != 0) {\n        pivot = pivotId;\n      } else {\n        if (position > 0) {\n          pivot = BIDS[index_of_position(position - 1)]; // if this offer is no longer in the book will start form best\n        } else {\n          pivot = offer.prev(); // trying previous offer on Mangrove as a pivot\n        }\n      }\n    } else {\n      // offer is live, so reusing its id for pivot\n      pivot = BIDS[index];\n    }\n    writeOffer({\n      index: index,\n      outbound_tkn: QUOTE,\n      inbound_tkn: BASE,\n      wants: new_wants,\n      gives: new_gives,\n      pivotId: pivot\n    });\n  }\n\n  function updateAsk(\n    uint index,\n    bool withBase,\n    bool reset,\n    uint amount,\n    uint pivotId\n  ) internal {\n    // outbound : BASE, inbound: QUOTE\n    P.Offer.t offer = MGV.offers(BASE, QUOTE, ASKS[index]);\n    uint position = position_of_index(index);\n    uint new_gives;\n    uint new_wants;\n    if (withBase) {\n      // amount: BASE\n      new_gives = reset ? amount : amount + offer.gives(); // in BASE\n      new_wants = quotes_of_position(position, new_gives);\n    } else {\n      new_wants = reset ? amount : amount + offer.wants(); // in QUOTES\n      new_gives = bases_of_position(position, new_wants);\n    }\n\n    uint pivot;\n    if (offer.gives() == 0) {\n      // offer was not live\n      if (pivotId != 0) {\n        pivot = pivotId;\n      } else {\n        if (position > 0) {\n          pivot = ASKS[index_of_position(position - 1)]; // if this offer is no longer in the book will start form best\n        } else {\n          pivot = offer.prev(); // trying previous offer on Mangrove as a pivot\n        }\n      }\n    } else {\n      // offer is live, so reusing its id for pivot\n      pivot = ASKS[index];\n    }\n    writeOffer({\n      index: index,\n      outbound_tkn: BASE,\n      inbound_tkn: QUOTE,\n      wants: new_wants,\n      gives: new_gives,\n      pivotId: pivot\n    });\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/CompoundLender.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// CompoundLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../CompoundModule.sol\";\nimport \"./SingleUser.sol\";\n\nabstract contract CompoundLender is SingleUser, CompoundModule {\n  function approveLender(IcERC20 ctoken, uint amount) external onlyAdmin {\n    require(_approveLender(ctoken, amount), \"Lender/ApproveFail\");\n  }\n\n  function enterMarkets(address[] calldata ctokens) external onlyAdmin {\n    _enterMarkets(ctokens);\n  }\n\n  function exitMarket(IcERC20 ctoken) external onlyAdmin {\n    _exitMarket(ctoken);\n  }\n\n  function claimComp() external onlyAdmin {\n    _claimComp();\n  }\n\n  function mint(\n    uint amount,\n    IcERC20 ctoken,\n    address\n  ) external onlyAdmin {\n    uint errCode = _mint(amount, ctoken);\n    require(errCode == 0, \"Lender/mintFailed\");\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    if (!isPooled(IEIP20(order.outbound_tkn))) {\n      // if flag says not to fetch liquidity on compound\n      return amount;\n    }\n    // if outbound_tkn == weth, overlying will return cEth\n    IcERC20 outbound_cTkn = overlyings[IEIP20(order.outbound_tkn)]; // this is 0x0 if outbound_tkn is not compound sourced.\n    if (address(outbound_cTkn) == address(0)) {\n      return amount;\n    }\n    (uint redeemable, ) = maxGettableUnderlying(\n      address(outbound_cTkn),\n      address(this)\n    );\n    if (redeemable < amount) {\n      return amount; //give up if __get__ cannot withdraw enough\n    }\n    // else try redeem on compound\n    if (compoundRedeem(amount, order) == 0) {\n      // redeemAmount was transfered to `this`\n      return 0;\n    }\n    return amount;\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (!isPooled(IEIP20(order.inbound_tkn))) {\n      return amount;\n    }\n    return compoundMint(amount, order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/CompoundModule.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// CompoundModule.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../interfaces/compound/ICompound.sol\";\nimport \"../lib/Exponential.sol\";\nimport \"../interfaces/IMangrove.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract CompoundModule is Exponential {\n  event ErrorOnRedeem(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    uint errorCode\n  );\n  event ErrorOnMint(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    uint errorCode\n  );\n\n  event ComptrollerError(address comp, uint errorCode);\n\n  // mapping : ERC20 -> cERC20\n  mapping(IEIP20 => IcERC20) overlyings;\n\n  // address of the comptroller\n  IComptroller public immutable comptroller;\n\n  // address of the price oracle used by the comptroller\n  ICompoundPriceOracle public immutable oracle;\n\n  IEIP20 immutable weth;\n\n  constructor(address _unitroller, address wethAddress) {\n    comptroller = IComptroller(_unitroller); // unitroller is a proxy for comptroller calls\n    require(_unitroller != address(0), \"Invalid comptroller address\");\n    ICompoundPriceOracle _oracle = IComptroller(_unitroller).oracle(); // pricefeed used by the comptroller\n    require(address(_oracle) != address(0), \"Failed to get price oracle\");\n    oracle = _oracle;\n    weth = IEIP20(wethAddress);\n  }\n\n  function isCeth(IcERC20 ctoken) internal view returns (bool) {\n    return (keccak256(abi.encodePacked(ctoken.symbol())) ==\n      keccak256(abi.encodePacked(\"cETH\")));\n  }\n\n  //dealing with cEth special case\n  function underlying(IcERC20 ctoken) internal view returns (IEIP20) {\n    require(ctoken.isCToken(), \"Invalid ctoken address\");\n    if (isCeth(ctoken)) {\n      // cETH has no underlying() function...\n      return weth;\n    } else {\n      return IEIP20(ctoken.underlying());\n    }\n  }\n\n  function _approveLender(IcERC20 ctoken, uint amount) internal returns (bool) {\n    IEIP20 token = underlying(ctoken);\n    return token.approve(address(ctoken), amount);\n  }\n\n  function _enterMarkets(address[] calldata ctokens) internal {\n    uint[] memory results = comptroller.enterMarkets(ctokens);\n    for (uint i = 0; i < ctokens.length; i++) {\n      require(results[i] == 0, \"Failed to enter market\");\n      IEIP20 token = underlying(IcERC20(ctokens[i]));\n      // adding ctoken.underlying --> ctoken mapping\n      overlyings[token] = IcERC20(ctokens[i]);\n    }\n  }\n\n  function _exitMarket(IcERC20 ctoken) internal {\n    require(\n      comptroller.exitMarket(address(ctoken)) == 0,\n      \"failed to exit marker\"\n    );\n  }\n\n  function _claimComp() internal {\n    comptroller.claimComp(address(this));\n  }\n\n  function isPooled(IEIP20 token) public view returns (bool) {\n    IcERC20 ctoken = overlyings[token];\n    return comptroller.checkMembership(address(this), ctoken);\n  }\n\n  /// @notice struct to circumvent stack too deep error in `maxGettableUnderlying` function\n  struct Heap {\n    uint ctokenBalance;\n    uint cDecimals;\n    uint decimals;\n    uint exchangeRateMantissa;\n    uint liquidity;\n    uint collateralFactorMantissa;\n    uint maxRedeemable;\n    uint balanceOfUnderlying;\n    uint priceMantissa;\n    uint underlyingLiquidity;\n    MathError mErr;\n    uint errCode;\n  }\n\n  function heapError(Heap memory heap) private pure returns (bool) {\n    return (heap.errCode != 0 || heap.mErr != MathError.NO_ERROR);\n  }\n\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\n  /// returns (R, B|R)\n  function maxGettableUnderlying(address _ctoken, address account)\n    public\n    view\n    returns (uint, uint)\n  {\n    IcERC20 ctoken = IcERC20(_ctoken);\n    Heap memory heap;\n    // NB balance below is underestimated unless accrue interest was triggered earlier in the transaction\n    (heap.errCode, heap.ctokenBalance, , heap.exchangeRateMantissa) = ctoken\n      .getAccountSnapshot(address(this)); // underapprox\n    heap.priceMantissa = oracle.getUnderlyingPrice(ctoken); //18 decimals\n\n    // balanceOfUnderlying(A) : cA.balance * exchange_rate(cA,A)\n\n    (heap.mErr, heap.balanceOfUnderlying) = mulScalarTruncate(\n      Exp({mantissa: heap.exchangeRateMantissa}),\n      heap.ctokenBalance // ctokens have 8 decimals precision\n    );\n\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n\n    // max amount of outbound_Tkn token than can be borrowed\n    (\n      heap.errCode,\n      heap.liquidity, // is USD:18 decimals\n      /*shortFall*/\n\n    ) = comptroller.getAccountLiquidity(account); // underapprox\n\n    // to get liquidity expressed in outbound_Tkn token instead of USD\n    (heap.mErr, heap.underlyingLiquidity) = divScalarByExpTruncate(\n      heap.liquidity,\n      Exp({mantissa: heap.priceMantissa})\n    );\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n    (, heap.collateralFactorMantissa, ) = comptroller.markets(address(ctoken));\n\n    // if collateral factor is 0 then any token can be redeemed from the pool w/o impacting borrow power\n    // also true if market is not entered\n    if (\n      heap.collateralFactorMantissa == 0 ||\n      !comptroller.checkMembership(account, ctoken)\n    ) {\n      return (heap.balanceOfUnderlying, heap.underlyingLiquidity);\n    }\n\n    // maxRedeem:[underlying] = liquidity:[USD / 18 decimals ] / (price(outbound_tkn):[USD.underlying^-1 / 18 decimals] * collateralFactor(outbound_tkn): [0-1] 18 decimals)\n    (heap.mErr, heap.maxRedeemable) = divScalarByExpTruncate(\n      heap.liquidity,\n      mul_(\n        Exp({mantissa: heap.collateralFactorMantissa}),\n        Exp({mantissa: heap.priceMantissa})\n      )\n    );\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n    heap.maxRedeemable = min(heap.maxRedeemable, heap.balanceOfUnderlying);\n    // B|R = B - R*CF\n    return (\n      heap.maxRedeemable,\n      sub_(\n        heap.underlyingLiquidity, //borrow power\n        mul_ScalarTruncate(\n          Exp({mantissa: heap.collateralFactorMantissa}),\n          heap.maxRedeemable\n        )\n      )\n    );\n  }\n\n  function compoundRedeem(uint amountToRedeem, ML.SingleOrder calldata order)\n    internal\n    returns (uint)\n  {\n    IcERC20 outbound_cTkn = overlyings[IEIP20(order.outbound_tkn)]; // this is 0x0 if outbound_tkn is not compound sourced.\n    if (address(outbound_cTkn) == address(0)) {\n      return amountToRedeem;\n    }\n    uint errorCode = outbound_cTkn.redeemUnderlying(amountToRedeem); // accrues interests\n    if (errorCode == 0) {\n      //compound redeem was a success\n      // if ETH was redeemed, one needs to convert them into wETH\n      if (isCeth(outbound_cTkn)) {\n        weth.deposit{value: amountToRedeem}();\n      }\n      return 0;\n    } else {\n      //compound redeem failed\n      emit ErrorOnRedeem(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amountToRedeem,\n        errorCode\n      );\n      return amountToRedeem;\n    }\n  }\n\n  function _mint(uint amount, IcERC20 ctoken) internal returns (uint errCode) {\n    if (isCeth(ctoken)) {\n      // turning `amount` of wETH into ETH\n      try weth.withdraw(amount) {\n        // minting amount of ETH into cETH\n        ctoken.mint{value: amount}();\n      } catch {\n        if (amount == weth.balanceOf(address(this))) {}\n        require(false);\n      }\n    } else {\n      // Approve transfer on the ERC20 contract (not needed if cERC20 is already approved for `this`)\n      // IEIP20(ctoken.underlying()).approve(ctoken, amount);\n      errCode = ctoken.mint(amount); // accrues interest\n    }\n  }\n\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\n  // utility to supply erc20 to compound\n  function compoundMint(uint amount, ML.SingleOrder calldata order)\n    internal\n    returns (uint missing)\n  {\n    IcERC20 ctoken = overlyings[IEIP20(order.inbound_tkn)];\n    uint errCode = _mint(amount, ctoken);\n    // Mint ctokens\n    if (errCode != 0) {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        errCode\n      );\n      missing = amount;\n    }\n  }\n}\n"
    },
    "contracts/Strategies/interfaces/compound/ICompound.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// ICompound.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../IEIP20.sol\";\n\ninterface ICompoundPriceOracle {\n  function getUnderlyingPrice(IcERC20 cToken) external view returns (uint);\n}\n\ninterface IComptroller {\n  // adding usefull public getters\n  function oracle() external returns (ICompoundPriceOracle priceFeed);\n\n  function markets(address cToken)\n    external\n    view\n    returns (\n      bool isListed,\n      uint collateralFactorMantissa,\n      bool isComped\n    );\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens)\n    external\n    returns (uint[] memory);\n\n  function exitMarket(address cToken) external returns (uint);\n\n  function getAccountLiquidity(address user)\n    external\n    view\n    returns (\n      uint errorCode,\n      uint liquidity,\n      uint shortfall\n    );\n\n  function claimComp(address holder) external;\n\n  function checkMembership(address account, IcERC20 cToken)\n    external\n    view\n    returns (bool);\n}\n\ninterface IcERC20 is IEIP20 {\n  // from https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol\n  function redeem(uint redeemTokens) external returns (uint);\n\n  function borrow(uint borrowAmount) external returns (uint);\n\n  // for non cETH only\n  function repayBorrow(uint repayAmount) external returns (uint);\n\n  // for cETH only\n  function repayBorrow() external payable;\n\n  // for non cETH only\n  function repayBorrowBehalf(address borrower, uint repayAmount)\n    external\n    returns (uint);\n\n  // for cETH only\n  function repayBorrowBehalf(address borrower) external payable;\n\n  function balanceOfUnderlying(address owner) external returns (uint);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    );\n\n  function borrowRatePerBlock() external view returns (uint);\n\n  function supplyRatePerBlock() external view returns (uint);\n\n  function totalBorrowsCurrent() external returns (uint);\n\n  function borrowBalanceCurrent(address account) external returns (uint);\n\n  function borrowBalanceStored(address account) external view returns (uint);\n\n  function exchangeRateCurrent() external returns (uint);\n\n  function exchangeRateStored() external view returns (uint);\n\n  function getCash() external view returns (uint);\n\n  function accrueInterest() external returns (uint);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) external returns (uint);\n\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n  function mint(uint mintAmount) external returns (uint);\n\n  // only in cETH\n  function mint() external payable;\n\n  // non cETH only\n  function underlying() external view returns (address); // access to public variable containing the address of the underlying ERC20\n\n  function isCToken() external view returns (bool); // public constant froim CTokenInterfaces.sol\n}\n"
    },
    "contracts/Strategies/lib/Exponential.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n  /**\n   * @dev Creates an exponential from numerator and denominator values.\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n   *            or if `denom` is zero.\n   */\n  function getExp(uint num, uint denom)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: rational}));\n  }\n\n  /**\n   * @dev Adds two exponentials, returning a new exponential.\n   */\n  function addExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({mantissa: result}));\n  }\n\n  /**\n   * @dev Subtracts two exponentials, returning a new exponential.\n   */\n  function subExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({mantissa: result}));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\n   */\n  function mulScalar(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mulScalarTruncate(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (MathError, uint)\n  {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(product));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mulScalarTruncateAddUInt(\n    Exp memory a,\n    uint scalar,\n    uint addend\n  ) internal pure returns (MathError, uint) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return addUInt(truncate(product), addend);\n  }\n\n  /**\n   * @dev Divide an Exp by a scalar, returning a new Exp.\n   */\n  function divScalar(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, returning a new Exp.\n   */\n  function divScalarByExp(uint scalar, Exp memory divisor)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n    (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n    return getExp(numerator, divisor.mantissa);\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n   */\n  function divScalarByExpTruncate(uint scalar, Exp memory divisor)\n    internal\n    pure\n    returns (MathError, uint)\n  {\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(fraction));\n  }\n\n  /**\n   * @dev Multiplies two exponentials, returning a new exponential.\n   */\n  function mulExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint doubleScaledProduct) = mulUInt(\n      a.mantissa,\n      b.mantissa\n    );\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    // We add half the scale before dividing so that we get rounding instead of truncation.\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n    (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(\n      halfExpScale,\n      doubleScaledProduct\n    );\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({mantissa: 0}));\n    }\n\n    (MathError err2, uint product) = divUInt(\n      doubleScaledProductWithHalfScale,\n      expScale\n    );\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n    assert(err2 == MathError.NO_ERROR);\n\n    return (MathError.NO_ERROR, Exp({mantissa: product}));\n  }\n\n  /**\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n   */\n  function mulExp(uint a, uint b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n  }\n\n  /**\n   * @dev Multiplies three exponentials, returning a new exponential.\n   */\n  function mulExp3(\n    Exp memory a,\n    Exp memory b,\n    Exp memory c\n  ) internal pure returns (MathError, Exp memory) {\n    (MathError err, Exp memory ab) = mulExp(a, b);\n    if (err != MathError.NO_ERROR) {\n      return (err, ab);\n    }\n    return mulExp(ab, c);\n  }\n\n  /**\n   * @dev Divides two exponentials, returning a new exponential.\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n   */\n  function divExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    return getExp(a.mantissa, b.mantissa);\n  }\n}\n"
    },
    "contracts/Strategies/lib/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n  /**\n   * @dev Possible error codes that we can return\n   */\n  enum MathError {\n    NO_ERROR,\n    DIVISION_BY_ZERO,\n    INTEGER_OVERFLOW,\n    INTEGER_UNDERFLOW\n  }\n\n  /**\n   * @dev Multiplies two numbers, returns an error on overflow.\n   */\n  function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    if (a == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    uint c = a * b;\n\n    if (c / a != b) {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    } else {\n      return (MathError.NO_ERROR, c);\n    }\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    if (b == 0) {\n      return (MathError.DIVISION_BY_ZERO, 0);\n    }\n\n    return (MathError.NO_ERROR, a / b);\n  }\n\n  /**\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    if (b <= a) {\n      return (MathError.NO_ERROR, a - b);\n    } else {\n      return (MathError.INTEGER_UNDERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev Adds two numbers, returns an error on overflow.\n   */\n  function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    uint c = a + b;\n\n    if (c >= a) {\n      return (MathError.NO_ERROR, c);\n    } else {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev add a and b and then subtract c\n   */\n  function addThenSubUInt(\n    uint a,\n    uint b,\n    uint c\n  ) internal pure returns (MathError, uint) {\n    (MathError err0, uint sum) = addUInt(a, b);\n\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, 0);\n    }\n\n    return subUInt(sum, c);\n  }\n\n  /**\n   * @dev min and max functions\n   */\n  function min(uint a, uint b) internal pure returns (uint) {\n    return (a < b ? a : b);\n  }\n\n  function max(uint a, uint b) internal pure returns (uint) {\n    return (a > b ? a : b);\n  }\n\n  uint constant MAXUINT = type(uint).max;\n  uint constant MAXUINT96 = type(uint96).max;\n  uint constant MAXUINT24 = type(uint24).max;\n}\n"
    },
    "contracts/Strategies/lib/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint constant expScale = 1e18;\n  uint constant doubleScale = 1e36;\n  uint constant halfExpScale = expScale / 2;\n  uint constant mantissaOne = expScale;\n\n  struct Exp {\n    uint mantissa;\n  }\n\n  struct Double {\n    uint mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (uint)\n  {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint scalar,\n    uint addend\n  ) internal pure returns (uint) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right)\n    internal\n    pure\n    returns (bool)\n  {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right)\n    internal\n    pure\n    returns (bool)\n  {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right)\n    internal\n    pure\n    returns (bool)\n  {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint n, string memory errorMessage)\n    internal\n    pure\n    returns (uint224)\n  {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint n, string memory errorMessage)\n    internal\n    pure\n    returns (uint32)\n  {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(uint a, uint b) internal pure returns (uint) {\n    return add_(a, b, \"addition overflow\");\n  }\n\n  function add_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(uint a, uint b) internal pure returns (uint) {\n    return sub_(a, b, \"subtraction underflow\");\n  }\n\n  function sub_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n  }\n\n  function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Exp memory b) internal pure returns (uint) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n  }\n\n  function mul_(Double memory a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Double memory b) internal pure returns (uint) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint a, uint b) internal pure returns (uint) {\n    return mul_(a, b, \"multiplication overflow\");\n  }\n\n  function mul_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n  }\n\n  function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Exp memory b) internal pure returns (uint) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n  }\n\n  function div_(Double memory a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Double memory b) internal pure returns (uint) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint a, uint b) internal pure returns (uint) {\n    return div_(a, b, \"divide by zero\");\n  }\n\n  function div_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/CashManagement/SimpleCompoundRetail.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../CompoundLender.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract SimpleCompoundRetail is CompoundLender {\n  constructor(\n    address _unitroller,\n    address payable _MGV,\n    address wethAddress\n  ) CompoundModule(_unitroller, wethAddress) MangroveOffer(_MGV) {\n    setGasreq(1_000_000);\n  }\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Compound.\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = SingleUser.__get__(amount, order);\n    if (missing > 0) {\n      return super.__get__(missing, order);\n    }\n    return 0;\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/CompoundTrader.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// CompoundTrader.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./CompoundLender.sol\";\n\nabstract contract CompoundTrader is CompoundLender {\n  event ErrorOnBorrow(address cToken, uint amount, uint errorCode);\n  event ErrorOnRepay(address cToken, uint amount, uint errorCode);\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    if (!isPooled(IEIP20(order.outbound_tkn))) {\n      return amount;\n    }\n    IcERC20 outbound_cTkn = overlyings[IEIP20(order.outbound_tkn)]; // this is 0x0 if outbound_tkn is not compound sourced for borrow.\n\n    if (address(outbound_cTkn) == address(0)) {\n      return amount;\n    }\n\n    // 1. Computing total borrow and redeem capacities of underlying asset\n    (uint redeemable, uint liquidity_after_redeem) = maxGettableUnderlying(\n      address(outbound_cTkn),\n      address(this)\n    );\n\n    // give up if amount is not gettable\n    if (add_(redeemable, liquidity_after_redeem) < amount) {\n      return amount;\n    }\n\n    // 2. trying to redeem liquidity from Compound\n    uint toRedeem = min(redeemable, amount);\n\n    uint notRedeemed = compoundRedeem(toRedeem, order);\n    if (notRedeemed > 0 && toRedeem > 0) {\n      // => notRedeemed == toRedeem\n      // this should not happen unless compound is out of cash, thus no need to try to borrow\n      // log already emitted by `compoundRedeem`\n      return amount;\n    }\n    amount = sub_(amount, toRedeem);\n    uint toBorrow = min(liquidity_after_redeem, amount);\n    if (toBorrow == 0) {\n      return amount;\n    }\n    // 3. trying to borrow missing liquidity\n    uint errorCode = outbound_cTkn.borrow(toBorrow);\n    if (errorCode != 0) {\n      emit ErrorOnBorrow(address(outbound_cTkn), toBorrow, errorCode);\n      return amount; // unable to borrow requested amount\n    }\n    // if ETH were borrowed, one needs to turn them into wETH\n    if (isCeth(outbound_cTkn)) {\n      weth.deposit{value: toBorrow}();\n    }\n    return sub_(amount, toBorrow);\n  }\n\n  /// @notice contract need to have approved `inbound_tkn` overlying in order to repay borrow\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (!isPooled(IEIP20(order.inbound_tkn))) {\n      return amount;\n    }\n    // NB: overlyings[wETH] = cETH\n    IcERC20 inbound_cTkn = overlyings[IEIP20(order.inbound_tkn)];\n    if (address(inbound_cTkn) == address(0)) {\n      return amount;\n    }\n    // trying to repay debt if user is in borrow position for inbound_tkn token\n    uint toRepay = min(\n      inbound_cTkn.borrowBalanceCurrent(address(this)),\n      amount\n    ); //accrues interests\n\n    uint errCode;\n    if (isCeth(inbound_cTkn)) {\n      // turning WETHs to ETHs\n      weth.withdraw(toRepay);\n      // OK since repayBorrow throws if failing in the case of Eth\n      inbound_cTkn.repayBorrow{value: toRepay}();\n    } else {\n      errCode = inbound_cTkn.repayBorrow(toRepay);\n    }\n    uint toMint;\n    if (errCode != 0) {\n      emit ErrorOnRepay(address(inbound_cTkn), toRepay, errCode);\n      toMint = amount;\n    } else {\n      toMint = amount - toRepay;\n    }\n    return compoundMint(toMint, order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/MarketMaking/SwingingMarketMaker.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SwingingMarketMaker.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../CompoundTrader.sol\";\n\ncontract SwingingMarketMaker is CompoundTrader {\n  using P.Offer for P.Offer.t;\n  event MissingPriceConverter(address token0, address token1);\n  event NotEnoughProvision(uint amount);\n\n  // price[B][A] : price of A in B = p(B|A) = volume of B obtained/volume of A given\n  mapping(address => mapping(address => uint)) private price; // price[tk0][tk1] is in tk0 precision\n  mapping(address => mapping(address => uint)) private offers;\n\n  constructor(\n    address _unitroller,\n    address payable _MGV,\n    address wethAddress\n  ) CompoundModule(_unitroller, wethAddress) MangroveOffer(_MGV) {\n    setGasreq(1_000_000);\n  }\n\n  // sets P(tk0|tk1)\n  // one wants P(tk0|tk1).P(tk1|tk0) >= 1\n  function setPrice(\n    address tk0,\n    address tk1,\n    uint p\n  ) external onlyAdmin {\n    price[tk0][tk1] = p; // has tk0.decimals() decimals\n  }\n\n  function startStrat(\n    address tk0,\n    address tk1,\n    uint gives // amount of tk0 (with tk0.decimals() decimals)\n  ) external payable onlyAdmin {\n    MGV.fund{value: msg.value}();\n    require(repostOffer(tk0, tk1, gives), \"Could not start strategy\");\n    IEIP20(tk0).approve(address(MGV), type(uint).max); // approving MGV for tk0 transfer\n    IEIP20(tk1).approve(address(MGV), type(uint).max); // approving MGV for tk1 transfer\n  }\n\n  // at this stage contract has `received` amount in token0\n  function repostOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gives // in outbound_tkn\n  ) internal returns (bool) {\n    // computing how much inbound_tkn one should ask for `gives` amount of outbound tokens\n    // NB p_10 has inbound_tkn.decimals() number of decimals\n    uint p_10 = price[inbound_tkn][outbound_tkn];\n    if (p_10 == 0) {\n      // ! p_10 has the decimals of inbound_tkn\n      emit MissingPriceConverter(inbound_tkn, outbound_tkn);\n      return false;\n    }\n    uint wants = div_(\n      mul_(p_10, gives), // p(base|quote).(gives:quote) : base\n      10**(IEIP20(outbound_tkn).decimals())\n    ); // in base units\n    uint offerId = offers[outbound_tkn][inbound_tkn];\n    if (offerId == 0) {\n      try\n        MGV.newOffer(outbound_tkn, inbound_tkn, wants, gives, OFR_GASREQ, 0, 0)\n      returns (uint id) {\n        if (id > 0) {\n          offers[outbound_tkn][inbound_tkn] = id;\n          return true;\n        } else {\n          return false;\n        }\n      } catch {\n        return false;\n      }\n    } else {\n      try\n        MGV.updateOffer(\n          outbound_tkn,\n          inbound_tkn,\n          wants,\n          gives,\n          // offerId is already on the book so a good pivot\n          OFR_GASREQ, // default value\n          0, // default value\n          offerId,\n          offerId\n        )\n      {\n        return true;\n      } catch Error(string memory message) {\n        emit PosthookFail(outbound_tkn, inbound_tkn, offerId, message);\n        return false;\n      }\n    }\n  }\n\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    override\n  {\n    address token0 = order.outbound_tkn;\n    address token1 = order.inbound_tkn;\n    uint offer_received = order.offer.wants(); // amount with token1.decimals() decimals\n    repostOffer({\n      outbound_tkn: token1,\n      inbound_tkn: token0,\n      gives: offer_received\n    });\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    // checks whether `this` contract has enough `base` token\n    uint missingGet = SingleUser.__get__(amount, order);\n    // if not tries to fetch missing liquidity on compound using `CompoundTrader`'s strat\n    return super.__get__(missingGet, order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/CashManagement/AdvancedCompoundRetail.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../CompoundTrader.sol\";\n\ncontract AdvancedCompoundRetail is CompoundTrader {\n  constructor(\n    address _unitroller,\n    address payable _MGV,\n    address wethAddress\n  ) CompoundModule(_unitroller, wethAddress) MangroveOffer(_MGV) {\n    setGasreq(1_000_000);\n  }\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Compound.\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = SingleUser.__get__(amount, order);\n    if (missing > 0) {\n      return super.__get__(missing, order);\n    }\n    return 0;\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/AaveModule.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../interfaces/aave/V2/ILendingPool.sol\";\nimport \"../interfaces/aave/V2/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/aave/V2/IPriceOracleGetter.sol\";\nimport \"../lib/Exponential.sol\";\nimport \"../interfaces/IMangrove.sol\";\nimport \"../interfaces/IEIP20.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract AaveModule is Exponential {\n  event ErrorOnRedeem(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n  event ErrorOnMint(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n\n  // address of the lendingPool\n  ILendingPool public immutable lendingPool;\n  IPriceOracleGetter public immutable priceOracle;\n  uint16 referralCode;\n\n  constructor(address _addressesProvider, uint _referralCode) {\n    require(\n      uint16(_referralCode) == _referralCode,\n      \"Referral code should be uint16\"\n    );\n    referralCode = uint16(referralCode); // for aave reference, put 0 for tests\n    address _lendingPool = ILendingPoolAddressesProvider(_addressesProvider)\n      .getLendingPool();\n    address _priceOracle = ILendingPoolAddressesProvider(_addressesProvider)\n      .getPriceOracle();\n    require(_lendingPool != address(0), \"Invalid lendingPool address\");\n    require(_priceOracle != address(0), \"Invalid priceOracle address\");\n    lendingPool = ILendingPool(_lendingPool);\n    priceOracle = IPriceOracleGetter(_priceOracle);\n  }\n\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  ///@notice approval of overlying contract by the underlying is necessary for minting and repaying borrow\n  ///@notice user must use this function to do so.\n  function approveLender(address token, uint amount) public {\n    IEIP20(token).approve(address(lendingPool), amount);\n  }\n\n  ///@notice exits markets\n  function _exitMarket(IEIP20 underlying) internal {\n    lendingPool.setUserUseReserveAsCollateral(address(underlying), false);\n  }\n\n  function _enterMarkets(IEIP20[] calldata underlyings) internal {\n    for (uint i = 0; i < underlyings.length; i++) {\n      lendingPool.setUserUseReserveAsCollateral(address(underlyings[i]), true);\n    }\n  }\n\n  function overlying(IEIP20 asset) public view returns (IEIP20 aToken) {\n    aToken = IEIP20(lendingPool.getReserveData(address(asset)).aTokenAddress);\n  }\n\n  // structs to avoir stack too deep in maxGettableUnderlying\n  struct Underlying {\n    uint ltv;\n    uint liquidationThreshold;\n    uint decimals;\n    uint price;\n  }\n\n  struct Account {\n    uint collateral;\n    uint debt;\n    uint borrowPower;\n    uint redeemPower;\n    uint ltv;\n    uint liquidationThreshold;\n    uint health;\n    uint balanceOfUnderlying;\n  }\n\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\n  /// returns (R, B|R)\n\n  function maxGettableUnderlying(\n    address asset,\n    bool tryBorrow,\n    address onBehalf\n  ) public view returns (uint, uint) {\n    Underlying memory underlying; // asset parameters\n    Account memory account; // accound parameters\n    (\n      account.collateral,\n      account.debt,\n      account.borrowPower, // avgLtv * sumCollateralEth - sumDebtEth\n      account.liquidationThreshold,\n      account.ltv,\n      account.health // avgLiquidityThreshold * sumCollateralEth / sumDebtEth  -- should be less than 10**18\n    ) = lendingPool.getUserAccountData(onBehalf);\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      asset\n    );\n    (\n      underlying.ltv, // collateral factor for lending\n      underlying.liquidationThreshold, // collateral factor for borrowing\n      ,\n      /*liquidationBonus*/\n      underlying.decimals,\n      /*reserveFactor*/\n\n    ) = DataTypes.getParams(reserveData.configuration);\n    account.balanceOfUnderlying = IEIP20(reserveData.aTokenAddress).balanceOf(\n      onBehalf\n    );\n\n    underlying.price = priceOracle.getAssetPrice(asset); // divided by 10**underlying.decimals\n\n    // account.redeemPower = account.liquidationThreshold * account.collateral - account.debt\n    account.redeemPower = sub_(\n      div_(mul_(account.liquidationThreshold, account.collateral), 10**4),\n      account.debt\n    );\n    // max redeem capacity = account.redeemPower/ underlying.liquidationThreshold * underlying.price\n    // unless account doesn't have enough collateral in asset token (hence the min())\n\n    uint maxRedeemableUnderlying = div_( // in 10**underlying.decimals\n      account.redeemPower * 10**(underlying.decimals) * 10**4,\n      mul_(underlying.liquidationThreshold, underlying.price)\n    );\n\n    maxRedeemableUnderlying = min(\n      maxRedeemableUnderlying,\n      account.balanceOfUnderlying\n    );\n\n    if (!tryBorrow) {\n      //gas saver\n      return (maxRedeemableUnderlying, 0);\n    }\n    // computing max borrow capacity on the premisses that maxRedeemableUnderlying has been redeemed.\n    // max borrow capacity = (account.borrowPower - (ltv*redeemed)) / underlying.ltv * underlying.price\n\n    uint borrowPowerImpactOfRedeemInUnderlying = div_(\n      mul_(maxRedeemableUnderlying, underlying.ltv),\n      10**4\n    );\n    uint borrowPowerInUnderlying = div_(\n      mul_(account.borrowPower, 10**underlying.decimals),\n      underlying.price\n    );\n\n    if (borrowPowerImpactOfRedeemInUnderlying > borrowPowerInUnderlying) {\n      // no more borrowPower left after max redeem operation\n      return (maxRedeemableUnderlying, 0);\n    }\n\n    uint maxBorrowAfterRedeemInUnderlying = sub_( // max borrow power in underlying after max redeem has been withdrawn\n      borrowPowerInUnderlying,\n      borrowPowerImpactOfRedeemInUnderlying\n    );\n    return (maxRedeemableUnderlying, maxBorrowAfterRedeemInUnderlying);\n  }\n\n  function aaveRedeem(\n    uint amountToRedeem,\n    address onBehalf,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    try\n      lendingPool.withdraw(order.outbound_tkn, amountToRedeem, onBehalf)\n    returns (uint withdrawn) {\n      //aave redeem was a success\n      if (amountToRedeem == withdrawn) {\n        return 0;\n      } else {\n        return (amountToRedeem - withdrawn);\n      }\n    } catch Error(string memory message) {\n      emit ErrorOnRedeem(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amountToRedeem,\n        message\n      );\n      return amountToRedeem;\n    }\n  }\n\n  function _mint(\n    uint amount,\n    address token,\n    address onBehalf\n  ) internal {\n    lendingPool.deposit(token, amount, onBehalf, referralCode);\n  }\n\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\n  // utility to supply erc20 to compound\n  // NB `ctoken` contract MUST be approved to perform `transferFrom token` by `this` contract.\n  /// @notice user need to approve ctoken in order to mint\n  function aaveMint(\n    uint amount,\n    address onBehalf,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    // contract must haveallowance()to spend funds on behalf ofmsg.sender for at-leastamount for the asset being deposited. This can be done via the standard ERC20 approve() method.\n    try lendingPool.deposit(order.inbound_tkn, amount, onBehalf, referralCode) {\n      return 0;\n    } catch Error(string memory message) {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        message\n      );\n    } catch {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        \"unexpected\"\n      );\n    }\n    return amount;\n  }\n}\n"
    },
    "contracts/Strategies/interfaces/aave/V2/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\npragma solidity >=0.6.12;\npragma abicoder v2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../../../lib/aave/V2/DataTypes.sol\";\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(\n    address indexed reserve,\n    address indexed user,\n    address indexed to,\n    uint amount\n  );\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint borrowRateMode,\n    uint borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint amount,\n    uint premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint debtToCover,\n    uint liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint liquidityRate,\n    uint stableBorrowRate,\n    uint variableBorrowRate,\n    uint liquidityIndex,\n    uint variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint amount,\n    address to\n  ) external returns (uint);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint amount,\n    uint rateMode,\n    address onBehalfOf\n  ) external returns (uint);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n    external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint[] calldata amounts,\n    uint[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint totalCollateralETH,\n      uint totalDebtETH,\n      uint availableBorrowsETH,\n      uint currentLiquidationThreshold,\n      uint ltv,\n      uint healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(\n    address reserve,\n    address rateStrategyAddress\n  ) external;\n\n  function setConfiguration(address reserve, uint configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    view\n    returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint amount,\n    uint balanceFromAfter,\n    uint balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider()\n    external\n    view\n    returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "contracts/Strategies/interfaces/aave/V2/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\npragma solidity >=0.6.12;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/Strategies/interfaces/aave/V2/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\npragma solidity >=0.6.12;\n\n/**\n * @title IPriceOracleGetter interface\n * @notice Interface for the Aave price oracle.\n **/\n\ninterface IPriceOracleGetter {\n  /**\n   * @dev returns the asset price in ETH\n   * @param asset the address of the asset\n   * @return the ETH price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint);\n}\n"
    },
    "contracts/Strategies/lib/aave/V2/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\n//for more details\npragma solidity >=0.6.12;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint data;\n  }\n\n  struct UserConfigurationMap {\n    uint data;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n\n  function getParams(ReserveConfigurationMap memory configMap)\n    internal\n    pure\n    returns (\n      uint,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    uint dataLocal = configMap.data;\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\n        LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\n        LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n    );\n  }\n\n  function isUsingAsCollateral(\n    DataTypes.UserConfigurationMap memory configMap,\n    uint reserveIndex\n  ) internal pure returns (bool) {\n    require(reserveIndex < 128, \"Invalid index\");\n    return (configMap.data >> (reserveIndex * 2 + 1)) & 1 != 0;\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/AaveLender.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./SingleUser.sol\";\nimport \"../AaveModule.sol\";\n\nabstract contract AaveLender is SingleUser, AaveModule {\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  ///@notice exits markets\n  function exitMarket(IEIP20 underlying) external onlyAdmin {\n    _exitMarket(underlying);\n  }\n\n  function enterMarkets(IEIP20[] calldata underlyings) external onlyAdmin {\n    _enterMarkets(underlyings);\n  }\n\n  function mint(\n    uint amount,\n    address token,\n    address onBehalf\n  ) external onlyAdmin {\n    _mint(amount, token, onBehalf);\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    (\n      uint redeemable, /*maxBorrowAfterRedeem*/\n\n    ) = maxGettableUnderlying(order.outbound_tkn, false, address(this));\n    if (amount > redeemable) {\n      return amount; // give up if amount is not redeemable (anti flashloan manipulation of AAVE)\n    }\n\n    if (aaveRedeem(amount, address(this), order) == 0) {\n      // amount was transfered to `this`\n      return 0;\n    }\n    return amount;\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    return aaveMint(amount, address(this), order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/AaveTrader.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AaveTrader.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./AaveLender.sol\";\n\nabstract contract AaveTrader is AaveLender {\n  uint public immutable interestRateMode;\n\n  constructor(uint _interestRateMode) {\n    interestRateMode = _interestRateMode;\n  }\n\n  event ErrorOnBorrow(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n  event ErrorOnRepay(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    // 1. Computing total borrow and redeem capacities of underlying asset\n    (uint redeemable, uint liquidity_after_redeem) = maxGettableUnderlying(\n      order.outbound_tkn,\n      true,\n      address(this)\n    );\n\n    if (add_(redeemable, liquidity_after_redeem) < amount) {\n      return amount; // give up early if not possible to fetch amount of underlying\n    }\n    // 2. trying to redeem liquidity from Compound\n    uint toRedeem = min(redeemable, amount);\n\n    uint notRedeemed = aaveRedeem(toRedeem, address(this), order);\n    if (notRedeemed > 0 && toRedeem > 0) {\n      // => notRedeemed == toRedeem\n      // this should not happen unless compound is out of cash, thus no need to try to borrow\n      // log already emitted by `compoundRedeem`\n      return amount;\n    }\n    amount = sub_(amount, toRedeem);\n    uint toBorrow = min(liquidity_after_redeem, amount);\n    if (toBorrow == 0) {\n      return amount;\n    }\n    // 3. trying to borrow missing liquidity\n    try\n      lendingPool.borrow(\n        order.outbound_tkn,\n        toBorrow,\n        interestRateMode,\n        referralCode,\n        address(this)\n      )\n    {\n      return sub_(amount, toBorrow);\n    } catch Error(string memory message) {\n      emit ErrorOnBorrow(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        toBorrow,\n        message\n      );\n      return amount;\n    }\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    // trying to repay debt if user is in borrow position for inbound_tkn token\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      order.inbound_tkn\n    );\n\n    uint debtOfUnderlying;\n    if (interestRateMode == 1) {\n      debtOfUnderlying = IEIP20(reserveData.stableDebtTokenAddress).balanceOf(\n        address(this)\n      );\n    } else {\n      debtOfUnderlying = IEIP20(reserveData.variableDebtTokenAddress).balanceOf(\n          address(this)\n        );\n    }\n\n    uint toRepay = min(debtOfUnderlying, amount);\n\n    uint toMint;\n    try\n      lendingPool.repay(\n        order.inbound_tkn,\n        toRepay,\n        interestRateMode,\n        address(this)\n      )\n    {\n      toMint = sub_(amount, toRepay);\n    } catch Error(string memory message) {\n      emit ErrorOnRepay(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        toRepay,\n        message\n      );\n      toMint = amount;\n    }\n    return aaveMint(toMint, address(this), order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/AaveLender.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./MultiUser.sol\";\nimport \"../AaveModule.sol\";\n\nabstract contract MultiUserAaveLender is MultiUser, AaveModule {\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  // tokens are fetched on Aave (on behalf of offer owner)\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    (\n      uint redeemable, /*maxBorrowAfterRedeem*/\n\n    ) = maxGettableUnderlying(order.outbound_tkn, false, owner);\n    if (amount > redeemable) {\n      return amount; // give up if amount is not redeemable (anti flashloan manipulation of AAVE)\n    }\n    // need to retreive overlyings from msg.sender (we suppose `this` is approved for that)\n    IEIP20 aToken = overlying(IEIP20(order.outbound_tkn));\n    try aToken.transferFrom(owner, address(this), amount) returns (\n      bool success\n    ) {\n      if (success) {\n        // amount overlying was transfered from `owner`'s wallet\n        // anything wrong beyond this point should revert\n        // trying to redeem from AAVE\n        require(aaveRedeem(amount, address(this), order) == 0); // throwing to cancel overlying transfer\n        return 0;\n      }\n    } catch {\n      // nothing to be done\n    }\n    emit LogIncident(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId,\n      \"aaveLender/overlyingTransferFail\"\n    );\n    return amount; // nothing was fetched\n  }\n\n  // received inbound token are put on Aave on behalf of offer owner\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    // minted Atokens are sent to owner\n    return aaveMint(amount, owner, order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/AaveTrader.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AaveTrader.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./AaveLender.sol\";\n\nabstract contract MultiUserAaveTrader is MultiUser, AaveModule {\n  uint public immutable interestRateMode;\n\n  constructor(uint _interestRateMode) {\n    interestRateMode = _interestRateMode;\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    // 1. Computing total borrow and redeem capacities of underlying asset\n    (uint redeemable, uint liquidity_after_redeem) = maxGettableUnderlying(\n      order.outbound_tkn,\n      true,\n      owner\n    );\n    // Fail early to prevent AAVE manipulation by flashloans\n    if (redeemable + liquidity_after_redeem < amount) {\n      return amount;\n    }\n    // 2. trying to redeem liquidity from AAVE\n    uint toRedeem = min(redeemable, amount);\n    if (toRedeem == 0) {\n      return amount;\n    }\n    IEIP20 aToken = overlying(IEIP20(order.outbound_tkn));\n    try aToken.transferFrom(owner, address(this), amount) returns (\n      bool success\n    ) {\n      if (!success) {\n        // notRedeemed > 0 should not happen unless lender is out of cash, thus no need to try to borrow\n        // log already emitted by `aaveRedeem`\n        emit LogIncident(\n          order.outbound_tkn,\n          order.inbound_tkn,\n          order.offerId,\n          \"Multi/aaveTrader/aTkn/TransferFail\"\n        );\n        return amount;\n      }\n      // overlying transfer has succeeded, anything wrong beyond this point should revert\n      require(aaveRedeem(toRedeem, address(this), order) == 0); // throwing to cancel transfer of overlying\n      amount = amount - toRedeem;\n      if (amount == 0) {\n        return 0;\n      }\n      uint toBorrow = min(liquidity_after_redeem, amount);\n      // 3. trying to borrow missing liquidity, failure to borrow will revert\n      // not encapsulating this external call to make sure aToken transfer is also reverted\n      lendingPool.borrow(\n        order.outbound_tkn,\n        toBorrow,\n        interestRateMode,\n        referralCode,\n        address(this)\n      );\n      // if this point is reached, borrow has succeeded.\n      return 0;\n    } catch {\n      // overlying transfer reverted.\n      emit LogIncident(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        \"Multi/AaveTrader/aTkn/transferRevert\"\n      );\n      return amount;\n    }\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    // trying to repay debt if user is in borrow position for inbound_tkn token\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      order.inbound_tkn\n    );\n\n    uint debtOfUnderlying;\n    if (interestRateMode == 1) {\n      debtOfUnderlying = IEIP20(reserveData.stableDebtTokenAddress).balanceOf(\n        address(this)\n      );\n    } else {\n      debtOfUnderlying = IEIP20(reserveData.variableDebtTokenAddress).balanceOf(\n          address(this)\n        );\n    }\n\n    uint toRepay = min(debtOfUnderlying, amount);\n\n    uint toMint;\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    try lendingPool.repay(order.inbound_tkn, toRepay, interestRateMode, owner) {\n      toMint = sub_(amount, toRepay);\n    } catch (bytes memory message) {\n      emit LogIncident(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        message\n      );\n      toMint = amount;\n    }\n    return aaveMint(toMint, owner, order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/CashManagement/SimpleAaveRetail.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../AaveV3Lender.sol\";\n\ncontract SimpleAaveRetail is AaveV3Lender {\n  constructor(address _addressesProvider, address payable _MGV)\n    AaveV3Module(_addressesProvider, 0)\n    MangroveOffer(_MGV)\n  {\n    setGasreq(1_000_000);\n  }\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Aave.\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = SingleUser.__get__(amount, order);\n    if (missing > 0) {\n      return super.__get__(missing, order);\n    }\n    return 0;\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/AaveV3Trader.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AaveTrader.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./AaveV3Lender.sol\";\n\nabstract contract AaveV3Trader is AaveV3Lender {\n  uint public immutable interestRateMode;\n\n  constructor(uint _interestRateMode) {\n    interestRateMode = _interestRateMode;\n  }\n\n  event ErrorOnBorrow(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n  event ErrorOnRepay(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    // 1. Computing total borrow and redeem capacities of underlying asset\n    (uint redeemable, uint liquidity_after_redeem) = maxGettableUnderlying(\n      order.outbound_tkn,\n      true,\n      address(this)\n    );\n\n    if (redeemable + liquidity_after_redeem < amount) {\n      return amount; // give up early if not possible to fetch amount of underlying\n    }\n    // 2. trying to redeem liquidity from Compound\n    uint toRedeem = redeemable < amount ? redeemable : amount;\n\n    uint notRedeemed = aaveRedeem(toRedeem, address(this), order);\n    if (notRedeemed > 0 && toRedeem > 0) {\n      // => notRedeemed == toRedeem\n      // this should not happen unless compound is out of cash, thus no need to try to borrow\n      // log already emitted by `compoundRedeem`\n      return amount;\n    }\n    amount = amount - toRedeem;\n    uint toBorrow = liquidity_after_redeem < amount\n      ? liquidity_after_redeem\n      : amount;\n    if (toBorrow == 0) {\n      return amount;\n    }\n    // 3. trying to borrow missing liquidity\n    try\n      lendingPool.borrow(\n        order.outbound_tkn,\n        toBorrow,\n        interestRateMode,\n        referralCode,\n        address(this)\n      )\n    {\n      return amount - toBorrow;\n    } catch Error(string memory message) {\n      emit ErrorOnBorrow(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        toBorrow,\n        message\n      );\n      return amount;\n    }\n  }\n\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    //optim\n    if (amount == 0) {\n      return 0;\n    }\n    // trying to repay debt if user is in borrow position for inbound_tkn token\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      order.inbound_tkn\n    );\n\n    uint debtOfUnderlying;\n    if (interestRateMode == 1) {\n      debtOfUnderlying = IEIP20(reserveData.stableDebtTokenAddress).balanceOf(\n        address(this)\n      );\n    } else {\n      debtOfUnderlying = IEIP20(reserveData.variableDebtTokenAddress).balanceOf(\n          address(this)\n        );\n    }\n\n    uint toRepay = debtOfUnderlying < amount ? debtOfUnderlying : amount;\n\n    uint toMint;\n    try\n      lendingPool.repay(\n        order.inbound_tkn,\n        toRepay,\n        interestRateMode,\n        address(this)\n      )\n    {\n      toMint = amount - toRepay;\n    } catch Error(string memory message) {\n      emit ErrorOnRepay(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        toRepay,\n        message\n      );\n      toMint = amount;\n    }\n    return aaveMint(toMint, address(this), order);\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/SingleUser/Deployable/CashManagement/AdvancedAaveRetail.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedAaveRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../AaveV3Trader.sol\";\n\ncontract AdvancedAaveRetail is AaveV3Trader(2) {\n  constructor(address addressesProvider, address payable _MGV)\n    AaveV3Module(addressesProvider, 0)\n    MangroveOffer(_MGV)\n  {\n    setGasreq(1_000_000);\n  }\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Aave.\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = SingleUser.__get__(amount, order);\n    if (missing > 0) {\n      return super.__get__(missing, order);\n    }\n    return 0;\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OasisLike.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../Persistent.sol\";\n\ncontract OasisLike is MultiUserPersistent {\n  constructor(address payable _MGV) MangroveOffer(_MGV) {}\n\n  // overrides MultiUser.__put__ in order to transfer all inbound tokens to owner\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    override\n    returns (uint missing)\n  {\n    // transfers the deposited tokens to owner\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    if (IEIP20(order.inbound_tkn).transfer(owner, amount)) {\n      return 0;\n    } else {\n      return amount;\n    }\n  }\n\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    override\n    returns (uint)\n  {\n    // tries to fetch missing amount into owner's wallet\n    address owner = ownerOf(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId\n    );\n    try\n      IEIP20(order.outbound_tkn).transferFrom(owner, address(this), amount)\n    returns (bool success) {\n      if (success) {\n        return 0;\n      } else {\n        return amount;\n      }\n    } catch {\n      return amount;\n    }\n  }\n}\n"
    },
    "contracts/Strategies/OfferLogics/MultiUsers/Deployable/MultiMaker.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../MultiUser.sol\";\n\ncontract MultiMaker is MultiUser {\n  constructor(address payable _MGV) MangroveOffer(_MGV) {}\n}\n"
    },
    "contracts/Tests/MgvCleaner_Test.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../periphery/MgvCleaner.sol\";\n\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\n// import \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract MgvCleaner_Test is HasMgvEvents {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMaker mkr;\n  address outbound;\n  address inbound;\n  MgvCleaner cleaner;\n\n  function a_beforeAll() public {\n    TestToken Outbound = TokenSetup.setup(\"A\", \"$A\");\n    TestToken Inbound = TokenSetup.setup(\"B\", \"$B\");\n    outbound = address(Outbound);\n    inbound = address(Inbound);\n    mgv = MgvSetup.setup(Outbound, Inbound);\n    mkr = MakerSetup.setup(mgv, outbound, inbound);\n    cleaner = new MgvCleaner(address(mgv));\n\n    payable(mkr).transfer(10 ether);\n\n    mkr.provisionMgv(5 ether);\n\n    Inbound.mint(address(this), 2 ether);\n    Outbound.mint(address(mkr), 1 ether);\n\n    Outbound.approve(address(mgv), 1 ether);\n    Inbound.approve(address(mgv), 1 ether);\n    mkr.approveMgv(Outbound, 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"MgvCleaner_Test\");\n    Display.register(outbound, \"$A\");\n    Display.register(inbound, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n    Display.register(address(cleaner), \"cleaner\");\n  }\n\n  /* # Test Config */\n\n  function single_failing_offer_test() public {\n    mgv.approve(outbound, inbound, address(cleaner), type(uint).max);\n\n    mkr.shouldFail(true);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n    cleaner.collect(outbound, inbound, targets, true);\n\n    uint newBal = address(this).balance;\n\n    TestEvents.more(newBal, oldBal, \"balance should have increased\");\n  }\n\n  function mult_failing_offer_test() public {\n    mgv.approve(outbound, inbound, address(cleaner), type(uint).max);\n\n    mkr.shouldFail(true);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint ofr2 = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](2);\n    targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n    targets[1] = [ofr2, 1 ether, 1 ether, type(uint).max];\n    cleaner.collect(outbound, inbound, targets, true);\n\n    uint newBal = address(this).balance;\n\n    TestEvents.more(newBal, oldBal, \"balance should have increased\");\n  }\n\n  function no_fail_no_cleaning_test() public {\n    mgv.approve(outbound, inbound, address(cleaner), type(uint).max);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n    try cleaner.collect(outbound, inbound, targets, true) {\n      TestEvents.fail(\"collect should fail since offer succeeded\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(\n        \"mgvCleaner/anOfferDidNotFail\",\n        reason,\n        \"fail should be due to offer execution succeeding\"\n      );\n    }\n\n    uint newBal = address(this).balance;\n\n    TestEvents.eq(newBal, oldBal, \"balance should be the same\");\n  }\n\n  // For now there is no need to approve\n  // function no_approve_no_cleaning_test() public {\n  //   uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000,0);\n\n  //   uint[4][] memory targets = new uint[4][](1);\n  //   targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n\n  //   try cleaner.collect(outbound, inbound,targets,true) {\n  //     TestEvents.fail(\"collect should fail since cleaner was not approved\");\n  //   } catch Error(string memory reason) {\n  //     TestEvents.eq(\"mgv/lowAllowance\",reason,\"Fail should be due to no allowance\");\n  //   }\n  // }\n}\n"
    },
    "contracts/periphery/MgvCleaner.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvCleaner.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, P} from \"../MgvLib.sol\";\n\ninterface MangroveLike {\n  function snipesFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint bounty\n    );\n\n  function offerInfo(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  ) external view returns (P.OfferStruct memory, P.OfferStruct memory);\n}\n\n/* The purpose of the Cleaner contract is to execute failing offers and collect\n * their associated bounty. It takes an array of offers with same definition as\n * `Mangrove.snipes` and expects them all to fail or not execute. */\n\n/* How to use:\n   1) Ensure *your* address approved Mangrove for the token you will provide to the offer (`inbound_tkn`).\n   2) Run `collect` on the offers that you detected were failing.\n\n   You can adjust takerWants/takerGives and gasreq as needed.\n\n   Note: in the current version you do not need to set MgvCleaner's allowance in Mangrove.\n   TODO: add `collectWith` with an additional `taker` argument.\n*/\ncontract MgvCleaner {\n  MangroveLike immutable MGV;\n\n  constructor(address _MGV) {\n    MGV = MangroveLike(_MGV);\n  }\n\n  receive() external payable {}\n\n  /* Returns the entire balance, not just the bounty collected */\n  function collect(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants\n  ) external returns (uint bal) { unchecked {\n    (uint successes, , , ) = MGV.snipesFor(\n      outbound_tkn,\n      inbound_tkn,\n      targets,\n      fillWants,\n      msg.sender\n    );\n    require(successes == 0, \"mgvCleaner/anOfferDidNotFail\");\n    bal = address(this).balance;\n    bool noRevert;\n    (noRevert, ) = msg.sender.call{value: bal}(\"\");\n  }}\n}\n"
    },
    "contracts/Tests/MakerOperations.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\ncontract MakerOperations_Test is IMaker, HasMgvEvents {\n  using P.Global for P.Global.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Offer for P.Offer.t;\n  using P.Local for P.Local.t;\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  TestMaker mkr2;\n  TestTaker tkr;\n  TestToken base;\n  TestToken quote;\n  address _base;\n  address _quote;\n\n  receive() external payable {}\n\n  function a_beforeAll() public {\n    base = TokenSetup.setup(\"A\", \"$A\");\n    _base = address(base);\n    quote = TokenSetup.setup(\"B\", \"$B\");\n    _quote = address(quote);\n\n    mgv = MgvSetup.setup(base, quote);\n    mkr = MakerSetup.setup(mgv, _base, _quote);\n    mkr2 = MakerSetup.setup(mgv, _base, _quote);\n    tkr = TakerSetup.setup(mgv, _base, _quote);\n\n    payable(mkr).transfer(10 ether);\n    mkr.approveMgv(base, 10 ether);\n    payable(mkr2).transfer(10 ether);\n    mkr2.approveMgv(base, 10 ether);\n\n    payable(tkr).transfer(10 ether);\n\n    quote.mint(address(tkr), 1 ether);\n    tkr.approveMgv(quote, 1 ether);\n\n    base.approve(address(mgv), 10 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"MakerOperations_Test\");\n    Display.register(_base, \"$A\");\n    Display.register(_quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker\");\n    Display.register(address(mkr2), \"maker2\");\n    Display.register(address(tkr), \"taker\");\n  }\n\n  function provision_adds_freeWei_and_ethers_test() public {\n    uint mgv_bal = address(mgv).balance;\n    uint amt1 = 235;\n    uint amt2 = 1.3 ether;\n\n    mkr.provisionMgv(amt1);\n\n    TestEvents.eq(mkr.freeWei(), amt1, \"incorrect mkr freeWei amount (1)\");\n    TestEvents.eq(\n      address(mgv).balance,\n      mgv_bal + amt1,\n      \"incorrect mgv ETH balance (1)\"\n    );\n\n    mkr.provisionMgv(amt2);\n\n    TestEvents.eq(\n      mkr.freeWei(),\n      amt1 + amt2,\n      \"incorrect mkr freeWei amount (2)\"\n    );\n    TestEvents.eq(\n      address(mgv).balance,\n      mgv_bal + amt1 + amt2,\n      \"incorrect mgv ETH balance (2)\"\n    );\n  }\n\n  // since we check calldata, execute must be internal\n  function makerExecute(ML.SingleOrder calldata order)\n    external\n    override\n    returns (bytes32 ret)\n  {\n    ret; // silence unused function parameter warning\n    uint num_args = 9;\n    uint selector_bytes = 4;\n    uint length = selector_bytes + num_args * 32;\n    TestEvents.eq(\n      msg.data.length,\n      length,\n      \"calldata length in execute is incorrect\"\n    );\n\n    TestEvents.eq(order.outbound_tkn, _base, \"wrong base\");\n    TestEvents.eq(order.inbound_tkn, _quote, \"wrong quote\");\n    TestEvents.eq(order.wants, 0.05 ether, \"wrong takerWants\");\n    TestEvents.eq(order.gives, 0.05 ether, \"wrong takerGives\");\n    TestEvents.eq(\n      order.offerDetail.gasreq(),\n      200_000,\n      \"wrong gasreq\"\n    );\n    TestEvents.eq(order.offerId, 1, \"wrong offerId\");\n    TestEvents.eq(\n      order.offer.wants(),\n      0.05 ether,\n      \"wrong offerWants\"\n    );\n    TestEvents.eq(\n      order.offer.gives(),\n      0.05 ether,\n      \"wrong offerGives\"\n    );\n    // test flashloan\n    TestEvents.eq(\n      quote.balanceOf(address(this)),\n      0.05 ether,\n      \"wrong quote balance\"\n    );\n    return \"\";\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {}\n\n  function calldata_and_balance_in_makerExecute_are_correct_test() public {\n    bool funded;\n    (funded, ) = address(mgv).call{value: 1 ether}(\"\");\n    base.mint(address(this), 1 ether);\n    uint ofr = mgv.newOffer(\n      _base,\n      _quote,\n      0.05 ether,\n      0.05 ether,\n      200_000,\n      0,\n      0\n    );\n    require(tkr.take(ofr, 0.05 ether), \"take must work or test is void\");\n  }\n\n  function withdraw_removes_freeWei_and_ethers_test() public {\n    uint mgv_bal = address(mgv).balance;\n    uint amt1 = 0.86 ether;\n    uint amt2 = 0.12 ether;\n\n    mkr.provisionMgv(amt1);\n    bool success = mkr.withdrawMgv(amt2);\n    TestEvents.check(success, \"mkr was not able to withdraw from mgv\");\n    TestEvents.eq(mkr.freeWei(), amt1 - amt2, \"incorrect mkr freeWei amount\");\n    TestEvents.eq(\n      address(mgv).balance,\n      mgv_bal + amt1 - amt2,\n      \"incorrect mgv ETH balance\"\n    );\n  }\n\n  function withdraw_too_much_fails_test() public {\n    uint amt1 = 6.003 ether;\n    mkr.provisionMgv(amt1);\n    try mkr.withdrawMgv(amt1 + 1) {\n      TestEvents.fail(\"mkr cannot withdraw more than it has\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/insufficientProvision\", \"wrong revert reason\");\n    }\n  }\n\n  function newOffer_without_freeWei_fails_test() public {\n    try mkr.newOffer(1 ether, 1 ether, 0, 0) {\n      TestEvents.fail(\"mkr cannot create offer without provision\");\n    } catch Error(string memory r) {\n      TestEvents.eq(\n        r,\n        \"mgv/insufficientProvision\",\n        \"new offer failed for wrong reason\"\n      );\n    }\n  }\n\n  function fund_newOffer_test() public {\n    uint oldBal = mgv.balanceOf(address(mkr));\n    mkr.newOfferWithFunding(1 ether, 1 ether, 50000, 0, 1 ether);\n    TestEvents.more(mgv.balanceOf(address(mkr)),oldBal,\"balance should have increased\");\n\n    TestEvents.expectFrom(address(mgv));\n    emit Credit(address(mkr),1 ether);\n  }\n\n  function fund_updateOffer_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n    mkr.updateOfferWithFunding(1 ether, 1 ether, 50000, 0,ofr, 0.9 ether);\n\n    TestEvents.expectFrom(address(mgv));\n    emit Credit(address(mkr),0.9 ether);\n  }\n\n  function posthook_fail_message_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n\n    mkr.setShouldFailHook(true);\n    tkr.take(ofr, 0.1 ether); // fails but we don't care\n\n    TestEvents.expectFrom(address(mgv));\n    emit PosthookFail(_base, _quote, ofr);\n  }\n\n  function badReturn_fails_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n\n    mkr.shouldAbort(true);\n    bool success = tkr.take(ofr, 0.1 ether);\n    TestEvents.check(!success, \"take should fail\");\n    mkr.expect(\"abort\");\n  }\n\n  function delete_restores_balance_test() public {\n    mkr.provisionMgv(1 ether);\n    uint bal = mkr.freeWei(); // should be 1 ether\n    uint offerId = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    uint bal_ = mkr.freeWei(); // 1 ether minus provision\n    uint collected = mkr.retractOfferWithDeprovision(offerId); // provision\n    TestEvents.eq(\n      bal - bal_,\n      collected,\n      \"retract does not return a correct amount\"\n    );\n    TestEvents.eq(mkr.freeWei(), bal, \"delete has not restored balance\");\n  }\n\n  function delete_offer_log_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    mkr.retractOfferWithDeprovision(ofr);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferRetract(_base, _quote, ofr);\n  }\n\n  function retract_retracted_does_not_drain_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n\n    mkr.retractOffer(ofr);\n\n    uint bal1 = mgv.balanceOf(address(mkr));\n    uint collected = mkr.retractOfferWithDeprovision(ofr);\n    TestEvents.check(collected > 0, \"deprovision should give credit\");\n    uint bal2 = mgv.balanceOf(address(mkr));\n    TestEvents.less(bal1, bal2, \"Balance should have increased\");\n\n    uint collected2 = mkr.retractOfferWithDeprovision(ofr);\n    TestEvents.check(\n      collected2 == 0,\n      \"second deprovision should not give credit\"\n    );\n    uint bal3 = mgv.balanceOf(address(mkr));\n    TestEvents.eq(bal3, bal2, \"Balance should not have increased\");\n  }\n\n  function retract_taken_does_not_drain_test() public {\n    mkr.provisionMgv(1 ether);\n    base.mint(address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    bool success = tkr.take(ofr, 0.1 ether);\n    TestEvents.eq(success, true, \"Snipe should succeed\");\n\n    uint bal1 = mgv.balanceOf(address(mkr));\n    mkr.retractOfferWithDeprovision(ofr);\n    uint bal2 = mgv.balanceOf(address(mkr));\n    TestEvents.less(bal1, bal2, \"Balance should have increased\");\n\n    uint collected = mkr.retractOfferWithDeprovision(ofr);\n    TestEvents.check(\n      collected == 0,\n      \"second deprovision should not give credit\"\n    );\n    uint bal3 = mgv.balanceOf(address(mkr));\n    TestEvents.eq(bal3, bal2, \"Balance should not have increased\");\n  }\n\n  function retract_offer_log_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    mkr.retractOffer(ofr);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferRetract(_base, _quote, ofr);\n  }\n\n  function retract_offer_maintains_balance_test() public {\n    mkr.provisionMgv(1 ether);\n    uint bal = mkr.freeWei();\n    uint prov = TestUtils.getProvision(mgv, _base, _quote, 2300);\n    mkr.retractOffer(mkr.newOffer(1 ether, 1 ether, 2300, 0));\n    TestEvents.eq(mkr.freeWei(), bal - prov, \"unexpected maker balance\");\n  }\n\n  function retract_middle_offer_leaves_a_valid_book_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 2300, 100);\n\n    mkr.retractOffer(ofr);\n    TestEvents.check(\n      !mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Offer was not removed from OB\"\n    );\n    (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) = mgv.offerInfo(\n      _base,\n      _quote,\n      ofr\n    );\n    TestEvents.eq(offer.prev, ofr0, \"Invalid prev\");\n    TestEvents.eq(offer.next, ofr1, \"Invalid next\");\n    TestEvents.eq(offer.gives, 0, \"offer gives was not set to 0\");\n    TestEvents.eq(offerDetail.gasprice, 100, \"offer gasprice is incorrect\");\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.prev)),\n      \"Invalid OB\"\n    );\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.next)),\n      \"Invalid OB\"\n    );\n    (P.OfferStruct memory offer0, ) = mgv.offerInfo(_base, _quote, offer.prev);\n    (P.OfferStruct memory offer1, ) = mgv.offerInfo(_base, _quote, offer.next);\n    TestEvents.eq(offer1.prev, ofr0, \"Invalid snitching for ofr1\");\n    TestEvents.eq(offer0.next, ofr1, \"Invalid snitching for ofr0\");\n  }\n\n  function retract_best_offer_leaves_a_valid_book_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 2300, 100);\n    mkr.retractOffer(ofr);\n    TestEvents.check(\n      !mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Offer was not removed from OB\"\n    );\n    (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) = mgv.offerInfo(\n      _base,\n      _quote,\n      ofr\n    );\n    TestEvents.eq(offer.prev, 0, \"Invalid prev\");\n    TestEvents.eq(offer.next, ofr1, \"Invalid next\");\n    TestEvents.eq(offer.gives, 0, \"offer gives was not set to 0\");\n    TestEvents.eq(offerDetail.gasprice, 100, \"offer gasprice is incorrect\");\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.next)),\n      \"Invalid OB\"\n    );\n    (P.OfferStruct memory offer1, ) = mgv.offerInfo(_base, _quote, offer.next);\n    TestEvents.eq(offer1.prev, 0, \"Invalid snitching for ofr1\");\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      cfg.best(),\n      ofr1,\n      \"Invalid best after retract\"\n    );\n  }\n\n  function retract_worst_offer_leaves_a_valid_book_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr0 = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Offer was not removed from OB\"\n    );\n    mkr.retractOffer(ofr);\n    (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) = mgv.offerInfo(\n      _base,\n      _quote,\n      ofr\n    );\n    TestEvents.eq(offer.prev, ofr0, \"Invalid prev\");\n    TestEvents.eq(offer.next, 0, \"Invalid next\");\n    TestEvents.eq(offer.gives, 0, \"offer gives was not set to 0\");\n    TestEvents.eq(offerDetail.gasprice, 100, \"offer gasprice is incorrect\");\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.prev)),\n      \"Invalid OB\"\n    );\n    (P.OfferStruct memory offer0, ) = mgv.offerInfo(_base, _quote, offer.prev);\n    TestEvents.eq(offer0.next, 0, \"Invalid snitching for ofr0\");\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      cfg.best(),\n      ofr0,\n      \"Invalid best after retract\"\n    );\n  }\n\n  function delete_wrong_offer_fails_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    try mkr2.retractOfferWithDeprovision(ofr) {\n      TestEvents.fail(\"mkr2 should not be able to delete mkr's offer\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/retractOffer/unauthorized\", \"wrong revert reason\");\n    }\n  }\n\n  function retract_wrong_offer_fails_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    try mkr2.retractOffer(ofr) {\n      TestEvents.fail(\"mkr2 should not be able to retract mkr's offer\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/retractOffer/unauthorized\", \"wrong revert reason\");\n    }\n  }\n\n  function gasreq_max_with_newOffer_ok_test() public {\n    mkr.provisionMgv(1 ether);\n    uint gasmax = 750000;\n    mgv.setGasmax(gasmax);\n    mkr.newOffer(1 ether, 1 ether, gasmax, 0);\n  }\n\n  function gasreq_too_high_fails_newOffer_test() public {\n    uint gasmax = 12;\n    mgv.setGasmax(gasmax);\n    try mkr.newOffer(1 ether, 1 ether, gasmax + 1, 0) {\n      TestEvents.fail(\"gasreq above gasmax, newOffer should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasreq/tooHigh\", \"wrong revert reason\");\n    }\n  }\n\n  function min_density_with_newOffer_ok_test() public {\n    mkr.provisionMgv(1 ether);\n    uint density = 10**7;\n    mgv.setGasbase(_base, _quote, 1);\n    mgv.setDensity(_base, _quote, density);\n    mkr.newOffer(1 ether, density, 0, 0);\n  }\n\n  function low_density_fails_newOffer_test() public {\n    uint density = 10**7;\n    mgv.setGasbase(_base, _quote, 1);\n    mgv.setDensity(_base, _quote, density);\n    try mkr.newOffer(1 ether, density - 1, 0, 0) {\n      TestEvents.fail(\"density too low, newOffer should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/density/tooLow\", \"wrong revert reason\");\n    }\n  }\n\n  function maker_gets_no_freeWei_on_partial_fill_test() public {\n    mkr.provisionMgv(1 ether);\n    base.mint(address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldBalance = mgv.balanceOf(address(mkr));\n    bool success = tkr.take(ofr, 0.1 ether);\n    TestEvents.check(success, \"take must succeed\");\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      oldBalance,\n      \"mkr balance must not change\"\n    );\n  }\n\n  function maker_gets_no_freeWei_on_full_fill_test() public {\n    mkr.provisionMgv(1 ether);\n    base.mint(address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldBalance = mgv.balanceOf(address(mkr));\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(success, \"take must succeed\");\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      oldBalance,\n      \"mkr balance must not change\"\n    );\n  }\n\n  function insertions_are_correctly_ordered_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    uint ofr01 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t loc_cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, loc_cfg.best(), \"Wrong best offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr0)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (P.OfferStruct memory offer, ) = mgv.offerInfo(_base, _quote, ofr0);\n    uint _ofr01 = offer.next;\n    TestEvents.eq(_ofr01, ofr01, \"Wrong 2nd offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, _ofr01)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, _ofr01);\n    uint _ofr1 = offer.next;\n    TestEvents.eq(_ofr1, ofr1, \"Wrong 3rd offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, _ofr1)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, _ofr1);\n    uint _ofr2 = offer.next;\n    TestEvents.eq(_ofr2, ofr2, \"Wrong 4th offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, _ofr2)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, _ofr2);\n    TestEvents.eq(offer.next, 0, \"Invalid OB\");\n  }\n\n  // insertTest price, density (gives/gasreq) vs (gives'/gasreq'), age\n  // nolongerBest\n  // idemPrice\n  // idemBest\n  // A.BCD --> ABC.D\n\n  function update_offer_resets_age_and_updates_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      cfg.best(),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_nolonger_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether + 1, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      cfg.best(),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_density_nolonger_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      cfg.best(),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_with_self_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether + 1, 100_000, ofr1, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      cfg.best(),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_density_with_self_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 99_999, ofr1, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestUtils.logOfferBook(mgv, _base, _quote, 2);\n    TestEvents.eq(\n      cfg.best(),\n      ofr1,\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_with_best_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether + 1, 100_000, ofr0, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      cfg.best(),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_density_with_best_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 99_999, ofr0, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestUtils.logOfferBook(mgv, _base, _quote, 2);\n    TestEvents.eq(\n      cfg.best(),\n      ofr1,\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_with_best_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr3 = mkr.newOffer(1.2 ether, 1 ether, 100_000, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (P.OfferStruct memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.1 ether, 1.0 ether, 100_000, ofr0, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_price_with_self_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr3 = mkr.newOffer(1.2 ether, 1 ether, 100_000, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (P.OfferStruct memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.1 ether, 1.0 ether, 100_000, ofr, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_density_with_best_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.0 ether, 1 ether, 100_001, 0);\n    uint ofr3 = mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (P.OfferStruct memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Update error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_density_with_self_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.0 ether, 1 ether, 100_001, 0);\n    uint ofr3 = mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (P.OfferStruct memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_after_higher_gasprice_change_fails_test() public {\n    uint provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    mkr.provisionMgv(provision);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (P.Global.t cfg, ) = mgv.config(_base, _quote);\n    mgv.setGasprice(cfg.gasprice() + 1); //gasprice goes up\n    try mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0) {\n      TestEvents.fail(\"Update offer should have failed\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/insufficientProvision\", \"wrong revert reason\");\n    }\n  }\n\n  function update_offer_after_higher_gasprice_change_succeeds_when_over_provisioned_test()\n    public\n  {\n    (P.Global.t cfg, ) = mgv.config(_base, _quote);\n    uint gasprice = cfg.gasprice();\n    uint provision = TestUtils.getProvision(\n      mgv,\n      _base,\n      _quote,\n      100_000,\n      gasprice\n    );\n    mkr.provisionMgv(provision * 2); // provisionning twice the required amount\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0); // locking exact bounty\n    mgv.setGasprice(gasprice + 1); //gasprice goes up\n    uint provision_ = TestUtils.getProvision( // new theoretical provision\n      mgv,\n      _base,\n      _quote,\n      100_000,\n      gasprice + 1\n    );\n    (cfg, ) = mgv.config(_base, _quote);\n    try mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0) {\n      TestEvents.expectFrom(address(mgv));\n      emit Credit(address(mkr), provision * 2);\n      emit OfferWrite(\n        _base,\n        _quote,\n        address(mkr),\n        1.0 ether,\n        1.0 ether,\n        gasprice, // offer at old gasprice\n        100_000,\n        ofr0,\n        0\n      );\n      emit Debit(address(mkr), provision); // transfering missing provision into offer bounty\n      emit OfferWrite(\n        _base,\n        _quote,\n        address(mkr),\n        1.0 ether + 2,\n        1.0 ether,\n        cfg.gasprice(), // offer gasprice should be the new gasprice\n        100_000,\n        ofr0,\n        0\n      );\n      emit Debit(address(mkr), provision_ - provision); // transfering missing provision into offer bounty\n    } catch {\n      TestEvents.fail(\"Update offer should have succeeded\");\n    }\n  }\n\n  function update_offer_after_lower_gasprice_change_succeeds_test() public {\n    uint provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    mkr.provisionMgv(provision);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (P.Global.t cfg, ) = mgv.config(_base, _quote);\n    mgv.setGasprice(cfg.gasprice() - 1); //gasprice goes down\n    uint _provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    try mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0) {\n      TestEvents.eq(\n        mgv.balanceOf(address(mkr)),\n        provision - _provision,\n        \"Maker balance is incorrect\"\n      );\n      TestEvents.expectFrom(address(mgv));\n      emit Credit(address(mkr), provision - _provision);\n    } catch {\n      TestEvents.fail(\"Update offer should have succeeded\");\n    }\n  }\n\n  function update_offer_next_to_itself_does_not_break_ob_test() public {\n    mkr.provisionMgv(1 ether);\n    uint left = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint right = mkr.newOffer(1 ether + 3, 1 ether, 100_000, 0);\n    uint center = mkr.newOffer(1 ether + 1, 1 ether, 100_000, 0);\n    mkr.updateOffer(1 ether + 2, 1 ether, 100_000, center, center);\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(_base, _quote, center);\n    TestEvents.eq(ofr.prev, left, \"ofr.prev should be unchanged\");\n    TestEvents.eq(ofr.next, right, \"ofr.next should be unchanged\");\n  }\n\n  function update_on_retracted_offer_test() public {\n    uint provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    mkr.provisionMgv(provision);\n    uint offerId = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.retractOfferWithDeprovision(offerId);\n    mkr.withdrawMgv(provision);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      0,\n      \"Maker should have no more provision on Mangrove\"\n    );\n    (P.OfferStruct memory ofr, P.OfferDetailStruct memory dtl) = mgv.offerInfo(\n      _base,\n      _quote,\n      offerId\n    );\n    TestEvents.eq(ofr.gives, 0, \"Retracted offer should have 0 gives\");\n    TestEvents.eq(\n      dtl.gasprice,\n      0,\n      \"Deprovisioned offer should have 0 gasprice\"\n    );\n    try mkr.updateOffer(1 ether + 2, 1 ether, 100_000, offerId, offerId) {\n      TestEvents.fail(\n        \"Deprovisioned offer cannot be updated unless reprovisioned\"\n      );\n    } catch Error(string memory message) {\n      TestEvents.eq(message, \"mgv/insufficientProvision\", \"\");\n      mkr.provisionMgv(provision);\n      try mkr.updateOffer(1 ether + 2, 1 ether, 100_000, offerId, offerId) {\n        (ofr, ) = mgv.offerInfo(_base, _quote, offerId);\n        TestEvents.eq(ofr.gives, 1 ether, \"Offer not correctly updated\");\n      } catch {\n        TestEvents.fail(\"Updating offer should succeed\");\n      }\n    }\n  }\n\n  function testOBBest(uint id) internal {\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(_base, _quote, id);\n    TestEvents.eq(mgv.best(_base, _quote), id, \"testOBBest: not best\");\n    TestEvents.eq(ofr.prev, 0, \"testOBBest: prev not 0\");\n  }\n\n  function testOBWorst(uint id) internal {\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(_base, _quote, id);\n    TestEvents.eq(ofr.next, 0, \"testOBWorst fail\");\n  }\n\n  function testOBLink(uint left, uint right) internal {\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(_base, _quote, left);\n    TestEvents.eq(ofr.next, right, \"testOBLink: wrong ofr.next\");\n    (ofr, ) = mgv.offerInfo(_base, _quote, right);\n    TestEvents.eq(ofr.prev, left, \"testOBLink: wrong ofr.prev\");\n  }\n\n  function testOBOrder(uint[1] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBWorst(ids[0]);\n  }\n\n  function testOBOrder(uint[2] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBLink(ids[0], ids[1]);\n    testOBWorst(ids[1]);\n  }\n\n  function testOBOrder(uint[3] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBLink(ids[0], ids[1]);\n    testOBLink(ids[1], ids[2]);\n    testOBWorst(ids[2]);\n  }\n\n  function complex_offer_update_left_1_1_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_right_1_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, two, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_left_1_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 5, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_right_1_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 5, x, g, two, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_left_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    uint three = mkr.newOffer(x + 5, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, 0, three);\n\n    testOBOrder([one, three, two]);\n  }\n\n  function complex_offer_update_right_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    uint three = mkr.newOffer(x + 5, x, g, 0);\n    mkr.updateOffer(x + 4, x, g, three, one);\n\n    testOBOrder([two, one, three]);\n  }\n\n  function complex_offer_update_left_3_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.retractOffer(two);\n    mkr.updateOffer(x + 3, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_right_3_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.retractOffer(one);\n    mkr.updateOffer(x, x, g, 0, one);\n\n    testOBOrder([one, two]);\n  }\n\n  function update_offer_prev_to_itself_does_not_break_ob_test() public {\n    mkr.provisionMgv(1 ether);\n    uint left = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint right = mkr.newOffer(1 ether + 3, 1 ether, 100_000, 0);\n    uint center = mkr.newOffer(1 ether + 2, 1 ether, 100_000, 0);\n    mkr.updateOffer(1 ether + 1, 1 ether, 100_000, center, center);\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(_base, _quote, center);\n    TestEvents.eq(ofr.prev, left, \"ofr.prev should be unchanged\");\n    TestEvents.eq(ofr.next, right, \"ofr.next should be unchanged\");\n  }\n\n  function update_offer_price_stays_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1.0 ether + 2, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether + 1, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr0,\n      cfg.best(),\n      \"Best offer should not have changed\"\n    );\n  }\n\n  function update_offer_density_stays_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n    (, P.Local.t cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr0,\n      cfg.best(),\n      \"Best offer should not have changed\"\n    );\n  }\n\n  function gasbase_is_deducted_1_test() public {\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mgv.setGasbase(_base, _quote, offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity(_base, _quote, 0);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 0, 0);\n    tkr.take(ofr, 0.1 ether);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - offer_gasbase * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  function gasbase_is_deducted_2_test() public {\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mgv.setGasbase(_base, _quote, offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity(_base, _quote, 0);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 0, 0);\n    tkr.take(ofr, 0.1 ether);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - offer_gasbase * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  function penalty_gasprice_is_mgv_gasprice_test() public {\n    mgv.setGasprice(10);\n    mkr.shouldFail(true);\n    mkr.provisionMgv(1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldProvision = mgv.balanceOf(address(mkr));\n    mgv.setGasprice(10000);\n    (uint gave, uint got) = tkr.marketOrder(1 ether, 1 ether);\n    TestEvents.check(gave == got && got == 0, \"market Order should be noop\");\n    uint gotBack = mgv.balanceOf(address(mkr)) - oldProvision;\n    TestEvents.eq(gotBack, 0, \"Should not have gotten any provision back\");\n  }\n}\n"
    },
    "contracts/Tests/Integration/Scenarii.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\n//import \"../Mangrove.sol\";\n//import \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"../Toolbox/TestUtils.sol\";\n// import \"../Toolbox/Display.sol\";\n\nimport \"../Agents/TestToken.sol\";\nimport \"../Agents/TestMaker.sol\";\nimport \"../Agents/TestMoriartyMaker.sol\";\nimport \"../Agents/MakerDeployer.sol\";\nimport \"../Agents/TestTaker.sol\";\nimport \"../Agents/TestDelegateTaker.sol\";\nimport \"../Agents/OfferManager.sol\";\n\nimport \"./TestCancelOffer.sol\";\nimport \"./TestCollectFailingOffer.sol\";\nimport \"./TestInsert.sol\";\nimport \"./TestSnipe.sol\";\nimport \"./TestFailingMarketOrder.sol\";\nimport \"./TestMarketOrder.sol\";\n\n// Pretest libraries are for deploying large contracts independently.\n// Otherwise bytecode can be too large. See EIP 170 for more on size limit:\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md\n\ncontract Scenarii_Test is HasMgvEvents {\n  AbstractMangrove mgv;\n  TestTaker taker;\n  MakerDeployer makers;\n  TestToken base;\n  TestToken quote;\n  TestUtils.Balances balances;\n  uint[] offerOf;\n\n  mapping(uint => mapping(TestUtils.Info => uint)) offers;\n\n  receive() external payable {}\n\n  function saveOffers() internal {\n    uint offerId = mgv.best(address(base), address(quote));\n    while (offerId != 0) {\n      (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) = mgv\n        .offerInfo(address(base), address(quote), offerId);\n      offers[offerId][TestUtils.Info.makerWants] = offer.wants;\n      offers[offerId][TestUtils.Info.makerGives] = offer.gives;\n      offers[offerId][TestUtils.Info.gasreq] = offerDetail.gasreq;\n      offerId = offer.next;\n    }\n  }\n\n  function saveBalances() internal {\n    uint[] memory balA = new uint[](makers.length());\n    uint[] memory balB = new uint[](makers.length());\n    uint[] memory balWei = new uint[](makers.length());\n    for (uint i = 0; i < makers.length(); i++) {\n      balA[i] = base.balanceOf(address(makers.getMaker(i)));\n      balB[i] = quote.balanceOf(address(makers.getMaker(i)));\n      balWei[i] = mgv.balanceOf(address(makers.getMaker(i)));\n    }\n    balances = TestUtils.Balances({\n      mgvBalanceWei: address(mgv).balance,\n      mgvBalanceFees: base.balanceOf(TestUtils.adminOf(mgv)),\n      takerBalanceA: base.balanceOf(address(taker)),\n      takerBalanceB: quote.balanceOf(address(taker)),\n      takerBalanceWei: mgv.balanceOf(address(taker)),\n      makersBalanceA: balA,\n      makersBalanceB: balB,\n      makersBalanceWei: balWei\n    });\n  }\n\n  function a_deployToken_beforeAll() public {\n    //console.log(\"IN BEFORE ALL\");\n    base = TokenSetup.setup(\"A\", \"$A\");\n    quote = TokenSetup.setup(\"B\", \"$B\");\n\n    TestUtils.not0x(address(base));\n    TestUtils.not0x(address(quote));\n\n    Display.register(address(0), \"NULL_ADDRESS\");\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Mgv_Test\");\n    Display.register(address(base), \"base\");\n    Display.register(address(quote), \"quote\");\n  }\n\n  function b_deployMgv_beforeAll() public {\n    mgv = MgvSetup.setup(base, quote);\n    Display.register(address(mgv), \"Mgv\");\n    TestUtils.not0x(address(mgv));\n    mgv.setFee(address(base), address(quote), 300);\n  }\n\n  function c_deployMakersTaker_beforeAll() public {\n    makers = MakerDeployerSetup.setup(mgv, address(base), address(quote));\n    makers.deploy(4);\n    for (uint i = 1; i < makers.length(); i++) {\n      Display.register(\n        address(makers.getMaker(i)),\n        TestUtils.append(\"maker-\", TestUtils.uint2str(i))\n      );\n    }\n    Display.register(address(makers.getMaker(0)), \"failer\");\n    taker = TakerSetup.setup(mgv, address(base), address(quote));\n    Display.register(address(taker), \"taker\");\n  }\n\n  function d_provisionAll_beforeAll() public {\n    // low level tranfer because makers needs gas to transfer to each maker\n    (bool success, ) = address(makers).call{gas: gasleft(), value: 80 ether}(\n      \"\"\n    ); // msg.value is distributed evenly amongst makers\n    require(success, \"maker transfer\");\n\n    for (uint i = 0; i < makers.length(); i++) {\n      TestMaker maker = makers.getMaker(i);\n      maker.provisionMgv(10 ether);\n      base.mint(address(maker), 5 ether);\n    }\n\n    quote.mint(address(taker), 5 ether);\n    taker.approveMgv(quote, 5 ether);\n    taker.approveMgv(base, 50 ether);\n    saveBalances();\n  }\n\n  function snipe_insert_and_fail_test() public {\n    offerOf = TestInsert.run(balances, mgv, makers, taker, base, quote);\n    //TestUtils.printOfferBook(mgv);\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    //TestEvents.logString(\"=== Snipe test ===\", 0);\n    saveBalances();\n    saveOffers();\n    (uint takerGot, uint takerGave) = TestSnipe.run(\n      balances,\n      offers,\n      mgv,\n      makers,\n      taker,\n      base,\n      quote\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OrderStart();\n    emit OrderComplete(\n      address(base),\n      address(quote),\n      address(taker),\n      takerGot,\n      takerGave,\n      0\n    );\n    TestEvents.stopExpecting();\n\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    // restore offer that was deleted after partial fill, minus taken amount\n    makers.getMaker(2).updateOffer(\n      1 ether - 0.375 ether,\n      0.8 ether - 0.3 ether,\n      80_000,\n      0,\n      2\n    );\n\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    //TestEvents.logString(\"=== Market order test ===\", 0);\n    saveBalances();\n    saveOffers();\n    TestMarketOrder.run(balances, offers, mgv, makers, taker, base, quote);\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    //TestEvents.logString(\"=== Failling offer test ===\", 0);\n    saveBalances();\n    saveOffers();\n    TestCollectFailingOffer.run(\n      balances,\n      offers,\n      mgv,\n      offerOf[0],\n      makers,\n      taker,\n      base,\n      quote\n    );\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n    saveBalances();\n    saveOffers();\n  }\n}\n\ncontract DeepCollect_Test {\n  TestToken base;\n  TestToken quote;\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMoriartyMaker evil;\n\n  receive() external payable {}\n\n  function a_beforeAll() public {\n    base = TokenSetup.setup(\"A\", \"$A\");\n    quote = TokenSetup.setup(\"B\", \"$B\");\n    mgv = MgvSetup.setup(base, quote);\n    tkr = TakerSetup.setup(mgv, address(base), address(quote));\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"DeepCollect_Tester\");\n    Display.register(address(base), \"$A\");\n    Display.register(address(quote), \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(tkr), \"taker\");\n\n    quote.mint(address(tkr), 5 ether);\n    tkr.approveMgv(quote, 20 ether);\n    tkr.approveMgv(base, 20 ether);\n\n    evil = new TestMoriartyMaker(mgv, address(base), address(quote));\n    Display.register(address(evil), \"Moriarty\");\n\n    (bool success, ) = address(evil).call{gas: gasleft(), value: 20 ether}(\"\");\n    require(success, \"maker transfer\");\n    evil.provisionMgv(10 ether);\n    base.mint(address(evil), 5 ether);\n    evil.approveMgv(base, 5 ether);\n\n    evil.newOffer({\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 100000,\n      pivotId: 0\n    });\n  }\n\n  function market_with_failures_test() public {\n    //TestEvents.logString(\"=== DeepCollect test ===\", 0);\n    TestFailingMarketOrder.moWithFailures(\n      mgv,\n      address(base),\n      address(quote),\n      tkr\n    );\n  }\n}\n"
    },
    "contracts/Tests/Agents/TestDelegateTaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../AbstractMangrove.sol\";\nimport \"./OfferManager.sol\";\nimport \"./TestToken.sol\";\n\ncontract TestDelegateTaker is ITaker {\n  OfferManager ofrMgr;\n  TestToken base;\n  TestToken quote;\n\n  constructor(\n    OfferManager _ofrMgr,\n    TestToken _base,\n    TestToken _quote\n  ) {\n    ofrMgr = _ofrMgr;\n    base = _base;\n    quote = _quote;\n  }\n\n  receive() external payable {}\n\n  function takerTrade(\n    //NB this is not called if mgv is not a flashTaker mgv\n    address,\n    address,\n    uint,\n    uint shouldGive\n  ) external override {\n    if (msg.sender == address(ofrMgr)) {\n      TestToken(quote).mint(address(this), shouldGive); // taker should have been given admin status for quote\n    } // taker should have approved ofrMgr for quote\n  }\n\n  function delegateOrder(\n    OfferManager mgr,\n    uint wants,\n    uint gives,\n    AbstractMangrove mgv,\n    bool invertedResidual\n  ) public {\n    try quote.approve(address(mgr), gives) {\n      mgr.order{value: 0.01 ether}(\n        mgv,\n        address(base),\n        address(quote),\n        wants,\n        gives,\n        invertedResidual\n      );\n    } catch {\n      require(false, \"failed to approve mgr\");\n    }\n  }\n}\n"
    },
    "contracts/Tests/Integration/TestCancelOffer.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestCancelOffer {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    TestMaker wrongOwner,\n    TestMaker maker,\n    uint offerId,\n    TestTaker, /* taker */\n    TestToken base,\n    TestToken quote\n  ) external {\n    try wrongOwner.retractOfferWithDeprovision(offerId) {\n      TestEvents.fail(\"Invalid authorization to cancel order\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(reason, \"mgv/cancelOffer/unauthorized\", \"Unexpected throw\");\n      try maker.retractOfferWithDeprovision(offerId) {\n        maker.retractOfferWithDeprovision(0);\n        uint provisioned = TestUtils.getProvision(\n          mgv,\n          address(base),\n          address(quote),\n          offers[offerId][TestUtils.Info.gasreq]\n        );\n        TestEvents.eq(\n          mgv.balanceOf(address(maker)),\n          balances.makersBalanceWei[offerId] + provisioned,\n          \"Incorrect returned provision to maker\"\n        );\n      } catch {\n        TestEvents.fail(\"Cancel order failed unexpectedly\");\n      }\n    }\n  }\n}\n"
    },
    "contracts/Tests/Integration/TestCollectFailingOffer.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestCollectFailingOffer {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    uint failingOfferId,\n    MakerDeployer makers,\n    TestTaker taker,\n    TestToken base,\n    TestToken quote\n  ) external {\n    // executing failing offer\n    try taker.takeWithInfo(failingOfferId, 0.5 ether) returns (\n      bool success,\n      uint takerGot,\n      uint takerGave\n    ) {\n      // take should return false not throw\n      TestEvents.check(!success, \"Failer should fail\");\n      TestEvents.eq(takerGot, 0, \"Failed offer should declare 0 takerGot\");\n      TestEvents.eq(takerGave, 0, \"Failed offer should declare 0 takerGave\");\n      // failingOffer should have been removed from Mgv\n      {\n        TestEvents.check(\n          !mgv.isLive(\n            mgv.offers(address(base), address(quote), failingOfferId)\n          ),\n          \"Failing offer should have been removed from Mgv\"\n        );\n      }\n      uint provision = TestUtils.getProvision(\n        mgv,\n        address(base),\n        address(quote),\n        offers[failingOfferId][TestUtils.Info.gasreq]\n      );\n      uint returned = mgv.balanceOf(address(makers.getMaker(0))) -\n        balances.makersBalanceWei[0];\n      TestEvents.eq(\n        address(mgv).balance,\n        balances.mgvBalanceWei - (provision - returned),\n        \"Mangrove has not send the correct amount to taker\"\n      );\n    } catch (bytes memory errorMsg) {\n      string memory err = abi.decode(errorMsg, (string));\n      TestEvents.fail(err);\n    }\n  }\n}\n"
    },
    "contracts/Tests/Integration/TestInsert.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestInsert {\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  function run(\n    TestUtils.Balances storage balances,\n    AbstractMangrove mgv,\n    MakerDeployer makers,\n    TestTaker, /* taker */ // silence warning about unused argument\n    TestToken base,\n    TestToken quote\n  ) public returns (uint[] memory) {\n    // each maker publishes an offer\n    uint[] memory offerOf = new uint[](makers.length());\n    offerOf[1] = makers.getMaker(1).newOffer({ // offer 1\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 50_000,\n      pivotId: 0\n    });\n    offerOf[2] = makers.getMaker(2).newOffer({ // offer 2\n      wants: 1 ether,\n      gives: 0.8 ether,\n      gasreq: 80_000,\n      pivotId: 1\n    });\n    offerOf[3] = makers.getMaker(3).newOffer({ // offer 3\n      wants: 0.5 ether,\n      gives: 1 ether,\n      gasreq: 90_000,\n      pivotId: 72\n    });\n    (P.Global.t cfg, ) = mgv.config(address(base), address(quote));\n    offerOf[0] = makers.getMaker(0).newOffer({ //failer offer 4\n      wants: 20 ether,\n      gives: 10 ether,\n      gasreq: cfg.gasmax(),\n      pivotId: 0\n    });\n    //TestUtils.printOfferBook(mgv);\n    //Checking makers have correctly provisoned their offers\n    for (uint i = 0; i < makers.length(); i++) {\n      uint gasreq_i = TestUtils.getOfferInfo(\n        mgv,\n        address(base),\n        address(quote),\n        TestUtils.Info.gasreq,\n        offerOf[i]\n      );\n      uint provision_i = TestUtils.getProvision(\n        mgv,\n        address(base),\n        address(quote),\n        gasreq_i\n      );\n      TestEvents.eq(\n        mgv.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceWei[i] - provision_i,\n        TestUtils.append(\n          \"Incorrect wei balance for maker \",\n          TestUtils.uint2str(i)\n        )\n      );\n    }\n    //Checking offers are correctly positioned (3 > 2 > 1 > 0)\n    uint offerId = mgv.best(address(base), address(quote));\n    uint expected_maker = 3;\n    while (offerId != 0) {\n      (P.OfferStruct memory offer, P.OfferDetailStruct memory od) = mgv.offerInfo(\n        address(base),\n        address(quote),\n        offerId\n      );\n      TestEvents.eq(\n        od.maker,\n        address(makers.getMaker(expected_maker)),\n        TestUtils.append(\n          \"Incorrect maker address at offer \",\n          TestUtils.uint2str(offerId)\n        )\n      );\n\n      unchecked {\n        expected_maker -= 1;\n      }\n      offerId = offer.next;\n    }\n    return offerOf;\n  }\n}\n"
    },
    "contracts/Tests/Integration/TestSnipe.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestSnipe {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    MakerDeployer makers,\n    TestTaker taker,\n    TestToken base,\n    TestToken quote\n  ) external returns (uint takerGot, uint takerGave) {\n    uint orderAmount = 0.3 ether;\n    uint snipedId = 2;\n    TestMaker maker = makers.getMaker(snipedId); // maker whose offer will be sniped\n\n    //(uint init_mkr_wants, uint init_mkr_gives,,,,,)=mgv.getOfferInfo(2);\n    //---------------SNIPE------------------//\n    {\n      bool takeSuccess;\n      (takeSuccess, takerGot, takerGave) = taker.takeWithInfo(\n        snipedId,\n        orderAmount\n      );\n\n      TestEvents.check(takeSuccess, \"snipe should be a success\");\n    }\n    TestEvents.eq(\n      base.balanceOf(TestUtils.adminOf(mgv)), //actual\n      balances.mgvBalanceFees +\n        TestUtils.getFee(mgv, address(base), address(quote), orderAmount), //expected\n      \"incorrect Mangrove A balance\"\n    );\n    TestEvents.eq(\n      base.balanceOf(address(taker)), // actual\n      balances.takerBalanceA +\n        orderAmount -\n        TestUtils.getFee(mgv, address(base), address(quote), orderAmount), // expected\n      \"incorrect taker A balance\"\n    );\n    TestEvents.eq(\n      takerGot,\n      orderAmount -\n        TestUtils.getFee(mgv, address(base), address(quote), orderAmount),\n      \"Incorrect takerGot\"\n    );\n    {\n      uint shouldGive = (orderAmount *\n        offers[snipedId][TestUtils.Info.makerWants]) /\n        offers[snipedId][TestUtils.Info.makerGives];\n      TestEvents.eq(\n        quote.balanceOf(address(taker)),\n        balances.takerBalanceB - shouldGive,\n        \"incorrect taker B balance\"\n      );\n      TestEvents.eq(takerGave, shouldGive, \"Incorrect takerGave\");\n    }\n    TestEvents.eq(\n      base.balanceOf(address(maker)),\n      balances.makersBalanceA[snipedId] - orderAmount,\n      \"incorrect maker A balance\"\n    );\n    TestEvents.eq(\n      quote.balanceOf(address(maker)),\n      balances.makersBalanceB[snipedId] +\n        (orderAmount * offers[snipedId][TestUtils.Info.makerWants]) /\n        offers[snipedId][TestUtils.Info.makerGives],\n      \"incorrect maker B balance\"\n    );\n    // Testing residual offer\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(\n      address(base),\n      address(quote),\n      snipedId\n    );\n    TestEvents.check(ofr.gives == 0, \"Offer should not have a residual\");\n  }\n}\n"
    },
    "contracts/Tests/Integration/TestFailingMarketOrder.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestFailingMarketOrder {\n  function moWithFailures(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    TestTaker taker\n  ) external {\n    taker.marketOrderWithFail({wants: 10 ether, gives: 30 ether});\n    TestEvents.check(\n      TestUtils.isEmptyOB(mgv, base, quote),\n      \"Offer book should be empty\"\n    );\n  }\n}\n"
    },
    "contracts/Tests/Integration/TestMarketOrder.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestMarketOrder {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    MakerDeployer makers,\n    TestTaker taker,\n    TestToken base,\n    TestToken quote\n  ) external {\n    uint takerWants = 1.6 ether; // of B token\n    uint takerGives = 2 ether; // of A token\n\n    (uint takerGot, uint takerGave) = taker.marketOrder(takerWants, takerGives);\n\n    // Checking Makers balances\n    for (uint i = 2; i < 4; i++) {\n      // offers 2 and 3 were consumed entirely\n      TestEvents.eq(\n        base.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceA[i] - offers[i][TestUtils.Info.makerGives],\n        TestUtils.append(\n          \"Incorrect A balance for maker \",\n          TestUtils.uint2str(i)\n        )\n      );\n      TestEvents.eq(\n        quote.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceB[i] + offers[i][TestUtils.Info.makerWants],\n        TestUtils.append(\n          \"Incorrect B balance for maker \",\n          TestUtils.uint2str(i)\n        )\n      );\n    }\n    uint leftMkrWants;\n    {\n      uint leftTkrWants = takerWants -\n        (offers[2][TestUtils.Info.makerGives] +\n          offers[3][TestUtils.Info.makerGives]);\n\n      leftMkrWants =\n        (offers[1][TestUtils.Info.makerWants] * leftTkrWants) /\n        offers[1][TestUtils.Info.makerGives];\n\n      TestEvents.eq(\n        base.balanceOf(address(makers.getMaker(1))),\n        balances.makersBalanceA[1] - leftTkrWants,\n        \"Incorrect A balance for maker 1\"\n      );\n    }\n\n    TestEvents.eq(\n      quote.balanceOf(address(makers.getMaker(1))),\n      balances.makersBalanceB[1] + leftMkrWants,\n      \"Incorrect B balance for maker 1\"\n    );\n\n    // Checking taker balance\n    TestEvents.eq(\n      base.balanceOf(address(taker)), // actual\n      balances.takerBalanceA +\n        takerWants -\n        TestUtils.getFee(mgv, address(base), address(quote), takerWants), // expected\n      \"incorrect taker A balance\"\n    );\n\n    TestEvents.eq(\n      takerGot,\n      takerWants -\n        TestUtils.getFee(mgv, address(base), address(quote), takerWants),\n      \"Incorrect declared takerGot\"\n    );\n\n    uint shouldGive = (offers[3][TestUtils.Info.makerWants] +\n      offers[2][TestUtils.Info.makerWants] +\n      leftMkrWants);\n    TestEvents.eq(\n      quote.balanceOf(address(taker)), // actual\n      balances.takerBalanceB - shouldGive, // expected\n      \"incorrect taker B balance\"\n    );\n\n    TestEvents.eq(takerGave, shouldGive, \"Incorrect declared takerGave\");\n\n    // Checking DEX Fee Balance\n    TestEvents.eq(\n      base.balanceOf(TestUtils.adminOf(mgv)), //actual\n      balances.mgvBalanceFees +\n        TestUtils.getFee(mgv, address(base), address(quote), takerWants), //expected\n      \"incorrect Mangrove balances\"\n    );\n  }\n}\n"
    },
    "contracts/Tests/Integration/AMM.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"hardhat/console.sol\";\nimport \"../../MgvLib.sol\";\nimport \"../Toolbox/TestUtils.sol\";\n\nimport \"../Agents/TestToken.sol\";\nimport \"../Agents/TestDelegateTaker.sol\";\nimport \"../Agents/OfferManager.sol\";\nimport \"../Agents/UniSwapMaker.sol\";\n\ncontract AMM_Test is HasMgvEvents {\n  using P.Global for P.Global.t;\n\n  AbstractMangrove mgv;\n  AbstractMangrove invMgv;\n  TestToken tk0;\n  TestToken tk1;\n\n  receive() external payable {}\n\n  function a_deployToken_beforeAll() public {\n    //console.log(\"IN BEFORE ALL\");\n    tk0 = TokenSetup.setup(\"tk0\", \"$tk0\");\n    tk1 = TokenSetup.setup(\"tk1\", \"$tk1\");\n\n    TestUtils.not0x(address(tk0));\n    TestUtils.not0x(address(tk1));\n\n    Display.register(address(0), \"NULL_ADDRESS\");\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"AMM_Test\");\n    Display.register(address(tk0), \"tk0\");\n    Display.register(address(tk1), \"tk1\");\n  }\n\n  function b_deployMgv_beforeAll() public {\n    mgv = MgvSetup.setup(tk0, tk1);\n    Display.register(address(mgv), \"Mgv\");\n    TestUtils.not0x(address(mgv));\n    //mgv.setFee(address(tk0), address(tk1), 300);\n\n    invMgv = MgvSetup.setup(tk0, tk1, true);\n    Display.register(address(invMgv), \"InvMgv\");\n    TestUtils.not0x(address(invMgv));\n    //invMgv.setFee(address(tk0), address(tk1), 300);\n  }\n\n  function prepare_offer_manager()\n    internal\n    returns (\n      OfferManager,\n      TestDelegateTaker,\n      TestDelegateTaker\n    )\n  {\n    OfferManager mgr = new OfferManager(mgv, invMgv);\n    Display.register(address(mgr), \"OfrMgr\");\n\n    TestDelegateTaker tkr = new TestDelegateTaker(mgr, tk0, tk1);\n    TestDelegateTaker _tkr = new TestDelegateTaker(mgr, tk1, tk0);\n    Display.register(address(tkr), \"Taker (tk0,tk1)\");\n    Display.register(address(_tkr), \"Taker (tk1,tk0)\");\n    bool noRevert0;\n    (noRevert0, ) = address(_tkr).call{value: 1 ether}(\"\");\n    bool noRevert1;\n    (noRevert1, ) = address(tkr).call{value: 1 ether}(\"\");\n    require(noRevert1 && noRevert0);\n\n    TestMaker maker = MakerSetup.setup(mgv, address(tk0), address(tk1));\n    Display.register(address(maker), \"Maker\");\n    tk0.mint(address(maker), 10 ether);\n    (bool success, ) = address(maker).call{gas: gasleft(), value: 10 ether}(\"\");\n    require(success);\n    maker.provisionMgv(10 ether);\n    maker.approveMgv(tk0, 10 ether);\n    maker.newOffer({\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 50_000,\n      pivotId: 0\n    });\n    maker.newOffer({\n      wants: 1 ether,\n      gives: 0.8 ether,\n      gasreq: 80_000,\n      pivotId: 1\n    });\n    maker.newOffer({\n      wants: 0.5 ether,\n      gives: 1 ether,\n      gasreq: 90_000,\n      pivotId: 72\n    });\n    return (mgr, tkr, _tkr);\n  }\n\n  function check_logs(address mgr, bool inverted) internal {\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(\n      address(tk0),\n      address(tk1),\n      3,\n      address(mgr),\n      1 ether,\n      0.5 ether\n    );\n    emit OfferSuccess(\n      address(tk0),\n      address(tk1),\n      2,\n      address(mgr),\n      0.8 ether,\n      1 ether\n    );\n    AbstractMangrove MGV = mgv;\n    if (inverted) {\n      TestEvents.expectFrom(address(invMgv));\n      MGV = invMgv;\n    }\n    (P.Global.t global, ) = MGV.config(address(0), address(0));\n    emit OfferWrite(\n      address(tk1),\n      address(tk0),\n      mgr,\n      1.2 ether,\n      1.2 ether,\n      global.gasprice(),\n      100_000,\n      1,\n      0\n    );\n    emit OfferSuccess(\n      address(tk1),\n      address(tk0),\n      1,\n      address(mgr),\n      1.2 ether,\n      1.2 ether\n    );\n    TestEvents.expectFrom(address(mgv));\n\n    (P.Global.t cfg, ) = mgv.config(address(0), address(0));\n    emit OfferWrite(\n      address(tk0),\n      address(tk1),\n      mgr,\n      0.6 ether,\n      0.6 ether,\n      cfg.gasprice(),\n      100_000,\n      4,\n      0\n    );\n  }\n\n  function offer_manager_test() public {\n    (\n      OfferManager mgr,\n      TestDelegateTaker tkr,\n      TestDelegateTaker _tkr\n    ) = prepare_offer_manager();\n    tk1.mint(address(tkr), 5 ether);\n    tk0.mint(address(_tkr), 5 ether);\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n\n    tkr.delegateOrder(mgr, 3 ether, 3 ether, mgv, false); // (A,B) order\n\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5); // taker has more A\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 2);\n    //Display.logBalances(tk0, tk1, address(taker));\n\n    _tkr.delegateOrder(mgr, 1.8 ether, 1.8 ether, mgv, false); // (B,A) order\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 2);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n\n    check_logs(address(mgr), false);\n  }\n\n  function inverted_offer_manager_test() public {\n    (\n      OfferManager mgr,\n      TestDelegateTaker tkr,\n      TestDelegateTaker _tkr\n    ) = prepare_offer_manager();\n\n    tk1.mint(address(tkr), 5 ether);\n    //tk0.mint(address(_taker), 5 ether);\n    tk0.addAdmin(address(_tkr)); // to test flashloan on the taker side\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n\n    tkr.delegateOrder(mgr, 3 ether, 3 ether, mgv, true); // (A,B) order, residual posted on invertedMgv(B,A)\n\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5); // taker has more A\n    TestUtils.logOfferBook(invMgv, address(tk1), address(tk0), 2);\n    Display.logBalances([address(tk0), address(tk1)], address(tkr));\n\n    _tkr.delegateOrder(mgr, 1.8 ether, 1.8 ether, invMgv, false); // (B,A) FlashTaker order\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    TestUtils.logOfferBook(invMgv, address(tk1), address(tk0), 2);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n    check_logs(address(mgr), true);\n  }\n\n  function uniswap_like_maker_test() public {\n    UniSwapMaker amm = new UniSwapMaker(mgv, 100, 3); // creates the amm\n\n    Display.register(address(amm), \"UnisWapMaker\");\n    Display.register(address(this), \"TestRunner\");\n\n    tk1.mint(address(amm), 1000 ether);\n    tk0.mint(address(amm), 500 ether);\n\n    mgv.fund{value: 5 ether}(address(amm));\n\n    tk1.mint(address(this), 5 ether);\n    tk1.approve(address(mgv), 2**160 - 1);\n\n    tk0.mint(address(this), 5 ether);\n    tk0.approve(address(mgv), 2**160 - 1);\n\n    amm.newMarket(address(tk0), address(tk1));\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 1);\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 1);\n\n    mgv.marketOrder(address(tk0), address(tk1), 3 ether, 2**160 - 1, true);\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 1);\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 1);\n  }\n}\n"
    },
    "contracts/Tests/Agents/UniSwapMaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"./TestToken.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport {IMaker} from \"../../MgvLib.sol\";\n\n// Mangrove must be provisioned in the name of UniSwapMaker\n// UniSwapMaker must have ERC20 credit in tk0 and tk1 and these credits should not be shared (since contract is memoryless)\ncontract UniSwapMaker is IMaker {\n  AbstractMangrove mgv;\n  address private admin;\n  uint gasreq = 80_000;\n  uint8 share; // [1,100] for 1/1 to 1/100\n  uint8 fee; // per 1000\n  uint32 ofr0;\n  uint32 ofr1;\n\n  constructor(\n    AbstractMangrove _mgv,\n    uint _share,\n    uint _fee\n  ) {\n    require(_share > 1, \"Invalid parameters\");\n    require(uint8(_fee) == _fee && uint8(_share) == _share);\n    admin = msg.sender;\n    mgv = _mgv; // Abstract Mangrove\n    share = uint8(_share);\n    fee = uint8(_fee);\n  }\n\n  receive() external payable {}\n\n  function setParams(uint _fee, uint _share) external {\n    require(_share > 1, \"Invalid parameters\");\n    require(uint8(_fee) == _fee && uint8(_share) == _share);\n    if (msg.sender == admin) {\n      fee = uint8(_fee);\n      share = uint8(_share);\n    }\n  }\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function makerExecute(ML.SingleOrder calldata order)\n    external\n    override\n    returns (bytes32 avoid_compilation_warning)\n  {\n    avoid_compilation_warning;\n    require(msg.sender == address(mgv), \"Illegal call\");\n    emit Execute(\n      msg.sender,\n      order.outbound_tkn, // takerWants\n      order.inbound_tkn, // takerGives\n      order.offerId,\n      order.wants,\n      order.gives\n    );\n    return \"\";\n  }\n\n  // newPrice(makerWants,makerGives)\n  function newPrice(uint pool0, uint pool1) internal view returns (uint, uint) {\n    uint newGives = pool1 / share; // share = 100 for 1%\n    uint x = (newGives * pool0) / (pool1 - newGives); // forces newGives < poolGives\n    uint newWants = (1000 * x) / (1000 - fee); // fee < 1000\n    return (newWants, newGives);\n  }\n\n  function newMarket(address tk0, address tk1) public {\n    TestToken(tk0).approve(address(mgv), 2**256 - 1);\n    TestToken(tk1).approve(address(mgv), 2**256 - 1);\n\n    uint pool0 = TestToken(tk0).balanceOf(address(this));\n    uint pool1 = TestToken(tk1).balanceOf(address(this));\n\n    (uint wants0, uint gives1) = newPrice(pool0, pool1);\n    (uint wants1, uint gives0) = newPrice(pool1, pool0);\n    ofr0 = uint32(mgv.newOffer(tk0, tk1, wants0, gives1, gasreq, 0, 0));\n    ofr1 = uint32(mgv.newOffer(tk1, tk0, wants1, gives0, gasreq, 0, 0)); // natural OB\n  }\n\n  function makerPosthook(ML.SingleOrder calldata order, ML.OrderResult calldata)\n    external\n    override\n  {\n    // taker has paid maker\n    require(msg.sender == address(mgv)); // may not be necessary\n    uint pool0 = TestToken(order.inbound_tkn).balanceOf(address(this)); // pool0 has increased\n    uint pool1 = TestToken(order.outbound_tkn).balanceOf(address(this)); // pool1 has decreased\n\n    (uint newWants, uint newGives) = newPrice(pool0, pool1);\n\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      newWants,\n      newGives,\n      gasreq,\n      0, // gasprice\n      0, // best pivot\n      order.offerId // the offer that was executed\n    );\n    // for all pairs in opposite Dex:\n    uint OFR = ofr0;\n    if (order.offerId == ofr0) {\n      OFR = ofr1;\n    }\n\n    (newWants, newGives) = newPrice(pool1, pool0);\n    mgv.updateOffer(\n      order.inbound_tkn,\n      order.outbound_tkn,\n      newWants,\n      newGives,\n      gasreq,\n      0,\n      OFR,\n      OFR\n    );\n  }\n}\n"
    },
    "contracts/Tests/Gatekeeping.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\ncontract NotAdmin {\n  AbstractMangrove mgv;\n\n  constructor(AbstractMangrove _mgv) {\n    mgv = _mgv;\n  }\n\n  function setGasprice(uint value) public {\n    mgv.setGasprice(value);\n  }\n\n  function setFee(\n    address base,\n    address quote,\n    uint fee\n  ) public {\n    mgv.setFee(base, quote, fee);\n  }\n\n  function setGovernance(address newGovernance) public {\n    mgv.setGovernance(newGovernance);\n  }\n\n  function kill() public {\n    mgv.kill();\n  }\n\n  function activate(\n    address base,\n    address quote,\n    uint fee,\n    uint density,\n    uint offer_gasbase\n  ) public {\n    mgv.activate(base, quote, fee, density, offer_gasbase);\n  }\n\n  function setGasbase(\n    address base,\n    address quote,\n    uint offer_gasbase\n  ) public {\n    mgv.setGasbase(base, quote, offer_gasbase);\n  }\n\n  function setGasmax(uint value) public {\n    mgv.setGasmax(value);\n  }\n\n  function setDensity(\n    address base,\n    address quote,\n    uint value\n  ) public {\n    mgv.setDensity(base, quote, value);\n  }\n\n  function setVault(address value) public {\n    mgv.setVault(value);\n  }\n\n  function setMonitor(address value) public {\n    mgv.setMonitor(value);\n  }\n}\n\ncontract Deployer {\n  AbstractMangrove mgv;\n\n  function deploy() public returns (AbstractMangrove) {\n    mgv = MgvSetup.deploy(msg.sender);\n    return mgv;\n  }\n\n  function setGovernance(address governance) public {\n    mgv.setGovernance(governance);\n  }\n}\n\n// In these tests, the testing contract is the market maker.\ncontract Gatekeeping_Test is IMaker, HasMgvEvents {\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMaker mkr;\n  TestMaker dual_mkr;\n  address base;\n  address quote;\n\n  function gov_is_not_sender_test() public {\n    Deployer deployer = new Deployer();\n    AbstractMangrove _mgv = deployer.deploy();\n\n    TestEvents.eq(\n      _mgv.governance(),\n      address(this),\n      \"governance should return this\"\n    );\n  }\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    tkr = TakerSetup.setup(mgv, base, quote);\n    mkr = MakerSetup.setup(mgv, base, quote);\n    dual_mkr = MakerSetup.setup(mgv, quote, base);\n\n    payable(tkr).transfer(10 ether);\n    payable(mkr).transfer(10 ether);\n    payable(dual_mkr).transfer(10 ether);\n\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    mkr.provisionMgv(5 ether);\n    dual_mkr.provisionMgv(5 ether);\n\n    baseT.mint(address(this), 2 ether);\n    quoteT.mint(address(tkr), 1 ether);\n    quoteT.mint(address(mkr), 1 ether);\n    baseT.mint(address(dual_mkr), 1 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n    tkr.approveMgv(quoteT, 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(tkr), \"taker[$A,$B]\");\n    Display.register(address(dual_mkr), \"maker[$B,$A]\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  /* # Test Config */\n\n  function gov_cant_be_zero_test() public {\n    try mgv.setGovernance(address(0)) {\n      TestEvents.fail(\"setting gov to 0 should be impossible\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/gov/not0\");\n    }\n  }\n\n  function gov_can_transfer_rights_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    mgv.setGovernance(address(notAdmin));\n\n    try mgv.setFee(base, quote, 0) {\n      TestEvents.fail(\"testing contracts should no longer be admin\");\n    } catch {}\n\n    try notAdmin.setFee(base, quote, 1) {} catch {\n      TestEvents.fail(\"notAdmin should have been given admin rights\");\n    }\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit SetGovernance(address(notAdmin));\n    emit SetFee(base, quote, 1);\n  }\n\n  function only_gov_can_set_fee_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setFee(base, quote, 0) {\n      TestEvents.fail(\"nonadmin cannot set fee\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_density_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setDensity(base, quote, 0) {\n      TestEvents.fail(\"nonadmin cannot set density\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function set_zero_density_test() public {\n    try mgv.setDensity(base, quote, 0) {} catch Error(string memory) {\n      TestEvents.fail(\"setting density to 0 should work\");\n    }\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit SetDensity(base, quote, 0);\n  }\n\n  function only_gov_can_kill_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.kill() {\n      TestEvents.fail(\"nonadmin cannot kill\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function killing_updates_config_test() public {\n    (P.Global.t global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(\n      !global.dead(),\n      \"mgv should not be dead \"\n    );\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(global.dead(), \"mgv should be dead \");\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit Kill();\n  }\n\n  function kill_is_idempotent_test() public {\n    (P.Global.t global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(\n      !global.dead(),\n      \"mgv should not be dead \"\n    );\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(global.dead(), \"mgv should be dead\");\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(\n      global.dead(),\n      \"mgv should still be dead\"\n    );\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit Kill();\n    emit Kill();\n  }\n\n  function only_gov_can_set_vault_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setVault(address(this)) {\n      TestEvents.fail(\"nonadmin cannot set vault\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_monitor_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setMonitor(address(this)) {\n      TestEvents.fail(\"nonadmin cannot set monitor\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_active_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.activate(quote, base, 0, 100, 0) {\n      TestEvents.fail(\"nonadmin cannot set active\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_gasprice_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setGasprice(0) {\n      TestEvents.fail(\"nonadmin cannot set gasprice\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_gasmax_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setGasmax(0) {\n      TestEvents.fail(\"nonadmin cannot set gasmax\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_gasbase_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setGasbase(base, quote, 0) {\n      TestEvents.fail(\"nonadmin cannot set gasbase\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function empty_mgv_ok_test() public {\n    try tkr.marketOrder(0, 0) {} catch {\n      TestEvents.fail(\"market order on empty mgv should not fail\");\n    }\n    // Logging tests\n  }\n\n  function set_fee_ceiling_test() public {\n    try mgv.setFee(base, quote, 501) {} catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/fee/<=500\");\n    }\n  }\n\n  function set_density_ceiling_test() public {\n    try mgv.setDensity(base, quote, uint(type(uint112).max) + 1) {\n      TestEvents.fail(\"density above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/density/112bits\");\n    }\n  }\n\n  function set_gasprice_ceiling_test() public {\n    try mgv.setGasprice(uint(type(uint16).max) + 1) {\n      TestEvents.fail(\"gasprice above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/gasprice/16bits\");\n    }\n  }\n\n  function set_zero_gasbase_test() public {\n    try mgv.setGasbase(base, quote, 0) {} catch Error(string memory) {\n      TestEvents.fail(\"setting gasbases to 0 should work\");\n    }\n  }\n\n  function set_gasbase_ceiling_test() public {\n    try mgv.setGasbase(base, quote, uint(type(uint24).max) + 1) {\n      TestEvents.fail(\"offer_gasbase above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/offer_gasbase/24bits\");\n    }\n  }\n\n  function set_gasmax_ceiling_test() public {\n    try mgv.setGasmax(uint(type(uint24).max) + 1) {\n      TestEvents.fail(\"gasmax above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/gasmax/24bits\");\n    }\n  }\n\n  function makerWants_wider_than_96_bits_fails_newOffer_test() public {\n    try mkr.newOffer(2**96, 1 ether, 10_000, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/wants/96bits\", \"wrong revert reason\");\n    }\n  }\n\n  function retractOffer_wrong_owner_fails_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n    try mgv.retractOffer(base, quote, ofr, false) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/retractOffer/unauthorized\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGives_wider_than_96_bits_fails_newOffer_test() public {\n    try mkr.newOffer(1, 2**96, 10_000, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gives/96bits\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_wider_than_24_bits_fails_newOffer_test() public {\n    try mkr.newOffer(1, 1, 2**24, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasreq/tooHigh\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_bigger_than_gasmax_fails_newOffer_test() public {\n    (P.Global.t cfg, ) = mgv.config(base, quote);\n    try mkr.newOffer(1, 1, cfg.gasmax() + 1, 0) {\n      TestEvents.fail(\"Offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasreq/tooHigh\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_at_gasmax_succeeds_newOffer_test() public {\n    (P.Global.t cfg, ) = mgv.config(base, quote);\n    try\n      mkr.newOffer(1 ether, 1 ether, cfg.gasmax(), 0)\n    returns (uint ofr) {\n      TestEvents.check(\n        mgv.isLive(mgv.offers(base, quote, ofr)),\n        \"Offer should have been inserted\"\n      );\n      // Logging tests\n      TestEvents.expectFrom(address(mgv));\n      emit OfferWrite(\n        address(base),\n        address(quote),\n        address(mkr),\n        1 ether, //base\n        1 ether, //quote\n        cfg.gasprice(), //gasprice\n        cfg.gasmax(), //gasreq\n        ofr, //ofrId\n        0 // prev\n      );\n      emit Debit(\n        address(mkr),\n        TestUtils.getProvision(\n          mgv,\n          address(base),\n          address(quote),\n          cfg.gasmax(),\n          0\n        )\n      );\n    } catch {\n      TestEvents.fail(\"Offer at gasmax should pass\");\n    }\n  }\n\n  function makerGasreq_lower_than_density_fails_newOffer_test() public {\n    (, P.Local.t cfg) = mgv.config(base, quote);\n    uint amount = (1 + cfg.offer_gasbase()) *\n      cfg.density();\n    try mkr.newOffer(amount - 1, amount - 1, 1, 0) {\n      TestEvents.fail(\"Offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/density/tooLow\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_at_density_suceeds_test() public {\n    (P.Global.t glob, P.Local.t cfg) = mgv.config(base, quote);\n    uint amount = (1 + cfg.offer_gasbase()) *\n      cfg.density();\n    try mkr.newOffer(amount, amount, 1, 0) returns (uint ofr) {\n      TestEvents.check(\n        mgv.isLive(mgv.offers(base, quote, ofr)),\n        \"Offer should have been inserted\"\n      );\n      // Logging tests\n      TestEvents.expectFrom(address(mgv));\n      emit OfferWrite(\n        address(base),\n        address(quote),\n        address(mkr),\n        amount, //base\n        amount, //quote\n        glob.gasprice(), //gasprice\n        1, //gasreq\n        ofr, //ofrId\n        0 // prev\n      );\n      emit Debit(\n        address(mkr),\n        TestUtils.getProvision(mgv, address(base), address(quote), 1, 0)\n      );\n    } catch {\n      TestEvents.fail(\"Offer at density should pass\");\n    }\n  }\n\n  function makerGasprice_wider_than_16_bits_fails_newOffer_test() public {\n    try mkr.newOffer(1, 1, 1, 2**16, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasprice/16bits\", \"wrong revert reason\");\n    }\n  }\n\n  function takerWants_wider_than_160_bits_fails_marketOrder_test() public {\n    try tkr.marketOrder(2**160, 0) {\n      TestEvents.fail(\"takerWants > 160bits, order should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/mOrder/takerWants/160bits\", \"wrong revert reason\");\n    }\n  }\n\n  function takerWants_above_96bits_fails_snipes_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [\n      ofr,\n      uint(type(uint96).max) + 1,\n      type(uint96).max,\n      type(uint).max\n    ];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipes with takerWants > 96bits should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/snipes/takerWants/96bits\");\n    }\n  }\n\n  function takerGives_above_96bits_fails_snipes_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [\n      ofr,\n      type(uint96).max,\n      uint(type(uint96).max) + 1,\n      type(uint).max\n    ];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipes with takerGives > 96bits should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/snipes/takerGives/96bits\");\n    }\n  }\n\n  function initial_allowance_is_zero_test() public {\n    TestEvents.eq(\n      mgv.allowances(base, quote, address(tkr), address(this)),\n      0,\n      \"initial allowance should be 0\"\n    );\n  }\n\n  function cannot_snipesFor_for_without_allowance_test() public {\n    TestToken(base).mint(address(mkr), 1 ether);\n    mkr.approveMgv(TestToken(base), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 300_000];\n    try mgv.snipesFor(base, quote, targets, true, address(tkr)) {\n      TestEvents.fail(\"snipeFor should fail without allowance\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/lowAllowance\");\n    }\n  }\n\n  function cannot_marketOrderFor_for_without_allowance_test() public {\n    TestToken(base).mint(address(mkr), 1 ether);\n    mkr.approveMgv(TestToken(base), 1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    try mgv.marketOrderFor(base, quote, 1 ether, 1 ether, true, address(tkr)) {\n      TestEvents.fail(\"marketOrderfor should fail without allowance\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/lowAllowance\");\n    }\n  }\n\n  function can_marketOrderFor_for_with_allowance_test() public {\n    TestToken(base).mint(address(mkr), 1 ether);\n    mkr.approveMgv(TestToken(base), 1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    tkr.approveSpender(address(this), 1.2 ether);\n    uint takerGot;\n    (takerGot, , ) = mgv.marketOrderFor(\n      base,\n      quote,\n      1 ether,\n      1 ether,\n      true,\n      address(tkr)\n    );\n    TestEvents.eq(\n      mgv.allowances(base, quote, address(tkr), address(this)),\n      0.2 ether,\n      \"allowance should have correctly reduced\"\n    );\n  }\n\n  /* # Internal IMaker setup */\n\n  bytes trade_cb;\n  bytes posthook_cb;\n\n  // maker's trade fn for the mgv\n  function makerExecute(ML.SingleOrder calldata)\n    external\n    override\n    returns (bytes32 ret)\n  {\n    ret; // silence unused function parameter\n    bool success;\n    if (trade_cb.length > 0) {\n      (success, ) = address(this).call(trade_cb);\n      require(success, \"makerExecute callback must work\");\n    }\n    return \"\";\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {\n    bool success;\n    order; // silence compiler warning\n    if (posthook_cb.length > 0) {\n      (success, ) = address(this).call(posthook_cb);\n      bool tradeResult = (result.mgvData == \"mgv/tradeSuccess\");\n      require(success == tradeResult, \"makerPosthook callback must work\");\n    }\n  }\n\n  /* # Reentrancy */\n\n  /* New Offer failure */\n\n  function newOfferKO() external {\n    try mgv.newOffer(base, quote, 1 ether, 1 ether, 30_000, 0, 0) {\n      TestEvents.fail(\"newOffer on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function newOffer_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.newOfferKO.selector);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* New Offer success */\n\n  // ! may be called with inverted _base and _quote\n  function newOfferOK(address _base, address _quote) external {\n    mgv.newOffer(_base, _quote, 1 ether, 1 ether, 30_000, 0, 0);\n  }\n\n  function newOffer_on_reentrancy_succeeds_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 200_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.newOfferOK.selector, quote, base);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(quote, base) == 1, \"newOffer on swapped pair must work\");\n  }\n\n  function newOffer_on_posthook_succeeds_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 200_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(this.newOfferOK.selector, base, quote);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(base, quote) == 2, \"newOffer on posthook must work\");\n  }\n\n  /* Update offer failure */\n\n  function updateOfferKO(uint ofr) external {\n    try mgv.updateOffer(base, quote, 1 ether, 2 ether, 35_000, 0, 0, ofr) {\n      TestEvents.fail(\"update offer on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function updateOffer_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.updateOfferKO.selector, ofr);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Update offer success */\n\n  // ! may be called with inverted _base and _quote\n  function updateOfferOK(\n    address _base,\n    address _quote,\n    uint ofr\n  ) external {\n    mgv.updateOffer(_base, _quote, 1 ether, 2 ether, 35_000, 0, 0, ofr);\n  }\n\n  function updateOffer_on_reentrancy_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(quote, base, 1 ether, 1 ether, 100_000, 0, 0);\n\n    trade_cb = abi.encodeWithSelector(\n      this.updateOfferOK.selector,\n      quote,\n      base,\n      other_ofr\n    );\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 400_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    (, P.OfferDetailStruct memory od) = mgv.offerInfo(quote, base, other_ofr);\n    require(od.gasreq == 35_000, \"updateOffer on swapped pair must work\");\n  }\n\n  function updateOffer_on_posthook_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.updateOfferOK.selector,\n      base,\n      quote,\n      other_ofr\n    );\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 300_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    (, P.OfferDetailStruct memory od) = mgv.offerInfo(base, quote, other_ofr);\n    require(od.gasreq == 35_000, \"updateOffer on posthook must work\");\n  }\n\n  /* Cancel Offer failure */\n\n  function retractOfferKO(uint id) external {\n    try mgv.retractOffer(base, quote, id, false) {\n      TestEvents.fail(\"retractOffer on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function retractOffer_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.retractOfferKO.selector, ofr);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Cancel Offer success */\n\n  function retractOfferOK(\n    address _base,\n    address _quote,\n    uint id\n  ) external {\n    uint collected = mgv.retractOffer(_base, _quote, id, false);\n    TestEvents.eq(\n      collected,\n      0,\n      \"Unexpected collected provision after retract w/o deprovision\"\n    );\n  }\n\n  function retractOffer_on_reentrancy_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(quote, base, 1 ether, 1 ether, 90_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(\n      this.retractOfferOK.selector,\n      quote,\n      base,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 90_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(\n      mgv.best(quote, base) == 0,\n      \"retractOffer on swapped pair must work\"\n    );\n  }\n\n  function retractOffer_on_posthook_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 190_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.retractOfferOK.selector,\n      base,\n      quote,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 90_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(base, quote) == 0, \"retractOffer on posthook must work\");\n  }\n\n  /* Market Order failure */\n\n  function marketOrderKO() external {\n    try mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true) {\n      TestEvents.fail(\"marketOrder on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function marketOrder_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.marketOrderKO.selector);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Market Order Success */\n\n  function marketOrderOK(address _base, address _quote) external {\n    try\n      mgv.marketOrder(_base, _quote, 0.5 ether, 0.5 ether, true)\n    {} catch Error(string memory r) {\n      console.log(\"ERR\", r);\n    }\n  }\n\n  function marketOrder_on_reentrancy_succeeds_test() public {\n    console.log(\n      \"dual mkr offer\",\n      dual_mkr.newOffer(0.5 ether, 0.5 ether, 30_000, 0)\n    );\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 392_000, 0, 0);\n    console.log(\"normal offer\", ofr);\n    trade_cb = abi.encodeWithSelector(this.marketOrderOK.selector, quote, base);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n    require(\n      mgv.best(quote, base) == 0,\n      \"2nd market order must have emptied mgv\"\n    );\n  }\n\n  function marketOrder_on_posthook_succeeds_test() public {\n    uint ofr = mgv.newOffer(base, quote, 0.5 ether, 0.5 ether, 500_000, 0, 0);\n    mgv.newOffer(base, quote, 0.5 ether, 0.5 ether, 200_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.marketOrderOK.selector,\n      base,\n      quote\n    );\n    require(tkr.take(ofr, 0.6 ether), \"take must succeed or test is void\");\n    require(\n      mgv.best(base, quote) == 0,\n      \"2nd market order must have emptied mgv\"\n    );\n  }\n\n  /* Snipe failure */\n\n  function snipesKO(uint id) external {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [id, 1 ether, type(uint96).max, type(uint48).max];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"snipe on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function snipe_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 60_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.snipesKO.selector, ofr);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Snipe success */\n\n  function snipesOK(\n    address _base,\n    address _quote,\n    uint id\n  ) external {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [id, 1 ether, type(uint96).max, type(uint48).max];\n    mgv.snipes(_base, _quote, targets, true);\n  }\n\n  function snipes_on_reentrancy_succeeds_test() public {\n    uint other_ofr = dual_mkr.newOffer(1 ether, 1 ether, 30_000, 0);\n    trade_cb = abi.encodeWithSelector(\n      this.snipesOK.selector,\n      quote,\n      base,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 190_000, 0, 0);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n    require(mgv.best(quote, base) == 0, \"snipe in swapped pair must work\");\n  }\n\n  function snipes_on_posthook_succeeds_test() public {\n    uint other_ofr = mkr.newOffer(1 ether, 1 ether, 30_000, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.snipesOK.selector,\n      base,\n      quote,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 190_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(base, quote) == 0, \"snipe in posthook must work\");\n  }\n\n  function newOffer_on_closed_fails_test() public {\n    mgv.kill();\n    try mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0) {\n      TestEvents.fail(\"newOffer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  /* # Mangrove closed/inactive */\n\n  function take_on_closed_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n\n    mgv.kill();\n    try tkr.take(ofr, 1 ether) {\n      TestEvents.fail(\"take offer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function newOffer_on_inactive_fails_test() public {\n    mgv.deactivate(base, quote);\n    try mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0) {\n      TestEvents.fail(\"newOffer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/inactive\");\n    }\n  }\n\n  function receive_on_closed_fails_test() public {\n    mgv.kill();\n\n    (bool success, bytes memory retdata) = address(mgv).call{value: 10 ether}(\n      \"\"\n    );\n    if (success) {\n      TestEvents.fail(\"receive() should fail on closed market\");\n    } else {\n      string memory r = TestUtils.getReason(retdata);\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function marketOrder_on_closed_fails_test() public {\n    mgv.kill();\n    try tkr.marketOrder(1 ether, 1 ether) {\n      TestEvents.fail(\"marketOrder should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function snipe_on_closed_fails_test() public {\n    mgv.kill();\n    try tkr.take(0, 1 ether) {\n      TestEvents.fail(\"snipe should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function withdraw_on_closed_ok_test() public {\n    mgv.kill();\n    mgv.withdraw(0.1 ether);\n  }\n\n  function retractOffer_on_closed_ok_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n    mgv.kill();\n    mgv.retractOffer(base, quote, ofr, false);\n  }\n\n  function updateOffer_on_closed_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n    mgv.kill();\n    try mgv.updateOffer(base, quote, 1 ether, 1 ether, 0, 0, 0, ofr) {\n      TestEvents.fail(\"update offer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function activation_emits_events_in_order_test() public {\n    mgv.activate(quote, base, 7, 0, 3);\n    TestEvents.expectFrom(address(mgv));\n    emit SetActive(quote, base, true);\n    emit SetFee(quote, base, 7);\n    emit SetDensity(quote, base, 0);\n    emit SetGasbase(quote, base, 3);\n  }\n\n  function updateOffer_on_inactive_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n    mgv.deactivate(base, quote);\n    try mgv.updateOffer(base, quote, 1 ether, 1 ether, 0, 0, 0, ofr) {\n      TestEvents.fail(\"update offer should fail on inactive market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/inactive\");\n      TestEvents.expectFrom(address(mgv));\n      emit SetActive(base, quote, false);\n    }\n  }\n}\n"
    },
    "contracts/Tests/Gas.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract Gas_Test is IMaker {\n  receive() external payable {}\n\n  AbstractMangrove _mgv;\n  TestTaker _tkr;\n  address _base;\n  address _quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    _base = address(baseT);\n    _quote = address(quoteT);\n    _mgv = MgvSetup.setup(baseT, quoteT);\n\n    bool noRevert;\n    (noRevert, ) = address(_mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(this), 2 ether);\n    baseT.approve(address(_mgv), 2 ether);\n    quoteT.approve(address(_mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(_base, \"$A\");\n    Display.register(_quote, \"$B\");\n    Display.register(address(_mgv), \"mgv\");\n\n    _mgv.newOffer(_base, _quote, 1 ether, 1 ether, 100_000, 0, 0);\n    console.log(\"mgv\", address(_mgv));\n\n    _tkr = TakerSetup.setup(_mgv, _base, _quote);\n    quoteT.mint(address(_tkr), 2 ether);\n    _tkr.approveMgv(quoteT, 2 ether);\n    Display.register(address(_tkr), \"Taker\");\n\n    /* set lock to 1 to avoid spurious 15k gas cost */\n    uint ofr = _mgv.newOffer(\n      _base,\n      _quote,\n      0.1 ether,\n      0.1 ether,\n      100_000,\n      0,\n      0\n    );\n    _tkr.take(ofr, 0.1 ether);\n  }\n\n  function getStored()\n    internal\n    view\n    returns (\n      AbstractMangrove,\n      TestTaker,\n      address,\n      address\n    )\n  {\n    return (_mgv, _tkr, _base, _quote);\n  }\n\n  function makerExecute(ML.SingleOrder calldata)\n    external\n    pure\n    override\n    returns (bytes32)\n  {\n    return \"\"; // silence unused function parameter\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {}\n\n  function update_min_move_0_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    uint g = gasleft();\n    mgv.updateOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 1, 1);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function update_full_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    uint g = gasleft();\n    mgv.updateOffer(base, quote, 0.5 ether, 1 ether, 100_001, 0, 1, 1);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function update_min_move_3_offer_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n  }\n\n  function update_min_move_3_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    uint g = gasleft();\n    mgv.updateOffer(base, quote, 1.0 ether, 0.1 ether, 100_00, 0, 1, 1);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function update_min_move_6_offer_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n  }\n\n  function update_min_move_6_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    uint g = gasleft();\n    mgv.updateOffer(base, quote, 1.0 ether, 0.1 ether, 100_00, 0, 1, 1);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function new_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    uint g = gasleft();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 1);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function take_offer_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    uint g = gasleft();\n    tkr.snipe(mgv, base, quote, 1, 1 ether, 1 ether, 100_000);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function partial_take_offer_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    uint g = gasleft();\n    tkr.snipe(mgv, base, quote, 1, 0.5 ether, 0.5 ether, 100_000);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function market_order_1_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    uint g = gasleft();\n    tkr.marketOrder(mgv, base, quote, 1 ether, 1 ether);\n    console.log(\"Gas used\", g - gasleft());\n  }\n\n  function market_order_8_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n  }\n\n  function market_order_8_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    uint g = gasleft();\n    tkr.marketOrder(mgv, base, quote, 2 ether, 2 ether);\n    console.log(\"Gas used\", g - gasleft());\n  }\n}\n"
    },
    "contracts/Tests/InvertedTakerOperations.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../AbstractMangrove.sol\";\nimport {IMaker as IM, MgvLib} from \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\n\n/* The following constructs an ERC20 with a transferFrom callback method,\n   and a TestTaker which throws away any funds received upon getting\n   a callback.\n*/\ncontract InvertedTakerOperations_Test is ITaker, HasMgvEvents {\n  TestToken baseT;\n  TestToken quoteT;\n  address base;\n  address quote;\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  bytes4 takerTrade_bytes;\n  uint baseBalance;\n  uint quoteBalance;\n\n  receive() external payable {}\n\n  function a_beforeAll() public {\n    baseT = TokenSetup.setup(\"A\", \"$A\");\n    quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT, true);\n\n    mkr = MakerSetup.setup(mgv, base, quote);\n\n    payable(mkr).transfer(10 ether);\n    mkr.provisionMgv(1 ether);\n    mkr.approveMgv(baseT, 10 ether);\n\n    baseT.mint(address(mkr), 5 ether);\n    quoteT.mint(address(this), 5 ether);\n    quoteT.approve(address(mgv), 5 ether);\n    baseBalance = baseT.balanceOf(address(this));\n    quoteBalance = quoteT.balanceOf(address(this));\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker\");\n    Display.register(mgv.vault(), \"vault\");\n  }\n\n  uint toPay;\n\n  function checkPay(\n    address,\n    address,\n    uint totalGives\n  ) external {\n    TestEvents.eq(\n      toPay,\n      totalGives,\n      \"totalGives should be the sum of taker flashborrows\"\n    );\n  }\n\n  bool skipCheck;\n\n  function takerTrade(\n    address _base,\n    address _quote,\n    uint totalGot,\n    uint totalGives\n  ) public override {\n    require(msg.sender == address(mgv));\n    if (!skipCheck) {\n      TestEvents.eq(\n        baseBalance + totalGot,\n        baseT.balanceOf(address(this)),\n        \"totalGot should be sum of maker flashloans\"\n      );\n    }\n    (bool success, ) = address(this).call(\n      abi.encodeWithSelector(takerTrade_bytes, _base, _quote, totalGives)\n    );\n    require(success, \"TradeFail\");\n  }\n\n  function taker_gets_sum_of_borrows_in_execute_test() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.checkPay.selector;\n    toPay = 0.2 ether;\n    (, uint gave, ) = mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true);\n    TestEvents.eq(\n      quoteBalance - gave,\n      quoteT.balanceOf(address(this)),\n      \"totalGave should be sum of taker flashborrows\"\n    );\n  }\n\n  function revertTrade(\n    address,\n    address,\n    uint\n  ) external pure {\n    require(false);\n  }\n\n  function taker_reverts_during_trade_test() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint _ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.revertTrade.selector;\n    skipCheck = true;\n    try mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true) {\n      TestEvents.fail(\"Market order should have reverted\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(\"TradeFail\", reason, \"Unexpected throw\");\n      TestEvents.check(\n        TestUtils.hasOffer(mgv, address(base), address(quote), ofr),\n        \"Offer 1 should be present\"\n      );\n      TestEvents.check(\n        TestUtils.hasOffer(mgv, address(base), address(quote), _ofr),\n        \"Offer 2 should be present\"\n      );\n    }\n  }\n\n  function refuseFeeTrade(\n    address _base,\n    address,\n    uint\n  ) external {\n    IERC20(_base).approve(address(mgv), 0);\n  }\n\n  function refusePayTrade(\n    address,\n    address _quote,\n    uint\n  ) external {\n    IERC20(_quote).approve(address(mgv), 0);\n  }\n\n  function taker_refuses_to_deliver_during_trade_test() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.refusePayTrade.selector;\n    try mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true) {\n      TestEvents.fail(\"Market order should have reverted\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(\n        reason,\n        \"mgv/takerFailToPayTotal\",\n        \"Unexpected throw message\"\n      );\n    }\n  }\n\n  function vault_receives_quote_tokens_if_maker_is_blacklisted_for_quote_test()\n    public\n  {\n    takerTrade_bytes = this.noop.selector;\n    quoteT.blacklists(address(mkr));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    address vault = address(1);\n    mgv.setVault(vault);\n    uint vaultBal = quoteT.balanceOf(vault);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n\n    (uint successes, , , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 1, \"Trade should succeed\");\n    TestEvents.eq(\n      quoteT.balanceOf(vault) - vaultBal,\n      1 ether,\n      \"Vault balance should have increased\"\n    );\n  }\n\n  function noop(\n    address,\n    address,\n    uint\n  ) external {}\n\n  function reenter(\n    address _base,\n    address _quote,\n    uint\n  ) external {\n    takerTrade_bytes = this.noop.selector;\n    skipCheck = true;\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [uint(2), 0.1 ether, 0.1 ether, 100_000];\n    (uint successes, uint totalGot, uint totalGave, ) = mgv.snipes(\n      _base,\n      _quote,\n      targets,\n      true\n    );\n    TestEvents.check(successes == 1, \"Snipe on reentrancy should succeed\");\n    TestEvents.eq(totalGot, 0.1 ether, \"Incorrect totalGot\");\n    TestEvents.eq(totalGave, 0.1 ether, \"Incorrect totalGave\");\n  }\n\n  function taker_snipe_mgv_during_trade_test() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.reenter.selector;\n    (uint got, uint gave, ) = mgv.marketOrder(\n      base,\n      quote,\n      0.1 ether,\n      0.1 ether,\n      true\n    );\n    TestEvents.eq(\n      quoteBalance - gave - 0.1 ether,\n      quoteT.balanceOf(address(this)),\n      \"Incorrect transfer (gave) during reentrancy\"\n    );\n    TestEvents.eq(\n      baseBalance + got + 0.1 ether,\n      baseT.balanceOf(address(this)),\n      \"Incorrect transfer (got) during reentrancy\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(base, quote, 1, address(this), 0.1 ether, 0.1 ether);\n    emit OfferSuccess(base, quote, 2, address(this), 0.1 ether, 0.1 ether);\n  }\n\n  function taker_pays_back_correct_amount_1_test() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint bal = quoteT.balanceOf(address(this));\n    takerTrade_bytes = this.noop.selector;\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.05 ether, 0.05 ether, 100_000];\n    mgv.snipes(base, quote, targets, true);\n    TestEvents.eq(\n      quoteT.balanceOf(address(this)),\n      bal - 0.05 ether,\n      \"wrong taker balance\"\n    );\n  }\n\n  function taker_pays_back_correct_amount_2_test() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint bal = quoteT.balanceOf(address(this));\n    takerTrade_bytes = this.noop.selector;\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.02 ether, 0.02 ether, 100_000];\n    mgv.snipes(base, quote, targets, true);\n    TestEvents.eq(\n      quoteT.balanceOf(address(this)),\n      bal - 0.02 ether,\n      \"wrong taker balance\"\n    );\n  }\n}\n"
    },
    "contracts/Tests/MakerPosthook.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\n\ncontract MakerPosthook_Test is IMaker, HasMgvEvents {\n  using P.Offer for P.Offer.t;\n  using P.OfferDetail for P.OfferDetail.t;\n  using P.Global for P.Global.t;\n  using P.Local for P.Local.t;\n\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestToken baseT;\n  TestToken quoteT;\n  address base;\n  address quote;\n  uint gasreq = 200_000;\n  uint ofr;\n  bytes4 posthook_bytes;\n  uint _gasprice = 50; // will cover for a gasprice of 50 gwei/gas uint\n  uint weiBalMaker;\n  bool abort = false;\n  bool willFail = false;\n  bool makerRevert = false;\n  bool called;\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  receive() external payable {}\n\n  function tradeRevert(bytes32 data) internal pure {\n    bytes memory revData = new bytes(32);\n    assembly {\n      mstore(add(revData, 32), data)\n      revert(add(revData, 32), 32)\n    }\n  }\n\n  function makerExecute(MgvLib.SingleOrder calldata trade)\n    external\n    override\n    returns (bytes32)\n  {\n    require(msg.sender == address(mgv));\n    if (makerRevert) {\n      tradeRevert(\"NOK\");\n    }\n    if (abort) {\n      return \"NOK\";\n    }\n    emit Execute(\n      msg.sender,\n      trade.outbound_tkn,\n      trade.inbound_tkn,\n      trade.offerId,\n      trade.wants,\n      trade.gives\n    );\n    //MakerTrade.returnWithData(\"OK\");\n    return \"\";\n  }\n\n  function renew_offer_at_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      order.offerId,\n      order.offerId\n    );\n  }\n\n  function update_gas_offer_at_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      order.offerId,\n      order.offerId\n    );\n  }\n\n  function failer_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    TestEvents.fail(\"Posthook should not be called\");\n  }\n\n  function retractOffer_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    uint bal = mgv.balanceOf(address(this));\n    mgv.retractOffer(base, quote, ofr, true);\n    if (abort) {\n      TestEvents.eq(\n        bal,\n        mgv.balanceOf(address(this)),\n        \"Cancel offer of a failed offer should not give provision to maker\"\n      );\n    }\n  }\n\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external override {\n    require(msg.sender == address(mgv));\n    bool success = (result.mgvData == \"mgv/tradeSuccess\");\n    TestEvents.eq(\n      success,\n      !(abort || makerRevert || willFail),\n      \"incorrect success flag\"\n    );\n    if (makerRevert) {\n      TestEvents.eq(\n        result.mgvData,\n        \"mgv/makerRevert\",\n        \"mgvData should be makerRevert\"\n      );\n    } else if (abort) {\n      TestEvents.eq(\n        result.mgvData,\n        \"mgv/makerAbort\",\n        \"mgvData should be makerAbort\"\n      );\n    } else {\n      TestEvents.eq(\n        result.mgvData,\n        bytes32(\"mgv/tradeSuccess\"),\n        \"mgvData should be tradeSuccess\"\n      );\n    }\n    TestEvents.check(\n      !TestUtils.hasOffer(\n        mgv,\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId\n      ),\n      \"Offer was not removed after take\"\n    );\n    bool noRevert;\n    (noRevert, ) = address(this).call(\n      abi.encodeWithSelector(posthook_bytes, order, result)\n    );\n  }\n\n  function a_beforeAll() public {\n    Display.register(address(this), \"Test runner\");\n\n    baseT = TokenSetup.setup(\"A\", \"$A\");\n    quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    Display.register(base, \"base\");\n    Display.register(quote, \"quote\");\n\n    mgv = MgvSetup.setup(baseT, quoteT);\n    Display.register(address(mgv), \"Mgv\");\n\n    tkr = TakerSetup.setup(mgv, base, quote);\n    Display.register(address(tkr), \"Taker\");\n\n    baseT.approve(address(mgv), 10 ether);\n\n    payable(tkr).transfer(10 ether);\n    quoteT.mint(address(tkr), 1 ether);\n    baseT.mint(address(this), 5 ether);\n\n    tkr.approveMgv(baseT, 1 ether); // takerFee\n    tkr.approveMgv(quoteT, 1 ether);\n\n    mgv.fund{value: 10 ether}(address(this)); // for new offer and further updates\n    weiBalMaker = mgv.balanceOf(address(this));\n  }\n\n  function renew_offer_after_partial_fill_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.renew_offer_at_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    bool success = tkr.take(ofr, 0.5 ether);\n    TestEvents.check(success, \"Snipe should succeed\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function renew_offer_after_complete_fill_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.renew_offer_at_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function renew_offer_after_failed_execution_test() public {\n    posthook_bytes = this.renew_offer_at_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    abort = true;\n\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(!success, \"Snipe should fail\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function treat_fail_at_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata res\n  ) external {\n    bool success = (res.mgvData == \"mgv/tradeSuccess\");\n    TestEvents.check(!success, \"Offer should be marked as failed\");\n    TestEvents.check(res.makerData == \"NOK\", \"Incorrect maker data\");\n  }\n\n  function failed_offer_is_not_executed_test() public {\n    posthook_bytes = this.treat_fail_at_posthook.selector;\n    uint balMaker = baseT.balanceOf(address(this));\n    uint balTaker = quoteT.balanceOf(address(tkr));\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    abort = true;\n\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(!success, \"Snipe should fail\");\n    TestEvents.eq(\n      baseT.balanceOf(address(this)),\n      balMaker,\n      \"Maker should not have been debited of her base tokens\"\n    );\n    TestEvents.eq(\n      quoteT.balanceOf(address(tkr)),\n      balTaker,\n      \"Taker should not have been debited of her quote tokens\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerAbort\"\n    );\n  }\n\n  function update_offer_with_more_gasprice_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    uint standard_provision = TestUtils.getProvision(mgv, base, quote, gasreq);\n    posthook_bytes = this.update_gas_offer_at_posthook.selector;\n    // provision for mgv.global.gasprice\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, 0, 0);\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - standard_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(success, \"Snipe should succeed\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function posthook_of_skipped_offer_wrong_gas_should_not_be_called_test()\n    public\n  {\n    posthook_bytes = this.failer_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n\n    bool success = tkr.snipe(\n      mgv,\n      base,\n      quote,\n      ofr,\n      1 ether,\n      1 ether,\n      gasreq - 1\n    );\n    TestEvents.check(!called, \"PostHook was called\");\n    TestEvents.check(!success, \"Snipe should fail\");\n  }\n\n  function posthook_of_skipped_offer_wrong_price_should_not_be_called_test()\n    public\n  {\n    posthook_bytes = this.failer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    bool success = tkr.snipe(mgv, base, quote, ofr, 1.1 ether, 1 ether, gasreq);\n    TestEvents.check(!success, \"Snipe should fail\");\n    TestEvents.check(!called, \"PostHook was called\");\n  }\n\n  function retract_offer_in_posthook_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(success, \"Snipe should succeed\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker, // provision returned to taker\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(base, quote, ofr, address(tkr), 1 ether, 1 ether);\n    emit Credit(address(this), mkr_provision);\n    emit OfferRetract(base, quote, ofr);\n  }\n\n  function balance_after_fail_and_retract_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    uint tkr_weis = address(tkr).balance;\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    abort = true;\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(!success, \"Snipe should fail\");\n    uint penalty = weiBalMaker - mgv.balanceOf(address(this));\n    TestEvents.eq(\n      penalty,\n      address(tkr).balance - tkr_weis,\n      \"Incorrect overall balance after penalty for taker\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerAbort\"\n    );\n    emit OfferRetract(base, quote, ofr);\n    emit Credit(address(this), mkr_provision - penalty);\n  }\n\n  function update_offer_after_deprovision_in_posthook_succeeds_test() public {\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.check(success, \"Snipe should succeed\");\n    mgv.updateOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0, ofr);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(base, quote, ofr, address(tkr), 1 ether, 1 ether);\n    emit OfferRetract(base, quote, ofr);\n  }\n\n  function check_best_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    called = true;\n    (, P.Local.t cfg) = mgv.config(order.outbound_tkn, order.inbound_tkn);\n    TestEvents.eq(\n      cfg.best(),\n      ofr,\n      \"Incorrect best offer id in posthook\"\n    );\n  }\n\n  function best_in_posthook_is_correct_test() public {\n    mgv.newOffer(base, quote, 2 ether, 1 ether, gasreq, _gasprice, 0);\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    uint best = mgv.newOffer(\n      base,\n      quote,\n      0.5 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    posthook_bytes = this.check_best_in_posthook.selector;\n    bool success = tkr.take(best, 1 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n  }\n\n  function check_offer_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    called = true;\n    uint __wants = order.offer.wants();\n    uint __gives = order.offer.gives();\n    address __maker = order.offerDetail.maker();\n    uint __gasreq = order.offerDetail.gasreq();\n    uint __gasprice = order.offerDetail.gasprice();\n    TestEvents.eq(__wants, 1 ether, \"Incorrect wants for offer in posthook\");\n    TestEvents.eq(__gives, 2 ether, \"Incorrect gives for offer in posthook\");\n    TestEvents.eq(__gasprice, 500, \"Incorrect gasprice for offer in posthook\");\n    TestEvents.eq(__maker, address(this), \"Incorrect maker address\");\n    TestEvents.eq(__gasreq, gasreq, \"Incorrect gasreq\");\n  }\n\n  function check_offer_in_posthook_test() public {\n    ofr = mgv.newOffer(base, quote, 1 ether, 2 ether, gasreq, 500, 0);\n    posthook_bytes = this.check_offer_in_posthook.selector;\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n  }\n\n  function check_lastId_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    called = true;\n    (, P.Local.t cfg) = mgv.config(order.outbound_tkn, order.inbound_tkn);\n    TestEvents.eq(\n      cfg.last(),\n      ofr,\n      \"Incorrect last offer id in posthook\"\n    );\n  }\n\n  function lastId_in_posthook_is_correct_test() public {\n    mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    ofr = mgv.newOffer(base, quote, 0.5 ether, 1 ether, gasreq, _gasprice, 0);\n    posthook_bytes = this.check_lastId_in_posthook.selector;\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n  }\n\n  function retract_offer_after_fail_in_posthook_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    abort = true; // maker should fail\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.check(!success, \"Snipe should fail\");\n\n    TestEvents.less(\n      mgv.balanceOf(address(this)),\n      weiBalMaker,\n      \"Maker balance after take should be less than original balance\"\n    );\n    uint refund = mgv.balanceOf(address(this)) + mkr_provision - weiBalMaker;\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerAbort\"\n    );\n    emit OfferRetract(base, quote, ofr);\n    emit Credit(address(this), refund);\n  }\n\n  function makerRevert_is_logged_test() public {\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    makerRevert = true; // maker should fail\n    bool success;\n    success = tkr.take(ofr, 2 ether);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n  }\n\n  function reverting_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) external pure {\n    assert(false);\n  }\n\n  function reverting_posthook_does_not_revert_offer_test() public {\n    TestUtils.getProvision(mgv, base, quote, gasreq, _gasprice);\n    uint balMaker = baseT.balanceOf(address(this));\n    uint balTaker = quoteT.balanceOf(address(tkr));\n    posthook_bytes = this.reverting_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(success, \"snipe should succeed\");\n    TestEvents.eq(\n      balMaker - 1 ether,\n      baseT.balanceOf(address(this)),\n      \"Incorrect maker balance\"\n    );\n    TestEvents.eq(\n      balTaker - 1 ether,\n      quoteT.balanceOf(address(tkr)),\n      \"Incorrect taker balance\"\n    );\n  }\n}\n"
    },
    "contracts/Tests/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./SafeMath.sol\";\nimport {IERC20} from \"../MgvLib.sol\";\n\n// From OpenZeppelin\n//The MIT License (MIT)\n\n//Copyright (c) 2016-2020 zOS Global Limited\n\n//Permission is hereby granted, free of charge, to any person obtaining\n//a copy of this software and associated documentation files (the\n//\"Software\"), to deal in the Software without restriction, including\n//without limitation the rights to use, copy, modify, merge, publish,\n//distribute, sublicense, and/or sell copies of the Software, and to\n//permit persons to whom the Software is furnished to do so, subject to\n//the following conditions:\n\n//The above copyright notice and this permission notice shall be included\n//in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n//MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n//CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n//TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return payable(msg.sender);\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n  using SafeMath for uint;\n\n  mapping(address => uint) private _balances;\n\n  mapping(address => mapping(address => uint)) private _allowances;\n\n  uint private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory __name, string memory __symbol) {\n    _name = __name;\n    _symbol = __symbol;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint amount\n  ) internal virtual {}\n\n  function deposit() external payable override {}\n\n  function withdraw(uint) external override {}\n}\n"
    },
    "contracts/Tests/MintableERC20BLWithDecimals.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"./ERC20BLWithDecimals.sol\";\nimport \"./SafeMath.sol\";\n\ncontract MintableERC20BLWithDecimals is ERC20BLWithDecimals {\n  using SafeMath for uint;\n\n  mapping(address => bool) admins;\n\n  constructor(\n    address admin,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) ERC20BLWithDecimals(name, symbol, decimals) {\n    admins[admin] = true;\n  }\n\n  function requireAdmin() internal view {\n    require(admins[msg.sender], \"MintableERC20BLWithDecimals/adminOnly\");\n  }\n\n  function addAdmin(address admin) external {\n    requireAdmin();\n    admins[admin] = true;\n  }\n\n  function mint(uint amount) external {\n    uint limit = 1000;\n    require(\n      amount <= limit.mul(pow(10, decimals())),\n      \"MintableERC20BLWithDecimals/mintLimitExceeded\"\n    );\n    _mint(_msgSender(), amount);\n  }\n\n  function mintAdmin(address to, uint amount) external {\n    requireAdmin();\n    _mint(to, amount);\n  }\n\n  function burn(address account, uint amount) external {\n    requireAdmin();\n    _burn(account, amount);\n  }\n\n  function blacklists(address account) external {\n    requireAdmin();\n    _blacklists(account);\n  }\n\n  function whitelists(address account) external {\n    requireAdmin();\n    _whitelists(account);\n  }\n\n  function pow(uint n, uint e) public pure returns (uint) {\n    if (e == 0) {\n      return 1;\n    } else if (e == 1) {\n      return n;\n    } else {\n      uint p = pow(n, e.div(2));\n      p = p.mul(p);\n      if (e.mod(2) == 1) {\n        p = p.mul(n);\n      }\n      return p;\n    }\n  }\n}\n"
    },
    "contracts/Tests/Agents/MoneyMarket.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma abicoder v2;\npragma solidity ^0.8.10;\n\nimport \"./TestToken.sol\";\nimport {SafeMath as S} from \"../SafeMath.sol\";\n\ncontract MoneyMarket {\n  // all prices are 1:1\n  // interest rate is 0\n  // the market has infinite liquidity\n\n  // money market must be admin of all tokens to work\n  // use token.addAdmin(address(moneyMarket)) to give it admin power\n\n  uint constant RATIO = 13_000; // basis points\n  TestToken[] tokens;\n  mapping(TestToken => mapping(address => uint)) borrows;\n  mapping(TestToken => mapping(address => uint)) lends;\n\n  constructor(TestToken[] memory _tokens) {\n    tokens = _tokens;\n  }\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function borrow(TestToken token, uint amount) external returns (bool) {\n    uint lent = getLends();\n    uint borrowed = getBorrows();\n    if (S.div(S.mul(S.add(borrowed, amount), RATIO), 10_000) <= lent) {\n      borrows[token][msg.sender] += amount;\n      token.mint(address(this), amount); // magic minting\n      token.transfer(msg.sender, amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function lend(TestToken token, uint amount) external {\n    token.transferFrom(msg.sender, address(this), amount);\n    lends[token][msg.sender] += amount;\n  }\n\n  function repay(TestToken token, uint _amount) external {\n    uint amount = min(borrows[token][msg.sender], _amount);\n    token.transferFrom(msg.sender, address(this), amount);\n    borrows[token][msg.sender] -= amount;\n  }\n\n  function redeem(TestToken token, uint _amount) external {\n    uint amount = min(lends[token][msg.sender], _amount);\n    token.transfer(msg.sender, amount);\n    lends[token][msg.sender] -= amount;\n  }\n\n  function getBorrows() public view returns (uint total) {\n    for (uint i = 0; i < tokens.length; i++) {\n      total += borrows[tokens[i]][msg.sender];\n    }\n  }\n\n  function getLends() public view returns (uint total) {\n    for (uint i = 0; i < tokens.length; i++) {\n      total += lends[tokens[i]][msg.sender];\n    }\n  }\n}\n"
    },
    "contracts/periphery/MgvOracle.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOracle.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../MgvLib.sol\";\n\n/* The purpose of the Oracle contract is to act as a gas price and density\n * oracle for the Mangrove. It bridges to an external oracle, and allows\n * a given sender to update the gas price and density which the oracle\n * reports to Mangrove. */\ncontract MgvOracle is IMgvMonitor {\n  address governance;\n  address mutator;\n\n  uint lastReceivedGasPrice;\n  uint lastReceivedDensity;\n\n  constructor(address _governance, address _initialMutator) {\n    governance = _governance;\n    mutator = _initialMutator;\n\n    //NOTE: Hardwiring density for now\n    /* Mangrove will reject densities from the Monitor that don't fit in 32 bits and use its internal density instead, so setting this contract's density to `type(uint).max` is a way to let Mangrove deal with density on its own. */\n    lastReceivedDensity = type(uint).max;\n  }\n\n  /* ## `authOnly` check */\n  // NOTE: Should use standard auth method, instead of this copy from MgvGovernable\n\n  function authOnly() internal view {\n    require(\n      msg.sender == governance ||\n        msg.sender == address(this) ||\n        governance == address(0),\n      \"MgvOracle/unauthorized\"\n    );\n  }\n\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    // Do nothing\n  }\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    // Do nothing\n  }\n\n  function setMutator(address _mutator) external {\n    authOnly();\n\n    mutator = _mutator;\n  }\n\n  function setGasPrice(uint gasPrice) external {\n    // governance or mutator are allowed to update the gasprice\n    require(\n      msg.sender == governance || msg.sender == mutator,\n      \"MgvOracle/unauthorized\"\n    );\n\n    lastReceivedGasPrice = gasPrice;\n  }\n\n  function setDensity(uint /*density*/) private view {\n    // governance or mutator are allowed to update the density\n    require(\n      msg.sender == governance || msg.sender == mutator,\n      \"MgvOracle/unauthorized\"\n    );\n\n    //NOTE: Not implemented, so not made external yet\n  }\n\n  function read(address /*outbound_tkn*/, address /*inbound_tkn*/)\n    external\n    view\n    override\n    returns (uint gasprice, uint density)\n  {\n    return (lastReceivedGasPrice, lastReceivedDensity);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
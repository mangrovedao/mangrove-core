{
  "language": "Solidity",
  "sources": {
    "contracts/AbstractMangrove.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// AbstractMangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML} from \"./MgvLib.sol\";\n\nimport {MgvOfferMaking} from \"./MgvOfferMaking.sol\";\nimport {MgvOfferTakingWithPermit} from \"./MgvOfferTakingWithPermit.sol\";\nimport {MgvGovernable} from \"./MgvGovernable.sol\";\n\n/* `AbstractMangrove` inherits the three contracts that implement generic Mangrove functionality (`MgvGovernable`,`MgvOfferTakingWithPermit` and `MgvOfferMaking`) but does not implement the abstract functions. */\nabstract contract AbstractMangrove is\n  MgvGovernable,\n  MgvOfferTakingWithPermit,\n  MgvOfferMaking\n{\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax,\n    string memory contractName\n  )\n    MgvOfferTakingWithPermit(contractName)\n    MgvGovernable(governance, gasprice, gasmax)\n  {}\n}\n"
    },
    "contracts/MgvLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// MgvLib.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"./preprocessed/MgvPack.post.sol\" as P;\n\n/* # Structs\nThe structs defined in `structs.js` have their counterpart as solidity structs that are easy to manipulate for outside contracts / callers of view functions. */\n\nlibrary MgvLib {\n  /*\n   Some miscellaneous data types useful to `Mangrove` and external contracts */\n  //+clear+\n\n  /* `SingleOrder` holds data about an order-offer match in a struct. Used by `marketOrder` and `internalSnipes` (and some of their nested functions) to avoid stack too deep errors. */\n  struct SingleOrder {\n    address outbound_tkn;\n    address inbound_tkn;\n    uint offerId;\n    P.Offer.t offer;\n    /* `wants`/`gives` mutate over execution. Initially the `wants`/`gives` from the taker's pov, then actual `wants`/`gives` adjusted by offer's price and volume. */\n    uint wants;\n    uint gives;\n    /* `offerDetail` is only populated when necessary. */\n    P.OfferDetail.t offerDetail;\n    P.Global.t global;\n    P.Local.t local;\n  }\n\n  /* <a id=\"MgvLib/OrderResult\"></a> `OrderResult` holds additional data for the maker and is given to them _after_ they fulfilled an offer. It gives them their own returned data from the previous call, and an `mgvData` specifying whether the Mangrove encountered an error. */\n\n  struct OrderResult {\n    /* `makerdata` holds a message that was either returned by the maker or passed as revert message at the end of the trade execution*/\n    bytes32 makerData;\n    /* `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes) code. */\n    bytes32 mgvData;\n  }\n}\n\n/* # Events\nThe events emitted for use by bots are listed here: */\ncontract HasMgvEvents {\n  /* * Emitted at the creation of the new Mangrove contract on the pair (`inbound_tkn`, `outbound_tkn`)*/\n  event NewMgv();\n\n  /* Mangrove adds or removes wei from `maker`'s account */\n  /* * Credit event occurs when an offer is removed from the Mangrove or when the `fund` function is called*/\n  event Credit(address indexed maker, uint amount);\n  /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */\n  event Debit(address indexed maker, uint amount);\n\n  /* * Mangrove reconfiguration */\n  event SetActive(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    bool value\n  );\n  event SetFee(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasbase(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offer_gasbase\n  );\n  event SetGovernance(address value);\n  event SetMonitor(address value);\n  event SetVault(address value);\n  event SetUseOracle(bool value);\n  event SetNotify(bool value);\n  event SetGasmax(uint value);\n  event SetDensity(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasprice(uint value);\n\n  /* Market order execution */\n  event OrderStart();\n  event OrderComplete(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address indexed taker,\n    uint takerGot,\n    uint takerGave,\n    uint penalty,\n    uint feePaid\n  );\n\n  /* * Offer execution */\n  event OfferSuccess(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\n    address taker,\n    uint takerWants,\n    uint takerGives\n  );\n\n  /* Log information when a trade execution reverts or returns a non empty bytes32 word */\n  event OfferFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\n    address taker,\n    uint takerWants,\n    uint takerGives,\n    // `mgvData` may only be `\"mgv/makerRevert\"`, `\"mgv/makerTransferFail\"` or `\"mgv/makerReceiveFail\"`\n    bytes32 mgvData\n  );\n\n  /* Log information when a posthook reverts */\n  event PosthookFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId,\n    bytes32 posthookData\n  );\n\n  /* * After `permit` and `approve` */\n  event Approval(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address owner,\n    address spender,\n    uint value\n  );\n\n  /* * Mangrove closure */\n  event Kill();\n\n  /* * An offer was created or updated.\n  A few words about why we include a `prev` field, and why we don't include a\n  `next` field: in theory clients should need neither `prev` nor a `next` field.\n  They could just 1. Read the order book state at a given block `b`.  2. On\n  every event, update a local copy of the orderbook.  But in practice, we do not\n  want to force clients to keep a copy of the *entire* orderbook. There may be a\n  long tail of spam. Now if they only start with the first $N$ offers and\n  receive a new offer that goes to the end of the book, they cannot tell if\n  there are missing offers between the new offer and the end of the local copy\n  of the book.\n  \n  So we add a prev pointer so clients with only a prefix of the book can receive\n  out-of-prefix offers and know what to do with them. The `next` pointer is an\n  optimization useful in Solidity (we traverse fewer memory locations) but\n  useless in client code.\n  */\n  event OfferWrite(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address maker,\n    uint wants,\n    uint gives,\n    uint gasprice,\n    uint gasreq,\n    uint id,\n    uint prev\n  );\n\n  /* * `offerId` was present and is now removed from the book. */\n  event OfferRetract(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id\n  );\n}\n\n/* # IMaker interface */\ninterface IMaker {\n  /* Called upon offer execution. \n  - If the call fails, Mangrove will not try to transfer funds.\n  - If the call succeeds but returndata's first 32 bytes are not 0, Mangrove will not try to transfer funds either.\n  - If the call succeeds and returndata's first 32 bytes are 0, Mangrove will try to transfer funds.\n  In other words, you may declare failure by reverting or by returning nonzero data. In both cases, those 32 first bytes will be passed back to you during the call to `makerPosthook` in the `result.mgvData` field.\n     ```\n     function tradeRevert(bytes32 data) internal pure {\n       bytes memory revData = new bytes(32);\n         assembly {\n           mstore(add(revData, 32), data)\n           revert(add(revData, 32), 32)\n         }\n     }\n     ```\n     */\n  function makerExecute(MgvLib.SingleOrder calldata order)\n    external\n    returns (bytes32);\n\n  /* Called after all offers of an order have been executed. Posthook of the last executed order is called first and full reentrancy into the Mangrove is enabled at this time. `order` recalls key arguments of the order that was processed and `result` recalls important information for updating the current offer. (see [above](#MgvLib/OrderResult))*/\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external;\n}\n\n/* # ITaker interface */\ninterface ITaker {\n  /* Inverted mangrove only: call to taker after loans went through */\n  function takerTrade(\n    address outbound_tkn,\n    address inbound_tkn,\n    // total amount of outbound_tkn token that was flashloaned to the taker\n    uint totalGot,\n    // total amount of inbound_tkn token that should be made available\n    uint totalGives\n  ) external;\n}\n\n/* # Monitor interface\nIf enabled, the monitor receives notification after each offer execution and is read for each pair's `gasprice` and `density`. */\ninterface IMgvMonitor {\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external;\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker) external;\n\n  function read(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint gasprice, uint density);\n}\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint);\n\n  function approve(address spender, uint amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n  /// for wETH contract\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/MgvOfferMaking.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferMaking.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {IMaker, HasMgvEvents, P} from \"./MgvLib.sol\";\nimport {MgvHasOffers} from \"./MgvHasOffers.sol\";\n\n/* `MgvOfferMaking` contains market-making-related functions. */\ncontract MgvOfferMaking is MgvHasOffers {\n  /* # Public Maker operations\n     ## New Offer */\n  //+clear+\n  /* In the Mangrove, makers and takers call separate functions. Market makers call `newOffer` to fill the book, and takers call functions such as `marketOrder` to consume it.  */\n\n  //+clear+\n\n  /* The following structs holds offer creation/update parameters in memory. This frees up stack space for local variables. */\n  struct OfferPack {\n    address outbound_tkn;\n    address inbound_tkn;\n    uint wants;\n    uint gives;\n    uint id;\n    uint gasreq;\n    uint gasprice;\n    uint pivotId;\n    P.Global.t global;\n    P.Local.t local;\n    // used on update only\n    P.Offer.t oldOffer;\n  }\n\n  /* The function `newOffer` is for market makers only; no match with the existing book is done. A maker specifies how much `inbound_tkn` it `wants` and how much `outbound_tkn` it `gives`.\n\n     It also specify with `gasreq` how much gas should be given when executing their offer.\n\n     `gasprice` indicates an upper bound on the gasprice at which the maker is ready to be penalised if their offer fails. Any value below the Mangrove's internal `gasprice` configuration value will be ignored.\n\n    `gasreq`, together with `gasprice`, will contribute to determining the penalty provision set aside by the Mangrove from the market maker's `balanceOf` balance.\n\n  Offers are always inserted at the correct place in the book. This requires walking through offers to find the correct insertion point. As in [Oasis](https://github.com/daifoundation/maker-otc/blob/f2060c5fe12fe3da71ac98e8f6acc06bca3698f5/src/matching_market.sol#L493), the maker should find the id of an offer close to its own and provide it as `pivotId`.\n\n  An offer cannot be inserted in a closed market, nor when a reentrancy lock for `outbound_tkn`,`inbound_tkn` is on.\n\n  No more than $2^{32}-1$ offers can ever be created for one `outbound_tkn`,`inbound_tkn` pair.\n\n  The actual contents of the function is in `writeOffer`, which is called by both `newOffer` and `updateOffer`.\n  */\n  function newOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) external payable returns (uint) {\n    unchecked {\n      /* In preparation for calling `writeOffer`, we read the `outbound_tkn`,`inbound_tkn` pair configuration, check for reentrancy and market liveness, fill the `OfferPack` struct and increment the `outbound_tkn`,`inbound_tkn` pair's `last`. */\n      OfferPack memory ofp;\n      (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\n      unlockedMarketOnly(ofp.local);\n      activeMarketOnly(ofp.global, ofp.local);\n      if (msg.value > 0) {\n        creditWei(msg.sender, msg.value);\n      }\n\n      ofp.id = 1 + ofp.local.last();\n      require(uint32(ofp.id) == ofp.id, \"mgv/offerIdOverflow\");\n\n      ofp.local = ofp.local.last(ofp.id);\n\n      ofp.outbound_tkn = outbound_tkn;\n      ofp.inbound_tkn = inbound_tkn;\n      ofp.wants = wants;\n      ofp.gives = gives;\n      ofp.gasreq = gasreq;\n      ofp.gasprice = gasprice;\n      ofp.pivotId = pivotId;\n\n      /* The second parameter to writeOffer indicates that we are creating a new offer, not updating an existing one. */\n      writeOffer(ofp, false);\n\n      /* Since we locally modified a field of the local configuration (`last`), we save the change to storage. Note that `writeOffer` may have further modified the local configuration by updating the current `best` offer. */\n      locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\n      return ofp.id;\n    }\n  }\n\n  /* ## Update Offer */\n  //+clear+\n  /* Very similar to `newOffer`, `updateOffer` prepares an `OfferPack` for `writeOffer`. Makers should use it for updating live offers, but also to save on gas by reusing old, already consumed offers.\n\n     A `pivotId` should still be given to minimise reads in the offer book. It is OK to give the offers' own id as a pivot.\n\n\n     Gas use is minimal when:\n     1. The offer does not move in the book\n     2. The offer does not change its `gasreq`\n     3. The (`outbound_tkn`,`inbound_tkn`)'s `offer_gasbase` has not changed since the offer was last written\n     4. `gasprice` has not changed since the offer was last written\n     5. `gasprice` is greater than the Mangrove's gasprice estimation\n  */\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external payable {\n    unchecked {\n      OfferPack memory ofp;\n      (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\n      unlockedMarketOnly(ofp.local);\n      activeMarketOnly(ofp.global, ofp.local);\n      if (msg.value > 0) {\n        creditWei(msg.sender, msg.value);\n      }\n      ofp.outbound_tkn = outbound_tkn;\n      ofp.inbound_tkn = inbound_tkn;\n      ofp.wants = wants;\n      ofp.gives = gives;\n      ofp.id = offerId;\n      ofp.gasreq = gasreq;\n      ofp.gasprice = gasprice;\n      ofp.pivotId = pivotId;\n      ofp.oldOffer = offers[outbound_tkn][inbound_tkn][offerId];\n      // Save local config\n      P.Local.t oldLocal = ofp.local;\n      /* The second argument indicates that we are updating an existing offer, not creating a new one. */\n      writeOffer(ofp, true);\n      /* We saved the current pair's configuration before calling `writeOffer`, since that function may update the current `best` offer. We now check for any change to the configuration and update it if needed. */\n      if (!oldLocal.eq(ofp.local)) {\n        locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\n      }\n    }\n  }\n\n  /* ## Retract Offer */\n  //+clear+\n  /* `retractOffer` takes the offer `offerId` out of the book. However, `deprovision == true` also refunds the provision associated with the offer. */\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision\n  ) external returns (uint provision) {\n    unchecked {\n      (, P.Local.t local) = config(outbound_tkn, inbound_tkn);\n      unlockedMarketOnly(local);\n      P.Offer.t offer = offers[outbound_tkn][inbound_tkn][offerId];\n      P.OfferDetail.t offerDetail = offerDetails[outbound_tkn][inbound_tkn][\n        offerId\n      ];\n      require(\n        msg.sender == offerDetail.maker(),\n        \"mgv/retractOffer/unauthorized\"\n      );\n\n      /* Here, we are about to un-live an offer, so we start by taking it out of the book by stitching together its previous and next offers. Note that unconditionally calling `stitchOffers` would break the book since it would connect offers that may have since moved. */\n      if (isLive(offer)) {\n        P.Local.t oldLocal = local;\n        local = stitchOffers(\n          outbound_tkn,\n          inbound_tkn,\n          offer.prev(),\n          offer.next(),\n          local\n        );\n        /* If calling `stitchOffers` has changed the current `best` offer, we update the storage. */\n        if (!oldLocal.eq(local)) {\n          locals[outbound_tkn][inbound_tkn] = local;\n        }\n      }\n      /* Set `gives` to 0. Moreover, the last argument depends on whether the user wishes to get their provision back (if true, `gasprice` will be set to 0 as well). */\n      dirtyDeleteOffer(\n        outbound_tkn,\n        inbound_tkn,\n        offerId,\n        offer,\n        offerDetail,\n        deprovision\n      );\n\n      /* If the user wants to get their provision back, we compute its provision from the offer's `gasprice`, `offer_gasbase` and `gasreq`. */\n      if (deprovision) {\n        provision =\n          10**9 *\n          offerDetail.gasprice() * //gasprice is 0 if offer was deprovisioned\n          (offerDetail.gasreq() + offerDetail.offer_gasbase());\n        // credit `balanceOf` and log transfer\n        creditWei(msg.sender, provision);\n      }\n      emit OfferRetract(outbound_tkn, inbound_tkn, offerId);\n    }\n  }\n\n  /* ## Provisioning\n  Market makers must have enough provisions for possible penalties. These provisions are in ETH. Every time a new offer is created or an offer is updated, `balanceOf` is adjusted to provision the offer's maximum possible penalty (`gasprice * (gasreq + offer_gasbase)`).\n\n  For instance, if the current `balanceOf` of a maker is 1 ether and they create an offer that requires a provision of 0.01 ethers, their `balanceOf` will be reduced to 0.99 ethers. No ethers will move; this is just an internal accounting movement to make sure the maker cannot `withdraw` the provisioned amounts.\n\n  */\n  //+clear+\n\n  /* Fund should be called with a nonzero value (hence the `payable` modifier). The provision will be given to `maker`, not `msg.sender`. */\n  function fund(address maker) public payable {\n    unchecked {\n      (P.Global.t _global, ) = config(address(0), address(0));\n      liveMgvOnly(_global);\n      creditWei(maker, msg.value);\n    }\n  }\n\n  function fund() external payable {\n    unchecked {\n      fund(msg.sender);\n    }\n  }\n\n  /* A transfer with enough gas to the Mangrove will increase the caller's available `balanceOf` balance. _You should send enough gas to execute this function when sending money to the Mangrove._  */\n  receive() external payable {\n    unchecked {\n      fund(msg.sender);\n    }\n  }\n\n  /* Any provision not currently held to secure an offer's possible penalty is available for withdrawal. */\n  function withdraw(uint amount) external returns (bool noRevert) {\n    unchecked {\n      /* Since we only ever send money to the caller, we do not need to provide any particular amount of gas, the caller should manage this herself. */\n      debitWei(msg.sender, amount);\n      (noRevert, ) = msg.sender.call{value: amount}(\"\");\n    }\n  }\n\n  /* # Low-level Maker functions */\n\n  /* ## Write Offer */\n\n  function writeOffer(OfferPack memory ofp, bool update) internal {\n    unchecked {\n      /* `gasprice`'s floor is Mangrove's own gasprice estimate, `ofp.global.gasprice`. We first check that gasprice fits in 16 bits. Otherwise it could be that `uint16(gasprice) < global_gasprice < gasprice`, and the actual value we store is `uint16(gasprice)`. */\n      require(checkGasprice(ofp.gasprice), \"mgv/writeOffer/gasprice/16bits\");\n\n      if (ofp.gasprice < ofp.global.gasprice()) {\n        ofp.gasprice = ofp.global.gasprice();\n      }\n\n      /* * Check `gasreq` below limit. Implies `gasreq` at most 24 bits wide, which ensures no overflow in computation of `provision` (see below). */\n      require(\n        ofp.gasreq <= ofp.global.gasmax(),\n        \"mgv/writeOffer/gasreq/tooHigh\"\n      );\n      /* * Make sure `gives > 0` -- division by 0 would throw in several places otherwise, and `isLive` relies on it. */\n      require(ofp.gives > 0, \"mgv/writeOffer/gives/tooLow\");\n      /* * Make sure that the maker is posting a 'dense enough' offer: the ratio of `outbound_tkn` offered per gas consumed must be high enough. The actual gas cost paid by the taker is overapproximated by adding `offer_gasbase` to `gasreq`. */\n      require(\n        ofp.gives >=\n          (ofp.gasreq + ofp.local.offer_gasbase()) * ofp.local.density(),\n        \"mgv/writeOffer/density/tooLow\"\n      );\n\n      /* The following checks are for the maker's convenience only. */\n      require(uint96(ofp.gives) == ofp.gives, \"mgv/writeOffer/gives/96bits\");\n      require(uint96(ofp.wants) == ofp.wants, \"mgv/writeOffer/wants/96bits\");\n\n      /* The position of the new or updated offer is found using `findPosition`. If the offer is the best one, `prev == 0`, and if it's the last in the book, `next == 0`.\n\n       `findPosition` is only ever called here, but exists as a separate function to make the code easier to read.\n\n    **Warning**: `findPosition` will call `better`, which may read the offer's `offerDetails`. So it is important to find the offer position _before_ we update its `offerDetail` in storage. We waste 1 (hot) read in that case but we deem that the code would get too ugly if we passed the old `offerDetail` as argument to `findPosition` and to `better`, just to save 1 hot read in that specific case.  */\n      (uint prev, uint next) = findPosition(ofp);\n\n      /* Log the write offer event. */\n      emit OfferWrite(\n        ofp.outbound_tkn,\n        ofp.inbound_tkn,\n        msg.sender,\n        ofp.wants,\n        ofp.gives,\n        ofp.gasprice,\n        ofp.gasreq,\n        ofp.id,\n        prev\n      );\n\n      /* We now write the new `offerDetails` and remember the previous provision (0 by default, for new offers) to balance out maker's `balanceOf`. */\n      uint oldProvision;\n      {\n        P.OfferDetail.t offerDetail = offerDetails[ofp.outbound_tkn][\n          ofp.inbound_tkn\n        ][ofp.id];\n        if (update) {\n          require(\n            msg.sender == offerDetail.maker(),\n            \"mgv/updateOffer/unauthorized\"\n          );\n          oldProvision =\n            10**9 *\n            offerDetail.gasprice() *\n            (offerDetail.gasreq() + offerDetail.offer_gasbase());\n        }\n\n        /* If the offer is new, has a new `gasprice`, `gasreq`, or if the Mangrove's `offer_gasbase` configuration parameter has changed, we also update `offerDetails`. */\n        if (\n          !update ||\n          offerDetail.gasreq() != ofp.gasreq ||\n          offerDetail.gasprice() != ofp.gasprice ||\n          offerDetail.offer_gasbase() != ofp.local.offer_gasbase()\n        ) {\n          uint offer_gasbase = ofp.local.offer_gasbase();\n          offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = P\n            .OfferDetail\n            .pack({\n              __maker: msg.sender,\n              __gasreq: ofp.gasreq,\n              __offer_gasbase: offer_gasbase,\n              __gasprice: ofp.gasprice\n            });\n        }\n      }\n\n      /* With every change to an offer, a maker may deduct provisions from its `balanceOf` balance. It may also get provisions back if the updated offer requires fewer provisions than before. */\n      {\n        uint provision = (ofp.gasreq + ofp.local.offer_gasbase()) *\n          ofp.gasprice *\n          10**9;\n        if (provision > oldProvision) {\n          debitWei(msg.sender, provision - oldProvision);\n        } else if (provision < oldProvision) {\n          creditWei(msg.sender, oldProvision - provision);\n        }\n      }\n      /* We now place the offer in the book at the position found by `findPosition`. */\n\n      /* First, we test if the offer has moved in the book or is not currently in the book. If `!isLive(ofp.oldOffer)`, we must update its prev/next. If it is live but its prev has changed, we must also update them. Note that checking both `prev = oldPrev` and `next == oldNext` would be redundant. If either is true, then the updated offer has not changed position and there is nothing to update.\n\n    As a note for future changes, there is a tricky edge case where `prev == oldPrev` yet the prev/next should be changed: a previously-used offer being brought back in the book, and ending with the same prev it had when it was in the book. In that case, the neighbor is currently pointing to _another_ offer, and thus must be updated. With the current code structure, this is taken care of as a side-effect of checking `!isLive`, but should be kept in mind. The same goes in the `next == oldNext` case. */\n      if (!isLive(ofp.oldOffer) || prev != ofp.oldOffer.prev()) {\n        /* * If the offer is not the best one, we update its predecessor; otherwise we update the `best` value. */\n        if (prev != 0) {\n          offers[ofp.outbound_tkn][ofp.inbound_tkn][prev] = offers[\n            ofp.outbound_tkn\n          ][ofp.inbound_tkn][prev].next(ofp.id);\n        } else {\n          ofp.local = ofp.local.best(ofp.id);\n        }\n\n        /* * If the offer is not the last one, we update its successor. */\n        if (next != 0) {\n          offers[ofp.outbound_tkn][ofp.inbound_tkn][next] = offers[\n            ofp.outbound_tkn\n          ][ofp.inbound_tkn][next].prev(ofp.id);\n        }\n\n        /* * Recall that in this branch, the offer has changed location, or is not currently in the book. If the offer is not new and already in the book, we must remove it from its previous location by stitching its previous prev/next. */\n        if (update && isLive(ofp.oldOffer)) {\n          ofp.local = stitchOffers(\n            ofp.outbound_tkn,\n            ofp.inbound_tkn,\n            ofp.oldOffer.prev(),\n            ofp.oldOffer.next(),\n            ofp.local\n          );\n        }\n      }\n\n      /* With the `prev`/`next` in hand, we finally store the offer in the `offers` map. */\n      P.Offer.t ofr = P.Offer.pack({\n        __prev: prev,\n        __next: next,\n        __wants: ofp.wants,\n        __gives: ofp.gives\n      });\n      offers[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = ofr;\n    }\n  }\n\n  /* ## Find Position */\n  /* `findPosition` takes a price in the form of a (`ofp.wants`,`ofp.gives`) pair, an offer id (`ofp.pivotId`) and walks the book from that offer (backward or forward) until the right position for the price is found. The position is returned as a `(prev,next)` pair, with `prev` or `next` at 0 to mark the beginning/end of the book (no offer ever has id 0).\n\n  If prices are equal, `findPosition` will put the newest offer last. */\n  function findPosition(OfferPack memory ofp)\n    internal\n    view\n    returns (uint, uint)\n  {\n    unchecked {\n      uint prevId;\n      uint nextId;\n      uint pivotId = ofp.pivotId;\n      /* Get `pivot`, optimizing for the case where pivot info is already known */\n      P.Offer.t pivot = pivotId == ofp.id\n        ? ofp.oldOffer\n        : offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\n\n      /* In case pivotId is not an active offer, it is unusable (since it is out of the book). We default to the current best offer. If the book is empty pivot will be 0. That is handled through a test in the `better` comparison function. */\n      if (!isLive(pivot)) {\n        pivotId = ofp.local.best();\n        pivot = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\n      }\n\n      /* * Pivot is better than `wants/gives`, we follow `next`. */\n      if (better(ofp, pivot, pivotId)) {\n        P.Offer.t pivotNext;\n        while (pivot.next() != 0) {\n          uint pivotNextId = pivot.next();\n          pivotNext = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotNextId];\n          if (better(ofp, pivotNext, pivotNextId)) {\n            pivotId = pivotNextId;\n            pivot = pivotNext;\n          } else {\n            break;\n          }\n        }\n        // gets here on empty book\n        (prevId, nextId) = (pivotId, pivot.next());\n\n        /* * Pivot is strictly worse than `wants/gives`, we follow `prev`. */\n      } else {\n        P.Offer.t pivotPrev;\n        while (pivot.prev() != 0) {\n          uint pivotPrevId = pivot.prev();\n          pivotPrev = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotPrevId];\n          if (better(ofp, pivotPrev, pivotPrevId)) {\n            break;\n          } else {\n            pivotId = pivotPrevId;\n            pivot = pivotPrev;\n          }\n        }\n\n        (prevId, nextId) = (pivot.prev(), pivotId);\n      }\n\n      return (\n        prevId == ofp.id ? ofp.oldOffer.prev() : prevId,\n        nextId == ofp.id ? ofp.oldOffer.next() : nextId\n      );\n    }\n  }\n\n  /* ## Better */\n  /* The utility method `better` takes an offer represented by `ofp` and another represented by `offer1`. It returns true iff `offer1` is better or as good as `ofp`.\n    \"better\" is defined on the lexicographic order $\\textrm{price} \\times_{\\textrm{lex}} \\textrm{density}^{-1}$. This means that for the same price, offers that deliver more volume per gas are taken first.\n\n      In addition to `offer1`, we also provide its id, `offerId1` in order to save gas. If necessary (ie. if the prices `wants1/gives1` and `wants2/gives2` are the same), we read storage to get `gasreq1` at `offerDetails[...][offerId1]. */\n  function better(\n    OfferPack memory ofp,\n    P.Offer.t offer1,\n    uint offerId1\n  ) internal view returns (bool) {\n    unchecked {\n      if (offerId1 == 0) {\n        /* Happens on empty book. Returning `false` would work as well due to specifics of `findPosition` but true is more consistent. Here we just want to avoid reading `offerDetail[...][0]` for nothing. */\n        return true;\n      }\n      uint wants1 = offer1.wants();\n      uint gives1 = offer1.gives();\n      uint wants2 = ofp.wants;\n      uint gives2 = ofp.gives;\n      uint weight1 = wants1 * gives2;\n      uint weight2 = wants2 * gives1;\n      if (weight1 == weight2) {\n        uint gasreq1 = offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][offerId1]\n          .gasreq();\n        uint gasreq2 = ofp.gasreq;\n        return (gives1 * gasreq2 >= gives2 * gasreq1);\n      } else {\n        return weight1 < weight2;\n      }\n    }\n  }\n}\n"
    },
    "contracts/MgvOfferTakingWithPermit.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferTakingWithPermit.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {HasMgvEvents} from \"./MgvLib.sol\";\n\nimport {MgvOfferTaking} from \"./MgvOfferTaking.sol\";\n\nabstract contract MgvOfferTakingWithPermit is MgvOfferTaking {\n  /* Takers may provide allowances on specific pairs, so other addresses can execute orders in their name. Allowance may be set using the usual `approve` function, or through an [EIP712](https://eips.ethereum.org/EIPS/eip-712) `permit`.\n\n  The mapping is `outbound_tkn => inbound_tkn => owner => spender => allowance` */\n  mapping(address => mapping(address => mapping(address => mapping(address => uint))))\n    public allowances;\n  /* Storing nonces avoids replay attacks. */\n  mapping(address => uint) public nonces;\n  /* Following [EIP712](https://eips.ethereum.org/EIPS/eip-712), structured data signing has `keccak256(\"Permit(address outbound_tkn,address inbound_tkn,address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")` in its prefix. */\n  bytes32 public constant PERMIT_TYPEHASH =\n    0xb7bf278e51ab1478b10530c0300f911d9ed3562fc93ab5e6593368fe23c077a2;\n  /* Initialized in the constructor, `DOMAIN_SEPARATOR` avoids cross-application permit reuse. */\n  bytes32 public immutable DOMAIN_SEPARATOR;\n\n  constructor(string memory contractName) {\n    /* Initialize [EIP712](https://eips.ethereum.org/EIPS/eip-712) `DOMAIN_SEPARATOR`. */\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(contractName)),\n        keccak256(bytes(\"1\")),\n        block.chainid,\n        address(this)\n      )\n    );\n  }\n\n  /* # Delegation public functions */\n\n  /* Adapted from [Uniswap v2 contract](https://github.com/Uniswap/uniswap-v2-core/blob/55ae25109b7918565867e5c39f1e84b7edd19b2a/contracts/UniswapV2ERC20.sol#L81) */\n  function permit(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    unchecked {\n      require(deadline >= block.timestamp, \"mgv/permit/expired\");\n\n      uint nonce = nonces[owner]++;\n      bytes32 digest = keccak256(\n        abi.encodePacked(\n          \"\\x19\\x01\",\n          DOMAIN_SEPARATOR,\n          keccak256(\n            abi.encode(\n              PERMIT_TYPEHASH,\n              outbound_tkn,\n              inbound_tkn,\n              owner,\n              spender,\n              value,\n              nonce,\n              deadline\n            )\n          )\n        )\n      );\n      address recoveredAddress = ecrecover(digest, v, r, s);\n      require(\n        recoveredAddress != address(0) && recoveredAddress == owner,\n        \"mgv/permit/invalidSignature\"\n      );\n\n      allowances[outbound_tkn][inbound_tkn][owner][spender] = value;\n      emit Approval(outbound_tkn, inbound_tkn, owner, spender, value);\n    }\n  }\n\n  function approve(\n    address outbound_tkn,\n    address inbound_tkn,\n    address spender,\n    uint value\n  ) external returns (bool) {\n    unchecked {\n      allowances[outbound_tkn][inbound_tkn][msg.sender][spender] = value;\n      emit Approval(outbound_tkn, inbound_tkn, msg.sender, spender, value);\n      return true;\n    }\n  }\n\n  /* The delegate version of `marketOrder` is `marketOrderFor`, which takes a `taker` address as additional argument. Penalties incurred by failed offers will still be sent to `msg.sender`, but exchanged amounts will be transferred from and to the `taker`. If the `msg.sender`'s allowance for the given `outbound_tkn`,`inbound_tkn` and `taker` are strictly less than the total amount eventually spent by `taker`, the call will fail. */\n\n  /* *Note:* `marketOrderFor` and `snipesFor` may emit ERC20 `Transfer` events of value 0 from `taker`, but that's already the case with common ERC20 implementations. */\n  function marketOrderFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint takerGot,\n      uint takerGave,\n      uint bounty,\n      uint feePaid\n    )\n  {\n    unchecked {\n      (takerGot, takerGave, bounty, feePaid) = generalMarketOrder(\n        outbound_tkn,\n        inbound_tkn,\n        takerWants,\n        takerGives,\n        fillWants,\n        taker\n      );\n      /* The sender's allowance is verified after the order complete so that `takerGave` rather than `takerGives` is checked against the allowance. The former may be lower. */\n      deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\n    }\n  }\n\n  /* The delegate version of `snipes` is `snipesFor`, which takes a `taker` address as additional argument. */\n  function snipesFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint bounty,\n      uint feePaid\n    )\n  {\n    unchecked {\n      (successes, takerGot, takerGave, bounty, feePaid) = generalSnipes(\n        outbound_tkn,\n        inbound_tkn,\n        targets,\n        fillWants,\n        taker\n      );\n      /* The sender's allowance is verified after the order complete so that the actual amounts are checked against the allowance, instead of the declared `takerGives`. The former may be lower.\n    \n    An immediate consequence is that any funds availale to Mangrove through `approve` can be used to clean offers. After a `snipesFor` where all offers have failed, all token transfers have been reverted, so `takerGave=0` and the check will succeed -- but the sender will still have received the bounty of the failing offers. */\n      deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\n    }\n  }\n\n  /* # Misc. low-level functions */\n\n  /* Used by `*For` functions, its both checks that `msg.sender` was allowed to use the taker's funds, and decreases the former's allowance. */\n  function deductSenderAllowance(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    uint amount\n  ) internal {\n    unchecked {\n      uint allowed = allowances[outbound_tkn][inbound_tkn][owner][msg.sender];\n      require(allowed >= amount, \"mgv/lowAllowance\");\n      allowances[outbound_tkn][inbound_tkn][owner][msg.sender] =\n        allowed -\n        amount;\n\n      emit Approval(\n        outbound_tkn,\n        inbound_tkn,\n        owner,\n        msg.sender,\n        allowed - amount\n      );\n    }\n  }\n}\n"
    },
    "contracts/MgvGovernable.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvGovernable.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {HasMgvEvents, P} from \"./MgvLib.sol\";\nimport {MgvRoot} from \"./MgvRoot.sol\";\n\ncontract MgvGovernable is MgvRoot {\n  /* The `governance` address. Governance is the only address that can configure parameters. */\n  address public governance;\n\n  constructor(\n    address _governance,\n    uint _gasprice,\n    uint gasmax\n  ) MgvRoot() {\n    unchecked {\n      emit NewMgv();\n\n      /* Initially, governance is open to anyone. */\n\n      /* Initialize vault to governance address, and set initial gasprice and gasmax. */\n      setVault(_governance);\n      setGasprice(_gasprice);\n      setGasmax(gasmax);\n      /* Initialize governance to `_governance` after parameter setting. */\n      setGovernance(_governance);\n    }\n  }\n\n  /* ## `authOnly` check */\n\n  function authOnly() internal view {\n    unchecked {\n      require(\n        msg.sender == governance ||\n          msg.sender == address(this) ||\n          governance == address(0),\n        \"mgv/unauthorized\"\n      );\n    }\n  }\n\n  /* # Set configuration and Mangrove state */\n\n  /* ## Locals */\n  /* ### `active` */\n  function activate(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee,\n    uint density,\n    uint offer_gasbase\n  ) public {\n    unchecked {\n      authOnly();\n      locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn]\n        .active(true);\n      emit SetActive(outbound_tkn, inbound_tkn, true);\n      setFee(outbound_tkn, inbound_tkn, fee);\n      setDensity(outbound_tkn, inbound_tkn, density);\n      setGasbase(outbound_tkn, inbound_tkn, offer_gasbase);\n    }\n  }\n\n  function deactivate(address outbound_tkn, address inbound_tkn) public {\n    authOnly();\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn]\n      .active(false);\n    emit SetActive(outbound_tkn, inbound_tkn, false);\n  }\n\n  /* ### `fee` */\n  function setFee(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee\n  ) public {\n    unchecked {\n      authOnly();\n      /* `fee` is in basis points, i.e. in percents of a percent. */\n      require(fee <= 500, \"mgv/config/fee/<=500\"); // at most 5%\n      locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].fee(\n        fee\n      );\n      emit SetFee(outbound_tkn, inbound_tkn, fee);\n    }\n  }\n\n  /* ### `density` */\n  /* Useless if `global.useOracle != 0` */\n  function setDensity(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint density\n  ) public {\n    unchecked {\n      authOnly();\n\n      require(checkDensity(density), \"mgv/config/density/112bits\");\n      //+clear+\n      locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn]\n        .density(density);\n      emit SetDensity(outbound_tkn, inbound_tkn, density);\n    }\n  }\n\n  /* ### `gasbase` */\n  function setGasbase(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offer_gasbase\n  ) public {\n    unchecked {\n      authOnly();\n      /* Checking the size of `offer_gasbase` is necessary to prevent a) data loss when copied to an `OfferDetail` struct, and b) overflow when used in calculations. */\n      require(\n        uint24(offer_gasbase) == offer_gasbase,\n        \"mgv/config/offer_gasbase/24bits\"\n      );\n      //+clear+\n      locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn]\n        .offer_gasbase(offer_gasbase);\n      emit SetGasbase(outbound_tkn, inbound_tkn, offer_gasbase);\n    }\n  }\n\n  /* ## Globals */\n  /* ### `kill` */\n  function kill() public {\n    unchecked {\n      authOnly();\n      internal_global = internal_global.dead(true);\n      emit Kill();\n    }\n  }\n\n  /* ### `gasprice` */\n  /* Useless if `global.useOracle is != 0` */\n  function setGasprice(uint gasprice) public {\n    unchecked {\n      authOnly();\n      require(checkGasprice(gasprice), \"mgv/config/gasprice/16bits\");\n\n      //+clear+\n\n      internal_global = internal_global.gasprice(gasprice);\n      emit SetGasprice(gasprice);\n    }\n  }\n\n  /* ### `gasmax` */\n  function setGasmax(uint gasmax) public {\n    unchecked {\n      authOnly();\n      /* Since any new `gasreq` is bounded above by `config.gasmax`, this check implies that all offers' `gasreq` is 24 bits wide at most. */\n      require(uint24(gasmax) == gasmax, \"mgv/config/gasmax/24bits\");\n      //+clear+\n      internal_global = internal_global.gasmax(gasmax);\n      emit SetGasmax(gasmax);\n    }\n  }\n\n  /* ### `governance` */\n  function setGovernance(address governanceAddress) public {\n    unchecked {\n      authOnly();\n      require(governanceAddress != address(0), \"mgv/config/gov/not0\");\n      governance = governanceAddress;\n      emit SetGovernance(governanceAddress);\n    }\n  }\n\n  /* ### `vault` */\n  function setVault(address vaultAddress) public {\n    unchecked {\n      authOnly();\n      vault = vaultAddress;\n      emit SetVault(vaultAddress);\n    }\n  }\n\n  /* ### `monitor` */\n  function setMonitor(address monitor) public {\n    unchecked {\n      authOnly();\n      internal_global = internal_global.monitor(monitor);\n      emit SetMonitor(monitor);\n    }\n  }\n\n  /* ### `useOracle` */\n  function setUseOracle(bool useOracle) public {\n    unchecked {\n      authOnly();\n      internal_global = internal_global.useOracle(useOracle);\n      emit SetUseOracle(useOracle);\n    }\n  }\n\n  /* ### `notify` */\n  function setNotify(bool notify) public {\n    unchecked {\n      authOnly();\n      internal_global = internal_global.notify(notify);\n      emit SetNotify(notify);\n    }\n  }\n}\n"
    },
    "contracts/preprocessed/MgvPack.post.sol": {
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: Unlicense\n\n// MgvPack.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* ************************************************** *\n            GENERATED FILE. DO NOT EDIT.\n * ************************************************** */\n\nimport \"./MgvStructs.post.sol\";\n\nimport \"./MgvOffer.post.sol\" as Offer;\nimport \"./MgvOfferDetail.post.sol\" as OfferDetail;\nimport \"./MgvGlobal.post.sol\" as Global;\nimport \"./MgvLocal.post.sol\" as Local;"
    },
    "contracts/preprocessed/MgvStructs.post.sol": {
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: Unlicense\n\n// MgvPack.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* ************************************************** *\n            GENERATED FILE. DO NOT EDIT.\n * ************************************************** */\n\n/* since you can't convert bool to uint in an expression without conditionals,\n * we add a file-level function and rely on compiler optimization\n */\nfunction uint_of_bool(bool b) pure returns (uint u) {\n  assembly { u := b }\n}\n\n// struct_defs are of the form [name,obj]\n\n// before: Can't put all structs under a 'Structs' library due to bad variable shadowing rules in Solidity\n// (would generate lots of spurious warnings about a nameclash between Structs.Offer and library Offer for instance)\n// now: Won't put all structs under a 'Structs' namespace because Mangrove & peripheral code now uses the current namespacing.\nstruct OfferStruct {\n  uint prev;\n  uint next;\n  uint wants;\n  uint gives;\n}\n\n// before: Can't put all structs under a 'Structs' library due to bad variable shadowing rules in Solidity\n// (would generate lots of spurious warnings about a nameclash between Structs.Offer and library Offer for instance)\n// now: Won't put all structs under a 'Structs' namespace because Mangrove & peripheral code now uses the current namespacing.\nstruct OfferDetailStruct {\n  address maker;\n  uint gasreq;\n  uint offer_gasbase;\n  uint gasprice;\n}\n\n// before: Can't put all structs under a 'Structs' library due to bad variable shadowing rules in Solidity\n// (would generate lots of spurious warnings about a nameclash between Structs.Offer and library Offer for instance)\n// now: Won't put all structs under a 'Structs' namespace because Mangrove & peripheral code now uses the current namespacing.\nstruct GlobalStruct {\n  address monitor;\n  bool useOracle;\n  bool notify;\n  uint gasprice;\n  uint gasmax;\n  bool dead;\n}\n\n// before: Can't put all structs under a 'Structs' library due to bad variable shadowing rules in Solidity\n// (would generate lots of spurious warnings about a nameclash between Structs.Offer and library Offer for instance)\n// now: Won't put all structs under a 'Structs' namespace because Mangrove & peripheral code now uses the current namespacing.\nstruct LocalStruct {\n  bool active;\n  uint fee;\n  uint density;\n  uint offer_gasbase;\n  bool lock;\n  uint best;\n  uint last;\n}"
    },
    "contracts/preprocessed/MgvOffer.post.sol": {
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: Unlicense\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n// fields are of the form [name,bits,type]\n\nimport \"./MgvStructs.post.sol\";\n\n// struct_defs are of the form [name,obj]\n\n/* ************************************************** *\n            GENERATED FILE. DO NOT EDIT.\n * ************************************************** */\n\n//some type safety for each struct\ntype t is uint;\nusing Library for t global;\n\nuint constant prev_bits  = 32;\nuint constant next_bits  = 32;\nuint constant wants_bits = 96;\nuint constant gives_bits = 96;\n\nuint constant prev_before  = 0;\nuint constant next_before  = prev_before  + prev_bits ;\nuint constant wants_before = next_before  + next_bits ;\nuint constant gives_before = wants_before + wants_bits;\n\nuint constant prev_mask  = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\nuint constant next_mask  = 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff;\nuint constant wants_mask = 0xffffffffffffffff000000000000000000000000ffffffffffffffffffffffff;\nuint constant gives_mask = 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000;\n\nlibrary Library {\n  function to_struct(t __packed) internal pure returns (OfferStruct memory __s) { unchecked {\n    __s.prev = (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\n    __s.next = (t.unwrap(__packed) << next_before) >> (256-next_bits);\n    __s.wants = (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\n    __s.gives = (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function unpack(t __packed) internal pure returns (uint __prev, uint __next, uint __wants, uint __gives) { unchecked {\n    __prev = (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\n    __next = (t.unwrap(__packed) << next_before) >> (256-next_bits);\n    __wants = (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\n    __gives = (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\n  }}\n\n  function prev(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\n  }}\n  function prev(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & prev_mask)\n                  | ((val << (256-prev_bits) >> prev_before)));\n  }}\n  function next(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << next_before) >> (256-next_bits);\n  }}\n  function next(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & next_mask)\n                  | ((val << (256-next_bits) >> next_before)));\n  }}\n  function wants(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\n  }}\n  function wants(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & wants_mask)\n                  | ((val << (256-wants_bits) >> wants_before)));\n  }}\n  function gives(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\n  }}\n  function gives(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gives_mask)\n                  | ((val << (256-gives_bits) >> gives_before)));\n  }}\n}\n\nfunction t_of_struct(OfferStruct memory __s) pure returns (t) { unchecked {\n  return pack(__s.prev, __s.next, __s.wants, __s.gives);\n}}\n\nfunction pack(uint __prev, uint __next, uint __wants, uint __gives) pure returns (t) { unchecked {\n  return t.wrap(((((0\n                | ((__prev << (256-prev_bits)) >> prev_before))\n                | ((__next << (256-next_bits)) >> next_before))\n                | ((__wants << (256-wants_bits)) >> wants_before))\n                | ((__gives << (256-gives_bits)) >> gives_before)));\n}}"
    },
    "contracts/preprocessed/MgvOfferDetail.post.sol": {
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: Unlicense\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n// fields are of the form [name,bits,type]\n\nimport \"./MgvStructs.post.sol\";\n\n// struct_defs are of the form [name,obj]\n\n/* ************************************************** *\n            GENERATED FILE. DO NOT EDIT.\n * ************************************************** */\n\n//some type safety for each struct\ntype t is uint;\nusing Library for t global;\n\nuint constant maker_bits         = 160;\nuint constant gasreq_bits        = 24;\nuint constant offer_gasbase_bits = 24;\nuint constant gasprice_bits      = 16;\n\nuint constant maker_before         = 0;\nuint constant gasreq_before        = maker_before         + maker_bits        ;\nuint constant offer_gasbase_before = gasreq_before        + gasreq_bits       ;\nuint constant gasprice_before      = offer_gasbase_before + offer_gasbase_bits;\n\nuint constant maker_mask         = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\nuint constant gasreq_mask        = 0xffffffffffffffffffffffffffffffffffffffff000000ffffffffffffffffff;\nuint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffffff;\nuint constant gasprice_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff;\n\nlibrary Library {\n  function to_struct(t __packed) internal pure returns (OfferDetailStruct memory __s) { unchecked {\n    __s.maker = address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\n    __s.gasreq = (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\n    __s.offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __s.gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function unpack(t __packed) internal pure returns (address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) { unchecked {\n    __maker = address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\n    __gasreq = (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\n    __offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n\n  function maker(t __packed) internal pure returns(address) { unchecked {\n    return address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\n  }}\n  function maker(t __packed,address val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & maker_mask)\n                  | ((uint(uint160(val)) << (256-maker_bits) >> maker_before)));\n  }}\n  function gasreq(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\n  }}\n  function gasreq(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasreq_mask)\n                  | ((val << (256-gasreq_bits) >> gasreq_before)));\n  }}\n  function offer_gasbase(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n  }}\n  function offer_gasbase(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & offer_gasbase_mask)\n                  | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\n  }}\n  function gasprice(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n  function gasprice(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasprice_mask)\n                  | ((val << (256-gasprice_bits) >> gasprice_before)));\n  }}\n}\n\nfunction t_of_struct(OfferDetailStruct memory __s) pure returns (t) { unchecked {\n  return pack(__s.maker, __s.gasreq, __s.offer_gasbase, __s.gasprice);\n}}\n\nfunction pack(address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) pure returns (t) { unchecked {\n  return t.wrap(((((0\n                | ((uint(uint160(__maker)) << (256-maker_bits)) >> maker_before))\n                | ((__gasreq << (256-gasreq_bits)) >> gasreq_before))\n                | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\n                | ((__gasprice << (256-gasprice_bits)) >> gasprice_before)));\n}}"
    },
    "contracts/preprocessed/MgvGlobal.post.sol": {
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: Unlicense\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n// fields are of the form [name,bits,type]\n\nimport \"./MgvStructs.post.sol\";\n\n// struct_defs are of the form [name,obj]\n\n/* ************************************************** *\n            GENERATED FILE. DO NOT EDIT.\n * ************************************************** */\n\n//some type safety for each struct\ntype t is uint;\nusing Library for t global;\n\nuint constant monitor_bits   = 160;\nuint constant useOracle_bits = 8;\nuint constant notify_bits    = 8;\nuint constant gasprice_bits  = 16;\nuint constant gasmax_bits    = 24;\nuint constant dead_bits      = 8;\n\nuint constant monitor_before   = 0;\nuint constant useOracle_before = monitor_before   + monitor_bits  ;\nuint constant notify_before    = useOracle_before + useOracle_bits;\nuint constant gasprice_before  = notify_before    + notify_bits   ;\nuint constant gasmax_before    = gasprice_before  + gasprice_bits ;\nuint constant dead_before      = gasmax_before    + gasmax_bits   ;\n\nuint constant monitor_mask   = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\nuint constant useOracle_mask = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\nuint constant notify_mask    = 0xffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff;\nuint constant gasprice_mask  = 0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff;\nuint constant gasmax_mask    = 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff;\nuint constant dead_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffff;\n\nlibrary Library {\n  function to_struct(t __packed) internal pure returns (GlobalStruct memory __s) { unchecked {\n    __s.monitor = address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\n    __s.useOracle = (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\n    __s.notify = (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\n    __s.gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n    __s.gasmax = (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\n    __s.dead = (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function unpack(t __packed) internal pure returns (address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) { unchecked {\n    __monitor = address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\n    __useOracle = (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\n    __notify = (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\n    __gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n    __gasmax = (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\n    __dead = (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\n  }}\n\n  function monitor(t __packed) internal pure returns(address) { unchecked {\n    return address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\n  }}\n  function monitor(t __packed,address val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & monitor_mask)\n                  | ((uint(uint160(val)) << (256-monitor_bits) >> monitor_before)));\n  }}\n  function useOracle(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\n  }}\n  function useOracle(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & useOracle_mask)\n                  | ((uint_of_bool(val) << (256-useOracle_bits) >> useOracle_before)));\n  }}\n  function notify(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\n  }}\n  function notify(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & notify_mask)\n                  | ((uint_of_bool(val) << (256-notify_bits) >> notify_before)));\n  }}\n  function gasprice(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\n  }}\n  function gasprice(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasprice_mask)\n                  | ((val << (256-gasprice_bits) >> gasprice_before)));\n  }}\n  function gasmax(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\n  }}\n  function gasmax(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & gasmax_mask)\n                  | ((val << (256-gasmax_bits) >> gasmax_before)));\n  }}\n  function dead(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\n  }}\n  function dead(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & dead_mask)\n                  | ((uint_of_bool(val) << (256-dead_bits) >> dead_before)));\n  }}\n}\n\nfunction t_of_struct(GlobalStruct memory __s) pure returns (t) { unchecked {\n  return pack(__s.monitor, __s.useOracle, __s.notify, __s.gasprice, __s.gasmax, __s.dead);\n}}\n\nfunction pack(address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) pure returns (t) { unchecked {\n  return t.wrap(((((((0\n                | ((uint(uint160(__monitor)) << (256-monitor_bits)) >> monitor_before))\n                | ((uint_of_bool(__useOracle) << (256-useOracle_bits)) >> useOracle_before))\n                | ((uint_of_bool(__notify) << (256-notify_bits)) >> notify_before))\n                | ((__gasprice << (256-gasprice_bits)) >> gasprice_before))\n                | ((__gasmax << (256-gasmax_bits)) >> gasmax_before))\n                | ((uint_of_bool(__dead) << (256-dead_bits)) >> dead_before)));\n}}"
    },
    "contracts/preprocessed/MgvLocal.post.sol": {
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: Unlicense\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n// fields are of the form [name,bits,type]\n\nimport \"./MgvStructs.post.sol\";\n\n// struct_defs are of the form [name,obj]\n\n/* ************************************************** *\n            GENERATED FILE. DO NOT EDIT.\n * ************************************************** */\n\n//some type safety for each struct\ntype t is uint;\nusing Library for t global;\n\nuint constant active_bits        = 8;\nuint constant fee_bits           = 16;\nuint constant density_bits       = 112;\nuint constant offer_gasbase_bits = 24;\nuint constant lock_bits          = 8;\nuint constant best_bits          = 32;\nuint constant last_bits          = 32;\n\nuint constant active_before        = 0;\nuint constant fee_before           = active_before        + active_bits       ;\nuint constant density_before       = fee_before           + fee_bits          ;\nuint constant offer_gasbase_before = density_before       + density_bits      ;\nuint constant lock_before          = offer_gasbase_before + offer_gasbase_bits;\nuint constant best_before          = lock_before          + lock_bits         ;\nuint constant last_before          = best_before          + best_bits         ;\n\nuint constant active_mask        = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\nuint constant fee_mask           = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\nuint constant density_mask       = 0xffffff0000000000000000000000000000ffffffffffffffffffffffffffffff;\nuint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffff000000ffffffffffffffffffffffff;\nuint constant lock_mask          = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\nuint constant best_mask          = 0xffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffffff;\nuint constant last_mask          = 0xffffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffff;\n\nlibrary Library {\n  function to_struct(t __packed) internal pure returns (LocalStruct memory __s) { unchecked {\n    __s.active = (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\n    __s.fee = (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\n    __s.density = (t.unwrap(__packed) << density_before) >> (256-density_bits);\n    __s.offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __s.lock = (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\n    __s.best = (t.unwrap(__packed) << best_before) >> (256-best_bits);\n    __s.last = (t.unwrap(__packed) << last_before) >> (256-last_bits);\n  }}\n\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\n  }}\n\n  function unpack(t __packed) internal pure returns (bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) { unchecked {\n    __active = (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\n    __fee = (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\n    __density = (t.unwrap(__packed) << density_before) >> (256-density_bits);\n    __offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n    __lock = (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\n    __best = (t.unwrap(__packed) << best_before) >> (256-best_bits);\n    __last = (t.unwrap(__packed) << last_before) >> (256-last_bits);\n  }}\n\n  function active(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\n  }}\n  function active(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & active_mask)\n                  | ((uint_of_bool(val) << (256-active_bits) >> active_before)));\n  }}\n  function fee(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\n  }}\n  function fee(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & fee_mask)\n                  | ((val << (256-fee_bits) >> fee_before)));\n  }}\n  function density(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << density_before) >> (256-density_bits);\n  }}\n  function density(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & density_mask)\n                  | ((val << (256-density_bits) >> density_before)));\n  }}\n  function offer_gasbase(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\n  }}\n  function offer_gasbase(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & offer_gasbase_mask)\n                  | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\n  }}\n  function lock(t __packed) internal pure returns(bool) { unchecked {\n    return (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\n  }}\n  function lock(t __packed,bool val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & lock_mask)\n                  | ((uint_of_bool(val) << (256-lock_bits) >> lock_before)));\n  }}\n  function best(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << best_before) >> (256-best_bits);\n  }}\n  function best(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & best_mask)\n                  | ((val << (256-best_bits) >> best_before)));\n  }}\n  function last(t __packed) internal pure returns(uint) { unchecked {\n    return (t.unwrap(__packed) << last_before) >> (256-last_bits);\n  }}\n  function last(t __packed,uint val) internal pure returns(t) { unchecked {\n    return t.wrap((t.unwrap(__packed) & last_mask)\n                  | ((val << (256-last_bits) >> last_before)));\n  }}\n}\n\nfunction t_of_struct(LocalStruct memory __s) pure returns (t) { unchecked {\n  return pack(__s.active, __s.fee, __s.density, __s.offer_gasbase, __s.lock, __s.best, __s.last);\n}}\n\nfunction pack(bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) pure returns (t) { unchecked {\n  return t.wrap((((((((0\n                | ((uint_of_bool(__active) << (256-active_bits)) >> active_before))\n                | ((__fee << (256-fee_bits)) >> fee_before))\n                | ((__density << (256-density_bits)) >> density_before))\n                | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\n                | ((uint_of_bool(__lock) << (256-lock_bits)) >> lock_before))\n                | ((__best << (256-best_bits)) >> best_before))\n                | ((__last << (256-last_bits)) >> last_before)));\n}}"
    },
    "contracts/MgvHasOffers.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvHasOffers.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor, P} from \"./MgvLib.sol\";\nimport {MgvRoot} from \"./MgvRoot.sol\";\n\n/* `MgvHasOffers` contains the state variables and functions common to both market-maker operations and market-taker operations. Mostly: storing offers, removing them, updating market makers' provisions. */\ncontract MgvHasOffers is MgvRoot {\n  /* # State variables */\n  /* Given a `outbound_tkn`,`inbound_tkn` pair, the mappings `offers` and `offerDetails` associate two 256 bits words to each offer id. Those words encode information detailed in [`structs.js`](#structs.js).\n\n     The mappings are `outbound_tkn => inbound_tkn => offerId => P.Offer.t|P.OfferDetail.t`.\n   */\n  mapping(address => mapping(address => mapping(uint => P.Offer.t)))\n    public offers;\n  mapping(address => mapping(address => mapping(uint => P.OfferDetail.t)))\n    public offerDetails;\n\n  /* Makers provision their possible penalties in the `balanceOf` mapping.\n\n       Offers specify the amount of gas they require for successful execution ([`gasreq`](#structs.js/gasreq)). To minimize book spamming, market makers must provision a *penalty*, which depends on their `gasreq` and on the pair's [`offer_gasbase`](#structs.js/gasbase). This provision is deducted from their `balanceOf`. If an offer fails, part of that provision is given to the taker, as retribution. The exact amount depends on the gas used by the offer before failing.\n\n       The Mangrove keeps track of their available balance in the `balanceOf` map, which is decremented every time a maker creates a new offer, and may be modified on offer updates/cancelations/takings.\n     */\n  mapping(address => uint) public balanceOf;\n\n  /* # Read functions */\n  /* Convenience function to get best offer of the given pair */\n  function best(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint)\n  {\n    unchecked {\n      P.Local.t local = locals[outbound_tkn][inbound_tkn];\n      return local.best();\n    }\n  }\n\n  /* Returns information about an offer in ABI-compatible structs. Do not use internally, would be a huge memory-copying waste. Use `offers[outbound_tkn][inbound_tkn]` and `offerDetails[outbound_tkn][inbound_tkn]` instead. */\n  function offerInfo(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  )\n    external\n    view\n    returns (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail)\n  {\n    unchecked {\n      P.Offer.t _offer = offers[outbound_tkn][inbound_tkn][offerId];\n      offer = _offer.to_struct();\n\n      P.OfferDetail.t _offerDetail = offerDetails[outbound_tkn][inbound_tkn][\n        offerId\n      ];\n      offerDetail = _offerDetail.to_struct();\n    }\n  }\n\n  /* # Provision debit/credit utility functions */\n  /* `balanceOf` is in wei of ETH. */\n\n  function debitWei(address maker, uint amount) internal {\n    unchecked {\n      uint makerBalance = balanceOf[maker];\n      require(makerBalance >= amount, \"mgv/insufficientProvision\");\n      balanceOf[maker] = makerBalance - amount;\n      emit Debit(maker, amount);\n    }\n  }\n\n  function creditWei(address maker, uint amount) internal {\n    unchecked {\n      balanceOf[maker] += amount;\n      emit Credit(maker, amount);\n    }\n  }\n\n  /* # Misc. low-level functions */\n  /* ## Offer deletion */\n\n  /* When an offer is deleted, it is marked as such by setting `gives` to 0. Note that provision accounting in the Mangrove aims to minimize writes. Each maker `fund`s the Mangrove to increase its balance. When an offer is created/updated, we compute how much should be reserved to pay for possible penalties. That amount can always be recomputed with `offerDetail.gasprice * (offerDetail.gasreq + offerDetail.offer_gasbase)`. The balance is updated to reflect the remaining available ethers.\n\n     Now, when an offer is deleted, the offer can stay provisioned, or be `deprovision`ed. In the latter case, we set `gasprice` to 0, which induces a provision of 0. All code calling `dirtyDeleteOffer` with `deprovision` set to `true` must be careful to correctly account for where that provision is going (back to the maker's `balanceOf`, or sent to a taker as compensation). */\n  function dirtyDeleteOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    P.Offer.t offer,\n    P.OfferDetail.t offerDetail,\n    bool deprovision\n  ) internal {\n    unchecked {\n      offer = offer.gives(0);\n      if (deprovision) {\n        offerDetail = offerDetail.gasprice(0);\n      }\n      offers[outbound_tkn][inbound_tkn][offerId] = offer;\n      offerDetails[outbound_tkn][inbound_tkn][offerId] = offerDetail;\n    }\n  }\n\n  /* ## Stitching the orderbook */\n\n  /* Connect the offers `betterId` and `worseId` through their `next`/`prev` pointers. For more on the book structure, see [`structs.js`](#structs.js). Used after executing an offer (or a segment of offers), after removing an offer, or moving an offer.\n\n  **Warning**: calling with `betterId = 0` will set `worseId` as the best. So with `betterId = 0` and `worseId = 0`, it sets the book to empty and loses track of existing offers.\n\n  **Warning**: may make memory copy of `local.best` stale. Returns new `local`. */\n  function stitchOffers(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint betterId,\n    uint worseId,\n    P.Local.t local\n  ) internal returns (P.Local.t) {\n    unchecked {\n      if (betterId != 0) {\n        offers[outbound_tkn][inbound_tkn][betterId] = offers[outbound_tkn][\n          inbound_tkn\n        ][betterId].next(worseId);\n      } else {\n        local = local.best(worseId);\n      }\n\n      if (worseId != 0) {\n        offers[outbound_tkn][inbound_tkn][worseId] = offers[outbound_tkn][\n          inbound_tkn\n        ][worseId].prev(betterId);\n      }\n\n      return local;\n    }\n  }\n\n  /* ## Check offer is live */\n  /* Check whether an offer is 'live', that is: inserted in the order book. The Mangrove holds a `outbound_tkn => inbound_tkn => id => P.Offer.t` mapping in storage. Offer ids that are not yet assigned or that point to since-deleted offer will point to an offer with `gives` field at 0. */\n  function isLive(P.Offer.t offer) public pure returns (bool) {\n    unchecked {\n      return offer.gives() > 0;\n    }\n  }\n}\n"
    },
    "contracts/MgvRoot.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvRoot.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* `MgvRoot` and its descendants describe an orderbook-based exchange (\"the Mangrove\") where market makers *do not have to provision their offer*. See `structs.js` for a longer introduction. In a nutshell: each offer created by a maker specifies an address (`maker`) to call upon offer execution by a taker. In the normal mode of operation, the Mangrove transfers the amount to be paid by the taker to the maker, calls the maker, attempts to transfer the amount promised by the maker to the taker, and reverts if it cannot.\n\n   There is one Mangrove contract that manages all tradeable pairs. This reduces deployment costs for new pairs and lets market makers have all their provision for all pairs in the same place.\n\n   The interaction map between the different actors is as follows:\n   <img src=\"./contactMap.png\" width=\"190%\"></img>\n\n   The sequence diagram of a market order is as follows:\n   <img src=\"./sequenceChart.png\" width=\"190%\"></img>\n\n   There is a secondary mode of operation in which the _maker_ flashloans the sold amount to the taker.\n\n   The Mangrove contract is `abstract` and accomodates both modes. Two contracts, `Mangrove` and `InvertedMangrove` inherit from it, one per mode of operation.\n\n   The contract structure is as follows:\n   <img src=\"./modular_mangrove.svg\" width=\"180%\"> </img>\n */\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor, P} from \"./MgvLib.sol\";\n\n/* `MgvRoot` contains state variables used everywhere in the operation of the Mangrove and their related function. */\ncontract MgvRoot is HasMgvEvents {\n\n  /* # State variables */\n  //+clear+\n  /* The `vault` address. If a pair has fees >0, those fees are sent to the vault. */\n  address public vault;\n\n  /* Global mgv configuration, encoded in a 256 bits word. The information encoded is detailed in [`structs.js`](#structs.js). */\n  P.Global.t internal internal_global;\n  /* Configuration mapping for each token pair of the form `outbound_tkn => inbound_tkn => P.Local.t`. The structure of each `P.Local.t` value is detailed in [`structs.js`](#structs.js). It fits in one word. */\n  mapping(address => mapping(address => P.Local.t)) internal locals;\n\n  /* Checking the size of `density` is necessary to prevent overflow when `density` is used in calculations. */\n  function checkDensity(uint density) internal pure returns (bool) {\n    unchecked {\n      return uint112(density) == density;\n    }\n  }\n\n  /* Checking the size of `gasprice` is necessary to prevent a) data loss when `gasprice` is copied to an `OfferDetail` struct, and b) overflow when `gasprice` is used in calculations. */\n  function checkGasprice(uint gasprice) internal pure returns (bool) {\n    unchecked {\n      return uint16(gasprice) == gasprice;\n    }\n  }\n\n  /* # Configuration Reads */\n  /* Reading the configuration for a pair involves reading the config global to all pairs and the local one. In addition, a global parameter (`gasprice`) and a local one (`density`) may be read from the oracle. */\n  function config(address outbound_tkn, address inbound_tkn)\n    public\n    view\n    returns (P.Global.t _global, P.Local.t _local)\n  {\n    unchecked {\n      _global = internal_global;\n      _local = locals[outbound_tkn][inbound_tkn];\n      if (_global.useOracle()) {\n        (uint gasprice, uint density) = IMgvMonitor(_global.monitor()).read(\n          outbound_tkn,\n          inbound_tkn\n        );\n        if (checkGasprice(gasprice)) {\n          _global = _global.gasprice(gasprice);\n        }\n        if (checkDensity(density)) {\n          _local = _local.density(density);\n        }\n      }\n    }\n  }\n\n  /* Returns the configuration in an ABI-compatible struct. Should not be called internally, would be a huge memory copying waste. Use `config` instead. */\n  function configInfo(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (P.GlobalStruct memory global, P.LocalStruct memory local)\n  {\n    unchecked {\n      (P.Global.t _global, P.Local.t _local) = config(\n        outbound_tkn,\n        inbound_tkn\n      );\n      global = _global.to_struct();\n      local = _local.to_struct();\n    }\n  }\n\n  /* Convenience function to check whether given pair is locked */\n  function locked(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (bool)\n  {\n    P.Local.t local = locals[outbound_tkn][inbound_tkn];\n    return local.lock();\n  }\n\n  /*\n  # Gatekeeping\n\n  Gatekeeping functions are safety checks called in various places.\n  */\n\n  /* `unlockedMarketOnly` protects modifying the market while an order is in progress. Since external contracts are called during orders, allowing reentrancy would, for instance, let a market maker replace offers currently on the book with worse ones. Note that the external contracts _will_ be called again after the order is complete, this time without any lock on the market.  */\n  function unlockedMarketOnly(P.Local.t local) internal pure {\n    require(!local.lock(), \"mgv/reentrancyLocked\");\n  }\n\n  /* <a id=\"Mangrove/definition/liveMgvOnly\"></a>\n     In case of emergency, the Mangrove can be `kill`ed. It cannot be resurrected. When a Mangrove is dead, the following operations are disabled :\n       * Executing an offer\n       * Sending ETH to the Mangrove the normal way. Usual [shenanigans](https://medium.com/@alexsherbuck/two-ways-to-force-ether-into-a-contract-1543c1311c56) are possible.\n       * Creating a new offer\n   */\n  function liveMgvOnly(P.Global.t _global) internal pure {\n    require(!_global.dead(), \"mgv/dead\");\n  }\n\n  /* When the Mangrove is deployed, all pairs are inactive by default (since `locals[outbound_tkn][inbound_tkn]` is 0 by default). Offers on inactive pairs cannot be taken or created. They can be updated and retracted. */\n  function activeMarketOnly(P.Global.t _global, P.Local.t _local)\n    internal\n    pure\n  {\n    liveMgvOnly(_global);\n    require(_local.active(), \"mgv/inactive\");\n  }\n}\n"
    },
    "contracts/MgvOfferTaking.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferTaking.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {IERC20, HasMgvEvents, IMaker, IMgvMonitor, MgvLib as ML, P} from \"./MgvLib.sol\";\nimport {MgvHasOffers} from \"./MgvHasOffers.sol\";\n\nabstract contract MgvOfferTaking is MgvHasOffers {\n  /* # MultiOrder struct */\n  /* The `MultiOrder` struct is used by market orders and snipes. Some of its fields are only used by market orders (`initialWants, initialGives`). We need a common data structure for both since low-level calls are shared between market orders and snipes. The struct is helpful in decreasing stack use. */\n  struct MultiOrder {\n    uint initialWants; // used globally by market order, not used by snipes\n    uint initialGives; // used globally by market order, not used by snipes\n    uint totalGot; // used globally by market order, per-offer by snipes\n    uint totalGave; // used globally by market order, per-offer by snipes\n    uint totalPenalty; // used globally\n    address taker; // used globally\n    bool fillWants; // used globally\n    uint feePaid; // used globally\n  }\n\n  /* # Market Orders */\n\n  /* ## Market Order */\n  //+clear+\n\n  /* A market order specifies a (`outbound_tkn`,`inbound_tkn`) pair, a desired total amount of `outbound_tkn` (`takerWants`), and an available total amount of `inbound_tkn` (`takerGives`). It returns four `uint`s: the total amount of `outbound_tkn` received, the total amount of `inbound_tkn` spent, the penalty received by msg.sender (in wei), and the fee paid by the taker (in wei).\n\n     The `takerGives/takerWants` ratio induces a maximum average price that the taker is ready to pay across all offers that will be executed during the market order. It is thus possible to execute an offer with a price worse than the initial (`takerGives`/`takerWants`) ratio given as argument to `marketOrder` if some cheaper offers were executed earlier in the market order.\n\n  The market order stops when the price has become too high, or when the end of the book has been reached, or:\n  * If `fillWants` is true, the market order stops when `takerWants` units of `outbound_tkn` have been obtained. With `fillWants` set to true, to buy a specific volume of `outbound_tkn` at any price, set `takerWants` to the amount desired and `takerGives` to $2^{160}-1$.\n  * If `fillWants` is false, the taker is filling `gives` instead: the market order stops when `takerGives` units of `inbound_tkn` have been sold. With `fillWants` set to false, to sell a specific volume of `inbound_tkn` at any price, set `takerGives` to the amount desired and `takerWants` to $0$. */\n  function marketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants\n  )\n    external\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    unchecked {\n      return\n        generalMarketOrder(\n          outbound_tkn,\n          inbound_tkn,\n          takerWants,\n          takerGives,\n          fillWants,\n          msg.sender\n        );\n    }\n  }\n\n  /* # General Market Order */\n  //+clear+\n  /* General market orders set up the market order with a given `taker` (`msg.sender` in the most common case). Returns `(totalGot, totalGave, penaltyReceived, feePaid)`.\n  Note that the `taker` can be anyone. This is safe when `taker == msg.sender`, but `generalMarketOrder` must not be called with `taker != msg.sender` unless a security check is done after (see [`MgvOfferTakingWithPermit`](#mgvoffertakingwithpermit.sol)`. */\n  function generalMarketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  )\n    internal\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    unchecked {\n      /* Since amounts stored in offers are 96 bits wide, checking that `takerWants` and `takerGives` fit in 160 bits prevents overflow during the main market order loop. */\n      require(\n        uint160(takerWants) == takerWants,\n        \"mgv/mOrder/takerWants/160bits\"\n      );\n      require(\n        uint160(takerGives) == takerGives,\n        \"mgv/mOrder/takerGives/160bits\"\n      );\n\n      /* `SingleOrder` is defined in `MgvLib.sol` and holds information for ordering the execution of one offer. */\n      ML.SingleOrder memory sor;\n      sor.outbound_tkn = outbound_tkn;\n      sor.inbound_tkn = inbound_tkn;\n      (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\n      /* Throughout the execution of the market order, the `sor`'s offer id and other parameters will change. We start with the current best offer id (0 if the book is empty). */\n      sor.offerId = sor.local.best();\n      sor.offer = offers[outbound_tkn][inbound_tkn][sor.offerId];\n      /* `sor.wants` and `sor.gives` may evolve, but they are initially however much remains in the market order. */\n      sor.wants = takerWants;\n      sor.gives = takerGives;\n\n      /* `MultiOrder` (defined above) maintains information related to the entire market order. During the order, initial `wants`/`gives` values minus the accumulated amounts traded so far give the amounts that remain to be traded. */\n      MultiOrder memory mor;\n      mor.initialWants = takerWants;\n      mor.initialGives = takerGives;\n      mor.taker = taker;\n      mor.fillWants = fillWants;\n\n      /* For the market order to even start, the market needs to be both active, and not currently protected from reentrancy. */\n      activeMarketOnly(sor.global, sor.local);\n      unlockedMarketOnly(sor.local);\n\n      /* ### Initialization */\n      /* The market order will operate as follows : it will go through offers from best to worse, starting from `offerId`, and: */\n      /* * will maintain remaining `takerWants` and `takerGives` values. The initial `takerGives/takerWants` ratio is the average price the taker will accept. Better prices may be found early in the book, and worse ones later.\n       * will not set `prev`/`next` pointers to their correct locations at each offer taken (this is an optimization enabled by forbidding reentrancy).\n       * after consuming a segment of offers, will update the current `best` offer to be the best remaining offer on the book. */\n\n      /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\n      sor.local = sor.local.lock(true);\n      locals[outbound_tkn][inbound_tkn] = sor.local;\n\n      emit OrderStart();\n\n      /* Call recursive `internalMarketOrder` function.*/\n      internalMarketOrder(mor, sor, true);\n\n      /* Over the course of the market order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\n      sendPenalty(mor.totalPenalty);\n\n      emit OrderComplete(\n        outbound_tkn,\n        inbound_tkn,\n        taker,\n        mor.totalGot,\n        mor.totalGave,\n        mor.totalPenalty,\n        mor.feePaid\n      );\n\n      //+clear+\n      return (mor.totalGot, mor.totalGave, mor.totalPenalty, mor.feePaid);\n    }\n  }\n\n  /* ## Internal market order */\n  //+clear+\n  /* `internalMarketOrder` works recursively. Going downward, each successive offer is executed until the market order stops (due to: volume exhausted, bad price, or empty book). Then the [reentrancy lock is lifted](#internalMarketOrder/liftReentrancy). Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book.\n\n    The last argument is a boolean named `proceed`. If an offer was not executed, it means the price has become too high. In that case, we notify the next recursive call that the market order should end. In this initial call, no offer has been executed yet so `proceed` is true. */\n  function internalMarketOrder(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    bool proceed\n  ) internal {\n    unchecked {\n      /* #### Case 1 : End of order */\n      /* We execute the offer currently stored in `sor`. */\n      if (\n        proceed &&\n        (mor.fillWants ? sor.wants > 0 : sor.gives > 0) &&\n        sor.offerId > 0\n      ) {\n        uint gasused; // gas used by `makerExecute`\n        bytes32 makerData; // data returned by maker\n\n        /* <a id=\"MgvOfferTaking/statusCodes\"></a> `mgvData` is an internal Mangrove status code. It may appear in an [`OrderResult`](#MgvLib/OrderResult). Its possible values are:\n      * `\"mgv/notExecuted\"`: offer was not executed.\n      * `\"mgv/tradeSuccess\"`: offer execution succeeded. Will appear in `OrderResult`.\n      * `\"mgv/notEnoughGasForMakerTrade\"`: cannot give maker close enough to `gasreq`. Triggers a revert of the entire order.\n      * `\"mgv/makerRevert\"`: execution of `makerExecute` reverted. Will appear in `OrderResult`.\n      * `\"mgv/makerTransferFail\"`: maker could not send outbound_tkn tokens. Will appear in `OrderResult`.\n      * `\"mgv/makerReceiveFail\"`: maker could not receive inbound_tkn tokens. Will appear in `OrderResult`.\n      * `\"mgv/takerTransferFail\"`: taker could not send inbound_tkn tokens. Triggers a revert of the entire order.\n\n      `mgvData` should not be exploitable by the maker! */\n        bytes32 mgvData;\n\n        /* Load additional information about the offer. We don't do it earlier to save one storage read in case `proceed` was false. */\n        sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\n          sor.offerId\n        ];\n\n        /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way, [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` means the failure is the maker's fault. */\n        /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. We will need it after the recursive call, so we save it in local variables. Same goes for `offerId`, `sor.offer` and `sor.offerDetail`. */\n\n        (gasused, makerData, mgvData) = execute(mor, sor);\n\n        /* Keep cached copy of current `sor` values. */\n        uint takerWants = sor.wants;\n        uint takerGives = sor.gives;\n        uint offerId = sor.offerId;\n        P.Offer.t offer = sor.offer;\n        P.OfferDetail.t offerDetail = sor.offerDetail;\n\n        /* If an execution was attempted, we move `sor` to the next offer. Note that the current state is inconsistent, since we have not yet updated `sor.offerDetails`. */\n        if (mgvData != \"mgv/notExecuted\") {\n          sor.wants = mor.initialWants > mor.totalGot\n            ? mor.initialWants - mor.totalGot\n            : 0;\n          /* It is known statically that `mor.initialGives - mor.totalGave` does not underflow since\n           1. `mor.totalGave` was increased by `sor.gives` during `execute`,\n           2. `sor.gives` was at most `mor.initialGives - mor.totalGave` from earlier step,\n           3. `sor.gives` may have been clamped _down_ during `execute` (to \"`offer.wants`\" if the offer is entirely consumed, or to `makerWouldWant`, cf. code of `execute`).\n        */\n          sor.gives = mor.initialGives - mor.totalGave;\n          sor.offerId = sor.offer.next();\n          sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\n        }\n\n        /* note that internalMarketOrder may be called twice with same offerId, but in that case `proceed` will be false! */\n        internalMarketOrder(\n          mor,\n          sor,\n          /* `proceed` value for next call. Currently, when an offer did not execute, it's because the offer's price was too high. In that case we interrupt the loop and let the taker leave with less than they asked for (but at a correct price). We could also revert instead of breaking; this could be a configurable flag for the taker to pick. */\n          mgvData != \"mgv/notExecuted\"\n        );\n\n        /* Restore `sor` values from to before recursive call */\n        sor.offerId = offerId;\n        sor.wants = takerWants;\n        sor.gives = takerGives;\n        sor.offer = offer;\n        sor.offerDetail = offerDetail;\n\n        /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\n        if (mgvData != \"mgv/notExecuted\") {\n          postExecute(mor, sor, gasused, makerData, mgvData);\n        }\n\n        /* #### Case 2 : End of market order */\n        /* If `proceed` is false, the taker has gotten its requested volume, or we have reached the end of the book, we conclude the market order. */\n      } else {\n        /* During the market order, all executed offers have been removed from the book. We end by stitching together the `best` offer pointer and the new best offer. */\n        sor.local = stitchOffers(\n          sor.outbound_tkn,\n          sor.inbound_tkn,\n          0,\n          sor.offerId,\n          sor.local\n        );\n        /* <a id=\"internalMarketOrder/liftReentrancy\"></a>Now that the market order is over, we can lift the lock on the book. In the same operation we\n\n      * lift the reentrancy lock, and\n      * update the storage\n\n      so we are free from out of order storage writes.\n      */\n        sor.local = sor.local.lock(false);\n        locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n\n        /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\n        payTakerMinusFees(mor, sor);\n\n        /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\n        executeEnd(mor, sor);\n      }\n    }\n  }\n\n  /* # Sniping */\n  /* ## Snipes */\n  //+clear+\n\n  /* `snipes` executes multiple offers. It takes a `uint[4][]` as penultimate argument, with each array element of the form `[offerId,takerWants,takerGives,offerGasreq]`. The return parameters are of the form `(successes,snipesGot,snipesGave,bounty,feePaid)`. \n  Note that we do not distinguish further between mismatched arguments/offer fields on the one hand, and an execution failure on the other. Still, a failed offer has to pay a penalty, and ultimately transaction logs explicitly mention execution failures (see `MgvLib.sol`). */\n  function snipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants\n  )\n    external\n    returns (\n      uint,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    unchecked {\n      return\n        generalSnipes(\n          outbound_tkn,\n          inbound_tkn,\n          targets,\n          fillWants,\n          msg.sender\n        );\n    }\n  }\n\n  /*\n     From an array of _n_ `[offerId, takerWants,takerGives,gasreq]` elements, execute each snipe in sequence. Returns `(successes, takerGot, takerGave, bounty, feePaid)`. \n\n     Note that if this function is not internal, anyone can make anyone use Mangrove.\n     Note that unlike general market order, the returned total values are _not_ `mor.totalGot` and `mor.totalGave`, since those are reset at every iteration of the `targets` array. Instead, accumulators `snipesGot` and `snipesGave` are used. */\n  function generalSnipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    internal\n    returns (\n      uint successCount,\n      uint snipesGot,\n      uint snipesGave,\n      uint totalPenalty,\n      uint feePaid\n    )\n  {\n    unchecked {\n      ML.SingleOrder memory sor;\n      sor.outbound_tkn = outbound_tkn;\n      sor.inbound_tkn = inbound_tkn;\n      (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\n\n      MultiOrder memory mor;\n      mor.taker = taker;\n      mor.fillWants = fillWants;\n\n      /* For the snipes to even start, the market needs to be both active and not currently protected from reentrancy. */\n      activeMarketOnly(sor.global, sor.local);\n      unlockedMarketOnly(sor.local);\n\n      emit OrderStart();\n\n      /* ### Main loop */\n      //+clear+\n\n      /* Call `internalSnipes` function. */\n      (successCount, snipesGot, snipesGave) = internalSnipes(mor, sor, targets);\n\n      /* Over the course of the snipes order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\n      sendPenalty(mor.totalPenalty);\n      //+clear+\n\n      emit OrderComplete(\n        sor.outbound_tkn,\n        sor.inbound_tkn,\n        taker,\n        snipesGot,\n        snipesGave,\n        mor.totalPenalty,\n        mor.feePaid\n      );\n      totalPenalty = mor.totalPenalty;\n      feePaid = mor.feePaid;\n    }\n  }\n\n  /* ## Internal snipes */\n  //+clear+\n  /* `internalSnipes` works by looping over targets. Each successive offer is executed under a [reentrancy lock](#internalSnipes/liftReentrancy), then its posthook is called. Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book. */\n  function internalSnipes(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    uint[4][] calldata targets\n  )\n    internal\n    returns (\n      uint successCount,\n      uint snipesGot,\n      uint snipesGave\n    )\n  {\n    unchecked {\n      for (uint i = 0; i < targets.length; i++) {\n        /* Reset these amounts since every snipe is treated individually. Only the total penalty is sent at the end of all snipes. */\n        mor.totalGot = 0;\n        mor.totalGave = 0;\n\n        /* Initialize single order struct. */\n        sor.offerId = targets[i][0];\n        sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\n        sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\n          sor.offerId\n        ];\n\n        /* If we removed the `isLive` conditional, a single expired or nonexistent offer in `targets` would revert the entire transaction (by the division by `offer.gives` below since `offer.gives` would be 0). We also check that `gasreq` is not worse than specified. A taker who does not care about `gasreq` can specify any amount larger than $2^{24}-1$. A mismatched price will be detected by `execute`. */\n        if (!isLive(sor.offer) || sor.offerDetail.gasreq() > targets[i][3]) {\n          /* We move on to the next offer in the array. */\n          continue;\n        } else {\n          require(\n            uint96(targets[i][1]) == targets[i][1],\n            \"mgv/snipes/takerWants/96bits\"\n          );\n          require(\n            uint96(targets[i][2]) == targets[i][2],\n            \"mgv/snipes/takerGives/96bits\"\n          );\n          sor.wants = targets[i][1];\n          sor.gives = targets[i][2];\n\n          /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\n          sor.local = sor.local.lock(true);\n          locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n\n          /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\"mgv/tradeSuccess\",\"mgv/notExecuted\"]` means the failure is the maker's fault. */\n          /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. */\n          (uint gasused, bytes32 makerData, bytes32 mgvData) = execute(\n            mor,\n            sor\n          );\n\n          if (mgvData == \"mgv/tradeSuccess\") {\n            successCount += 1;\n          }\n\n          /* In the market order, we were able to avoid stitching back offers after every `execute` since we knew a continuous segment starting at best would be consumed. Here, we cannot do this optimisation since offers in the `targets` array may be anywhere in the book. So we stitch together offers immediately after each `execute`. */\n          if (mgvData != \"mgv/notExecuted\") {\n            sor.local = stitchOffers(\n              sor.outbound_tkn,\n              sor.inbound_tkn,\n              sor.offer.prev(),\n              sor.offer.next(),\n              sor.local\n            );\n          }\n\n          /* <a id=\"internalSnipes/liftReentrancy\"></a> Now that the current snipe is over, we can lift the lock on the book. In the same operation we\n        * lift the reentrancy lock, and\n        * update the storage\n\n        so we are free from out of order storage writes.\n        */\n          sor.local = sor.local.lock(false);\n          locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n\n          /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\n          payTakerMinusFees(mor, sor);\n\n          /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\n          executeEnd(mor, sor);\n\n          /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\n          if (mgvData != \"mgv/notExecuted\") {\n            postExecute(mor, sor, gasused, makerData, mgvData);\n          }\n\n          snipesGot += mor.totalGot;\n          snipesGave += mor.totalGave;\n        }\n      }\n    }\n  }\n\n  /* # General execution */\n  /* During a market order or a snipes, offers get executed. The following code takes care of executing a single offer with parameters given by a `SingleOrder` within a larger context given by a `MultiOrder`. */\n\n  /* ## Execute */\n  /* This function will compare `sor.wants` `sor.gives` with `sor.offer.wants` and `sor.offer.gives`. If the price of the offer is low enough, an execution will be attempted (with volume limited by the offer's advertised volume).\n\n     Summary of the meaning of the return values:\n    * `gasused` is the gas consumed by the execution\n    * `makerData` is the data returned after executing the offer\n    * `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes).\n  */\n  function execute(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    returns (\n      uint gasused,\n      bytes32 makerData,\n      bytes32 mgvData\n    )\n  {\n    unchecked {\n      /* #### `Price comparison` */\n      //+clear+\n      /* The current offer has a price `p = offerWants  offerGives` and the taker is ready to accept a price up to `p' = takerGives  takerWants`. Comparing `offerWants * takerWants` and `offerGives * takerGives` tels us whether `p < p'`.\n       */\n      {\n        uint offerWants = sor.offer.wants();\n        uint offerGives = sor.offer.gives();\n        uint takerWants = sor.wants;\n        uint takerGives = sor.gives;\n        /* <a id=\"MgvOfferTaking/checkPrice\"></a>If the price is too high, we return early.\n\n         Otherwise we now know we'll execute the offer. */\n        if (offerWants * takerWants > offerGives * takerGives) {\n          return (0, bytes32(0), \"mgv/notExecuted\");\n        }\n\n        /* ### Specification of value transfers:\n\n      Let $o_w$ be `offerWants`, $o_g$ be `offerGives`, $t_w$ be `takerWants`, $t_g$ be `takerGives`, and `f  {w,g}` be $w$ if `fillWants` is true, $g$ otherwise.\n\n      Let $\\textrm{got}$ be the amount that the taker will receive, and $\\textrm{gave}$ be the amount that the taker will pay.\n\n      #### Case $f = w$\n\n      If $f = w$, let $\\textrm{got} = \\min(o_g,t_w)$, and let $\\textrm{gave} = \\left\\lceil\\dfrac{o_w \\textrm{got}}{o_g}\\right\\rceil$. This is well-defined since, for live offers, $o_g > 0$.\n\n      In plain english, we only give to the taker up to what they wanted (or what the offer has to give), and follow the offer price to determine what the taker will give.\n\n      Since $\\textrm{gave}$ is rounded up, the price might be overevaluated. Still, we cannot spend more than what the taker specified as `takerGives`. At this point [we know](#MgvOfferTaking/checkPrice) that $o_w t_w \\leq o_g t_g$, so since $t_g$ is an integer we have\n      \n      $t_g \\geq \\left\\lceil\\dfrac{o_w t_w}{o_g}\\right\\rceil \\geq \\left\\lceil\\dfrac{o_w \\textrm{got}}{o_g}\\right\\rceil = \\textrm{gave}$.\n\n\n      #### Case $f = g$\n\n      If $f = g$, let $\\textrm{gave} = \\min(o_w,t_g)$, and $\\textrm{got} = o_g$ if $o_w = 0$, $\\textrm{got} = \\left\\lfloor\\dfrac{o_g \\textrm{gave}}{o_w}\\right\\rfloor$ otherwise.\n\n      In plain english, we spend up to what the taker agreed to pay (or what the offer wants), and follow the offer price to determine what the taker will get. This may exceed $t_w$.\n\n      #### Price adjustment\n\n      Prices are rounded up to ensure maker is not drained on small amounts. It's economically unlikely, but `density` protects the taker from being drained anyway so it is better to default towards protecting the maker here.\n      */\n\n        /*\n      ### Implementation\n\n      First we check the cases $(f=w \\wedge o_g < t_w)\\vee(f_g \\wedge o_w < t_g)$, in which case the above spec simplifies to $\\textrm{got} = o_g, \\textrm{gave} = o_w$.\n\n      Otherwise the offer may be partially consumed.\n      \n      In the case $f=w$ we don't touch $\\textrm{got}$ (which was initialized to $t_w$) and compute $\\textrm{gave} = \\left\\lceil\\dfrac{o_w t_w}{o_g}\\right\\rceil$. As shown above we have $\\textrm{gave} \\leq t_g$.\n\n      In the case $f=g$ we don't touch $\\textrm{gave}$ (which was initialized to $t_g$) and compute $\\textrm{got} = o_g$ if $o_w = 0$, and $\\textrm{got} = \\left\\lfloor\\dfrac{o_g t_g}{o_w}\\right\\rfloor$ otherwise.\n      */\n        if (\n          (mor.fillWants && offerGives < takerWants) ||\n          (!mor.fillWants && offerWants < takerGives)\n        ) {\n          sor.wants = offerGives;\n          sor.gives = offerWants;\n        } else {\n          if (mor.fillWants) {\n            uint product = offerWants * takerWants;\n            sor.gives =\n              product /\n              offerGives +\n              (product % offerGives == 0 ? 0 : 1);\n          } else {\n            if (offerWants == 0) {\n              sor.wants = offerGives;\n            } else {\n              sor.wants = (offerGives * takerGives) / offerWants;\n            }\n          }\n        }\n      }\n      /* The flashloan is executed by call to `flashloan`. If the call reverts, it means the maker failed to send back `sor.wants` `outbound_tkn` to the taker. Notes :\n       * `msg.sender` is the Mangrove itself in those calls -- all operations related to the actual caller should be done outside of this call.\n       * any spurious exception due to an error in Mangrove code will be falsely blamed on the Maker, and its provision for the offer will be unfairly taken away.\n       */\n      (bool success, bytes memory retdata) = address(this).call(\n        abi.encodeWithSelector(this.flashloan.selector, sor, mor.taker)\n      );\n\n      /* `success` is true: trade is complete */\n      if (success) {\n        /* In case of success, `retdata` encodes the gas used by the offer. */\n        gasused = abi.decode(retdata, (uint));\n        /* `mgvData` indicates trade success */\n        mgvData = bytes32(\"mgv/tradeSuccess\");\n        emit OfferSuccess(\n          sor.outbound_tkn,\n          sor.inbound_tkn,\n          sor.offerId,\n          mor.taker,\n          sor.wants,\n          sor.gives\n        );\n\n        /* If configured to do so, the Mangrove notifies an external contract that a successful trade has taken place. */\n        if (sor.global.notify()) {\n          IMgvMonitor(sor.global.monitor()).notifySuccess(sor, mor.taker);\n        }\n\n        /* We update the totals in the multiorder based on the adjusted `sor.wants`/`sor.gives`. */\n        /* overflow: sor.{wants,gives} are on 96bits, sor.total{Got,Gave} are on 256 bits. */\n        mor.totalGot += sor.wants;\n        mor.totalGave += sor.gives;\n      } else {\n        /* In case of failure, `retdata` encodes a short [status code](#MgvOfferTaking/statusCodes), the gas used by the offer, and an arbitrary 256 bits word sent by the maker.  */\n        (mgvData, gasused, makerData) = innerDecode(retdata);\n        /* Note that in the `if`s, the literals are bytes32 (stack values), while as revert arguments, they are strings (memory pointers). */\n        if (\n          mgvData == \"mgv/makerRevert\" ||\n          mgvData == \"mgv/makerTransferFail\" ||\n          mgvData == \"mgv/makerReceiveFail\"\n        ) {\n          emit OfferFail(\n            sor.outbound_tkn,\n            sor.inbound_tkn,\n            sor.offerId,\n            mor.taker,\n            sor.wants,\n            sor.gives,\n            mgvData\n          );\n\n          /* If configured to do so, the Mangrove notifies an external contract that a failed trade has taken place. */\n          if (sor.global.notify()) {\n            IMgvMonitor(sor.global.monitor()).notifyFail(sor, mor.taker);\n          }\n          /* It is crucial that any error code which indicates an error caused by the taker triggers a revert, because functions that call `execute` consider that `mgvData` not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` should be blamed on the maker. */\n        } else if (mgvData == \"mgv/notEnoughGasForMakerTrade\") {\n          revert(\"mgv/notEnoughGasForMakerTrade\");\n        } else if (mgvData == \"mgv/takerTransferFail\") {\n          revert(\"mgv/takerTransferFail\");\n        } else {\n          /* This code must be unreachable. **Danger**: if a well-crafted offer/maker pair can force a revert of `flashloan`, the Mangrove will be stuck. */\n          revert(\"mgv/swapError\");\n        }\n      }\n\n      /* Delete the offer. The last argument indicates whether the offer should be stripped of its provision (yes if execution failed, no otherwise). We delete offers whether the amount remaining on offer is > density or not for the sake of uniformity (code is much simpler). We also expect prices to move often enough that the maker will want to update their price anyway. To simulate leaving the remaining volume in the offer, the maker can program their `makerPosthook` to `updateOffer` and put the remaining volume back in. */\n      dirtyDeleteOffer(\n        sor.outbound_tkn,\n        sor.inbound_tkn,\n        sor.offerId,\n        sor.offer,\n        sor.offerDetail,\n        mgvData != \"mgv/tradeSuccess\"\n      );\n    }\n  }\n\n  /* ## flashloan (abstract) */\n  /* Externally called by `execute`, flashloan lends money (from the taker to the maker, or from the maker to the taker, depending on the implementation) then calls `makerExecute` to run the maker liquidity fetching code. If `makerExecute` is unsuccessful, `flashloan` reverts (but the larger orderbook traversal will continue). \n\n  All `flashloan` implementations must `require(msg.sender) == address(this))`. */\n  function flashloan(ML.SingleOrder calldata sor, address taker)\n    external\n    virtual\n    returns (uint gasused);\n\n  /* ## Maker Execute */\n  /* Called by `flashloan`, `makerExecute` runs the maker code and checks that it can safely send the desired assets to the taker. */\n\n  function makerExecute(ML.SingleOrder calldata sor)\n    internal\n    returns (uint gasused)\n  {\n    unchecked {\n      bytes memory cd = abi.encodeWithSelector(\n        IMaker.makerExecute.selector,\n        sor\n      );\n\n      uint gasreq = sor.offerDetail.gasreq();\n      address maker = sor.offerDetail.maker();\n      uint oldGas = gasleft();\n      /* We let the maker pay for the overhead of checking remaining gas and making the call, as well as handling the return data (constant gas since only the first 32 bytes of return data are read). So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\textrm{gasreq} - \\frac{63h}{64}$ gas. */\n      /* Note : as a possible future feature, we could stop an order when there's not enough gas left to continue processing offers. This could be done safely by checking, as soon as we start processing an offer, whether `63/64(gasleft-offer_gasbase) > gasreq`. If no, we could stop and know by induction that there is enough gas left to apply fees, stitch offers, etc for the offers already executed. */\n      if (!(oldGas - oldGas / 64 >= gasreq)) {\n        innerRevert([bytes32(\"mgv/notEnoughGasForMakerTrade\"), \"\", \"\"]);\n      }\n\n      (bool callSuccess, bytes32 makerData) = controlledCall(maker, gasreq, cd);\n\n      gasused = oldGas - gasleft();\n\n      if (!callSuccess) {\n        innerRevert([bytes32(\"mgv/makerRevert\"), bytes32(gasused), makerData]);\n      }\n\n      bool transferSuccess = transferTokenFrom(\n        sor.outbound_tkn,\n        maker,\n        address(this),\n        sor.wants\n      );\n\n      if (!transferSuccess) {\n        innerRevert(\n          [bytes32(\"mgv/makerTransferFail\"), bytes32(gasused), makerData]\n        );\n      }\n    }\n  }\n\n  /* ## executeEnd (abstract) */\n  /* Called by `internalSnipes` and `internalMarketOrder`, `executeEnd` may run implementation-specific code after all makers have been called once. In [`InvertedMangrove`](#InvertedMangrove), the function calls the taker once so they can act on their flashloan. In [`Mangrove`], it does nothing. */\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    virtual;\n\n  /* ## Post execute */\n  /* At this point, we know `mgvData != \"mgv/notExecuted\"`. After executing an offer (whether in a market order or in snipes), we\n     1. Call the maker's posthook and sum the total gas used.\n     2. If offer failed: sum total penalty due to taker and give remainder to maker.\n   */\n  function postExecute(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    uint gasused,\n    bytes32 makerData,\n    bytes32 mgvData\n  ) internal {\n    unchecked {\n      if (mgvData == \"mgv/tradeSuccess\") {\n        beforePosthook(sor);\n      }\n\n      uint gasreq = sor.offerDetail.gasreq();\n\n      /* We are about to call back the maker, giving it its unused gas (`gasreq - gasused`). Since the gas used so far may exceed `gasreq`, we prevent underflow in the subtraction below by bounding `gasused` above with `gasreq`. We could have decided not to call back the maker at all when there is no gas left, but we do it for uniformity. */\n      if (gasused > gasreq) {\n        gasused = gasreq;\n      }\n\n      gasused =\n        gasused +\n        makerPosthook(sor, gasreq - gasused, makerData, mgvData);\n\n      if (mgvData != \"mgv/tradeSuccess\") {\n        mor.totalPenalty += applyPenalty(sor, gasused);\n      }\n    }\n  }\n\n  /* ## beforePosthook (abstract) */\n  /* Called by `makerPosthook`, this function can run implementation-specific code before calling the maker has been called a second time. In [`InvertedMangrove`](#InvertedMangrove), all makers are called once so the taker gets all of its money in one shot. Then makers are traversed again and the money is sent back to each taker using `beforePosthook`. In [`Mangrove`](#Mangrove), `beforePosthook` does nothing. */\n\n  function beforePosthook(ML.SingleOrder memory sor) internal virtual;\n\n  /* ## Maker Posthook */\n  function makerPosthook(\n    ML.SingleOrder memory sor,\n    uint gasLeft,\n    bytes32 makerData,\n    bytes32 mgvData\n  ) internal returns (uint gasused) {\n    unchecked {\n      /* At this point, mgvData can only be `\"mgv/tradeSuccess\"`, `\"mgv/makerRevert\"`, `\"mgv/makerTransferFail\"` or `\"mgv/makerReceiveFail\"` */\n      bytes memory cd = abi.encodeWithSelector(\n        IMaker.makerPosthook.selector,\n        sor,\n        ML.OrderResult({makerData: makerData, mgvData: mgvData})\n      );\n\n      address maker = sor.offerDetail.maker();\n\n      uint oldGas = gasleft();\n      /* We let the maker pay for the overhead of checking remaining gas and making the call. So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\textrm{gasreq} - \\frac{63h}{64}$ gas. */\n      if (!(oldGas - oldGas / 64 >= gasLeft)) {\n        revert(\"mgv/notEnoughGasForMakerPosthook\");\n      }\n\n      (bool callSuccess, bytes32 posthookData) = controlledCall(\n        maker,\n        gasLeft,\n        cd\n      );\n\n      gasused = oldGas - gasleft();\n\n      if (!callSuccess) {\n        emit PosthookFail(\n          sor.outbound_tkn,\n          sor.inbound_tkn,\n          sor.offerId,\n          posthookData\n        );\n      }\n    }\n  }\n\n  /* ## `controlledCall` */\n  /* Calls an external function with controlled gas expense. A direct call of the form `(,bytes memory retdata) = maker.call{gas}(selector,...args)` enables a griefing attack: the maker uses half its gas to write in its memory, then reverts with that memory segment as argument. After a low-level call, solidity automaticaly copies `returndatasize` bytes of `returndata` into memory. So the total gas consumed to execute a failing offer could exceed `gasreq + offer_gasbase` where `n` is the number of failing offers. In case of success, we read the first 32 bytes of returndata (the signature of `makerExecute` is `bytes32`). Otherwise, for compatibility with most errors that bubble up from contract calls and Solidity's `require`, we read 32 bytes of returndata starting from the 69th (4 bytes of method sig + 32 bytes of offset + 32 bytes of string length). */\n  function controlledCall(\n    address callee,\n    uint gasreq,\n    bytes memory cd\n  ) internal returns (bool success, bytes32 data) {\n    unchecked {\n      bytes32[4] memory retdata;\n\n      /* if success, read returned bytes 1..32, otherwise read returned bytes 69..100. */\n      assembly {\n        success := call(gasreq, callee, 0, add(cd, 32), mload(cd), retdata, 100)\n        data := mload(add(mul(iszero(success), 68), retdata))\n      }\n    }\n  }\n\n  /* # Penalties */\n  /* Offers are just promises. They can fail. Penalty provisioning discourages from failing too much: we ask makers to provision more ETH than the expected gas cost of executing their offer and penalize them accoridng to wasted gas.\n\n     Under normal circumstances, we should expect to see bots with a profit expectation dry-running offers locally and executing `snipe` on failing offers, collecting the penalty. The result should be a mostly clean book for actual takers (i.e. a book with only successful offers).\n\n     **Incentive issue**: if the gas price increases enough after an offer has been created, there may not be an immediately profitable way to remove the fake offers. In that case, we count on 3 factors to keep the book clean:\n     1. Gas price eventually comes down.\n     2. Other market makers want to keep the Mangrove attractive and maintain their offer flow.\n     3. Mangrove governance (who may collect a fee) wants to keep the Mangrove attractive and maximize exchange volume. */\n\n  //+clear+\n  /* After an offer failed, part of its provision is given back to the maker and the rest is stored to be sent to the taker after the entire order completes. In `applyPenalty`, we _only_ credit the maker with its excess provision. So it looks like the maker is gaining something. In fact they're just getting back a fraction of what they provisioned earlier. */\n  /*\n     Penalty application summary:\n\n   * If the transaction was a success, we entirely refund the maker and send nothing to the taker.\n   * Otherwise, the maker loses the cost of `gasused + offer_gasbase` gas. The gas price is estimated by `gasprice`.\n   * To create the offer, the maker had to provision for `gasreq + offer_gasbase` gas at a price of `offerDetail.gasprice`.\n   * We do not consider the tx.gasprice.\n   * `offerDetail.gasbase` and `offerDetail.gasprice` are the values of the Mangrove parameters `config.offer_gasbase` and `config.gasprice` when the offer was created. Without caching those values, the provision set aside could end up insufficient to reimburse the maker (or to retribute the taker).\n   */\n  function applyPenalty(ML.SingleOrder memory sor, uint gasused)\n    internal\n    returns (uint)\n  {\n    unchecked {\n      uint gasreq = sor.offerDetail.gasreq();\n\n      uint provision = 10**9 *\n        sor.offerDetail.gasprice() *\n        (gasreq + sor.offerDetail.offer_gasbase());\n\n      /* We set `gasused = min(gasused,gasreq)` since `gasreq < gasused` is possible e.g. with `gasreq = 0` (all calls consume nonzero gas). */\n      if (gasused > gasreq) {\n        gasused = gasreq;\n      }\n\n      /* As an invariant, `applyPenalty` is only called when `mgvData` is not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` */\n      uint penalty = 10**9 *\n        sor.global.gasprice() *\n        (gasused + sor.local.offer_gasbase());\n\n      if (penalty > provision) {\n        penalty = provision;\n      }\n\n      /* Here we write to storage the new maker balance. This occurs _after_ possible reentrant calls. How do we know we're not crediting twice the same amounts? Because the `offer`'s provision was set to 0 in storage (through `dirtyDeleteOffer`) before the reentrant calls. In this function, we are working with cached copies of the offer as it was before it was consumed. */\n      creditWei(sor.offerDetail.maker(), provision - penalty);\n\n      return penalty;\n    }\n  }\n\n  function sendPenalty(uint amount) internal {\n    unchecked {\n      if (amount > 0) {\n        (bool noRevert, ) = msg.sender.call{value: amount}(\"\");\n        require(noRevert, \"mgv/sendPenaltyReverted\");\n      }\n    }\n  }\n\n  /* Post-trade, `payTakerMinusFees` sends what's due to the taker and the rest (the fees) to the vault. Routing through the Mangrove like that also deals with blacklisting issues (separates the maker-blacklisted and the taker-blacklisted cases). */\n  function payTakerMinusFees(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n  {\n    unchecked {\n      /* Should be statically provable that the 2 transfers below cannot return false under well-behaved ERC20s and a non-blacklisted, non-0 target. */\n\n      uint concreteFee = (mor.totalGot * sor.local.fee()) / 10_000;\n      if (concreteFee > 0) {\n        mor.totalGot -= concreteFee;\n        mor.feePaid = concreteFee;\n        require(\n          transferToken(sor.outbound_tkn, vault, concreteFee),\n          \"mgv/feeTransferFail\"\n        );\n      }\n      if (mor.totalGot > 0) {\n        require(\n          transferToken(sor.outbound_tkn, mor.taker, mor.totalGot),\n          \"mgv/MgvFailToPayTaker\"\n        );\n      }\n    }\n  }\n\n  /* # Misc. functions */\n\n  /* Regular solidity reverts prepend the string argument with a [function signature](https://docs.soliditylang.org/en/v0.7.6/control-structures.html#revert). Since we wish to transfer data through a revert, the `innerRevert` function does a low-level revert with only the required data. `innerCode` decodes this data. */\n  function innerDecode(bytes memory data)\n    internal\n    pure\n    returns (\n      bytes32 mgvData,\n      uint gasused,\n      bytes32 makerData\n    )\n  {\n    unchecked {\n      /* The `data` pointer is of the form `[mgvData,gasused,makerData]` where each array element is contiguous and has size 256 bits. */\n      assembly {\n        mgvData := mload(add(data, 32))\n        gasused := mload(add(data, 64))\n        makerData := mload(add(data, 96))\n      }\n    }\n  }\n\n  /* <a id=\"MgvOfferTaking/innerRevert\"></a>`innerRevert` reverts a raw triple of values to be interpreted by `innerDecode`.    */\n  function innerRevert(bytes32[3] memory data) internal pure {\n    unchecked {\n      assembly {\n        revert(data, 96)\n      }\n    }\n  }\n\n  /* `transferTokenFrom` is adapted from [existing code](https://soliditydeveloper.com/safe-erc20) and in particular avoids the\n  \"no return value\" bug. It never throws and returns true iff the transfer was successful according to `tokenAddress`.\n\n    Note that any spurious exception due to an error in Mangrove code will be falsely blamed on `from`.\n  */\n  function transferTokenFrom(\n    address tokenAddress,\n    address from,\n    address to,\n    uint value\n  ) internal returns (bool) {\n    unchecked {\n      bytes memory cd = abi.encodeWithSelector(\n        IERC20.transferFrom.selector,\n        from,\n        to,\n        value\n      );\n      (bool noRevert, bytes memory data) = tokenAddress.call(cd);\n      return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\n    }\n  }\n\n  function transferToken(\n    address tokenAddress,\n    address to,\n    uint value\n  ) internal returns (bool) {\n    unchecked {\n      bytes memory cd = abi.encodeWithSelector(\n        IERC20.transfer.selector,\n        to,\n        value\n      );\n      (bool noRevert, bytes memory data) = tokenAddress.call(cd);\n      return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\n    }\n  }\n}\n"
    },
    "contracts/test/lib/agents/TestMoriartyMaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"contracts/AbstractMangrove.sol\";\nimport {IERC20, MgvLib as ML, P, IMaker} from \"contracts/MgvLib.sol\";\n\ncontract TestMoriartyMaker is IMaker {\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n  bool succeed;\n  uint dummy;\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _base,\n    address _quote\n  ) {\n    mgv = _mgv;\n    base = _base;\n    quote = _quote;\n    succeed = true;\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    override\n    returns (bytes32 ret)\n  {\n    bool _succeed = succeed;\n    if (order.offerId == dummy) {\n      succeed = false;\n    }\n    if (_succeed) {\n      ret = \"\";\n    } else {\n      assert(false);\n    }\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {}\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public {\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    (, P.Local.t cfg) = mgv.config(base, quote);\n    uint density = cfg.density();\n    uint offer_gasbase = cfg.offer_gasbase();\n    dummy = mgv.newOffer({\n      outbound_tkn: base,\n      inbound_tkn: quote,\n      wants: 1,\n      gives: (density > 0 ? density : 1) * (offer_gasbase + 100000),\n      gasreq: 100000,\n      gasprice: 0,\n      pivotId: 0\n    }); //dummy offer\n  }\n\n  function provisionMgv(uint amount) public {\n    (bool success, ) = address(mgv).call{value: amount}(\"\");\n    require(success);\n  }\n\n  function approveMgv(IERC20 token, uint amount) public {\n    token.approve(address(mgv), amount);\n  }\n\n  receive() external payable {}\n}\n"
    },
    "contracts/toy_strategies/utils/SimpleOracle.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleOrale.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../interfaces/IOracle.sol\";\nimport \"contracts/strategies/utils/AccessControlled.sol\";\nimport {IERC20} from \"../../MgvLib.sol\";\n\ncontract SimpleOracle is IOracle, AccessControlled {\n  address reader; // if unset, anyone can read price\n  IERC20 public immutable base_token;\n  mapping(address => uint96) internal priceData;\n\n  constructor(address _base, address admin) AccessControlled(admin) {\n    try IERC20(_base).decimals() returns (uint8 d) {\n      require(d != 0, \"Invalid decimals number for Oracle base\");\n      base_token = IERC20(_base);\n    } catch {\n      revert(\"Invalid Oracle base address\");\n    }\n  }\n\n  function decimals() external view override returns (uint8) {\n    return base_token.decimals();\n  }\n\n  function setReader(address _reader) external onlyAdmin {\n    reader = _reader;\n  }\n\n  function setPrice(address token, uint price) external override onlyAdmin {\n    require(uint96(price) == price, \"price overflow\");\n    priceData[token] = uint96(price);\n  }\n\n  function getPrice(address token)\n    external\n    view\n    override\n    onlyCaller(reader)\n    returns (uint96 price)\n  {\n    price = priceData[token];\n    require(price != 0, \"missing price data\");\n  }\n}\n"
    },
    "contracts/toy_strategies/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// IOracle.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\npragma solidity ^0.8.10;\npragma abicoder v2;\n\ninterface IOracle {\n  function decimals() external view returns (uint8);\n\n  function getPrice(address token) external view returns (uint96);\n\n  function setPrice(address token, uint price) external;\n}\n"
    },
    "contracts/strategies/utils/AccessControlled.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AccessedControlled.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {AccessControlledStorage as ACS} from \"./AccessControlledStorage.sol\";\n\n// TODO-foundry-merge explain what this contract does\n\ncontract AccessControlled {\n  constructor(address admin_) {\n    require(admin_ != address(0), \"accessControlled/0xAdmin\");\n    ACS.get_storage().admin = admin_;\n  }\n\n  modifier onlyCaller(address caller) {\n    require(\n      caller == address(0) || msg.sender == caller,\n      \"AccessControlled/Invalid\"\n    );\n    _;\n  }\n\n  function admin() public view returns (address) {\n    return ACS.get_storage().admin;\n  }\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin(), \"AccessControlled/Invalid\");\n    _;\n  }\n\n  function setAdmin(address _admin) public onlyAdmin {\n    require(_admin != address(0), \"AccessControlled/0xAdmin\");\n    ACS.get_storage().admin = _admin;\n  }\n}\n"
    },
    "contracts/strategies/utils/AccessControlledStorage.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AccessedControlled.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\n// TODO-foundry-merge explain what this contract does\n\nlibrary AccessControlledStorage {\n  struct Layout {\n    address admin;\n  }\n\n  function get_storage() internal pure returns (Layout storage st) {\n    bytes32 storagePosition = keccak256(\"Mangrove.AccessControlledStorage\");\n    assembly {\n      st.slot := storagePosition\n    }\n  }\n}\n"
    },
    "contracts/test/lib/MangroveTest.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.13;\nimport \"./Test2.sol\";\nimport {TestTaker} from \"contracts/test/lib/agents/TestTaker.sol\";\nimport {TrivialTestMaker, TestMaker} from \"contracts/test/lib/agents/TestMaker.sol\";\nimport {MakerDeployer} from \"contracts/test/lib/agents/MakerDeployer.sol\";\nimport {TestMoriartyMaker} from \"contracts/test/lib/agents/TestMoriartyMaker.sol\";\nimport {TestToken} from \"contracts/test/lib/tokens/TestToken.sol\";\n\nimport {AbstractMangrove} from \"contracts/AbstractMangrove.sol\";\nimport {Mangrove} from \"contracts/Mangrove.sol\";\nimport {InvertedMangrove} from \"contracts/InvertedMangrove.sol\";\nimport {IERC20, MgvLib, P, HasMgvEvents, IMaker, ITaker, IMgvMonitor} from \"contracts/MgvLib.sol\";\nimport {console2 as csl} from \"foundry_lib/forge-std/src/console2.sol\";\n\n// below imports are for the \\$( function)\nimport {AccessControlled} from \"contracts/strategies/utils/AccessControlled.sol\";\n\n/* *************************************************************** \n   import this file and inherit MangroveTest to get up and running \n   *************************************************************** */\n\n/* This file is useful to:\n * auto-import all testing-useful contracts\n * inherit the standard forge-std/test.sol contract augmented with utilities & mangrove-specific functions\n */\n\ncontract MangroveTest is Test2, HasMgvEvents {\n  using stdStorage for StdStorage;\n  // Configure the initial setup.\n  // Add fields here to make MangroveTest more configurable.\n  struct TokenOptions {\n    string name;\n    string symbol;\n    uint8 decimals;\n  }\n  struct MangroveTestOptions {\n    bool invertedMangrove;\n    TokenOptions base;\n    TokenOptions quote;\n    uint defaultFee;\n  }\n\n  AbstractMangrove mgv;\n  TestToken base;\n  TestToken quote;\n\n  MangroveTestOptions options =\n    MangroveTestOptions({\n      invertedMangrove: false,\n      base: TokenOptions({name: \"Base Token\", symbol: \"$(A)\", decimals: 18}),\n      quote: TokenOptions({name: \"Quote Token\", symbol: \"$(B)\", decimals: 18}),\n      defaultFee: 0\n    });\n\n  constructor() {\n    // generic trace labeling\n    vm.label(tx.origin, \"tx.origin\");\n    vm.label($(this), \"Test runner\");\n  }\n\n  /* Defaults:\n  - testing contract has\n    - 10 ETH funded in mangrove\n  - new makers\n    - have 100 ETH\n  - new takers\n    - have 100 ETH\n  */\n  function setUp() public virtual {\n    // tokens\n    base = new TestToken(\n      $(this),\n      options.base.name,\n      options.base.symbol,\n      options.base.decimals\n    );\n    quote = new TestToken(\n      $(this),\n      options.quote.name,\n      options.quote.symbol,\n      options.quote.decimals\n    );\n    // mangrove deploy\n    mgv = setupMangrove(base, quote, options.invertedMangrove);\n    // start with mgvBalance on mangrove\n    mgv.fund{value: 10 ether}();\n    // approve mgv\n    base.approve($(mgv), type(uint).max);\n    quote.approve($(mgv), type(uint).max);\n  }\n\n  /* Log offer book */\n\n  event OBState(\n    address base,\n    address quote,\n    uint[] offerIds,\n    uint[] wants,\n    uint[] gives,\n    address[] makerAddr,\n    uint[] gasreqs\n  );\n\n  /** Two different OB logging methods.\n   *\n   *  `logOfferBook` will be easy to read in traces\n   *\n   *  `printOfferBook` will be easy to read in the console.logs section\n   */\n\n  /* Log OB with events */\n  event offers_head(address outbound, address inbound);\n  event offers_line(\n    uint id,\n    uint wants,\n    uint gives,\n    address maker,\n    uint gasreq\n  );\n\n  function logOfferBook(\n    address $out,\n    address $in,\n    uint size\n  ) internal {\n    uint offerId = mgv.best($out, $in);\n\n    // save call results so logs are easier to read\n    uint[] memory ids = new uint[](size);\n    P.Offer.t[] memory offers = new P.Offer.t[](size);\n    P.OfferDetail.t[] memory details = new P.OfferDetail.t[](size);\n    uint c = 0;\n    while ((offerId != 0) && (c < size)) {\n      ids[c] = offerId;\n      offers[c] = mgv.offers($out, $in, offerId);\n      details[c] = mgv.offerDetails($out, $in, offerId);\n      offerId = offers[c].next();\n      c++;\n    }\n    c = 0;\n    emit offers_head($out, $in);\n    while (c < size) {\n      emit offers_line(\n        ids[c],\n        offers[c].wants(),\n        offers[c].gives(),\n        details[c].maker(),\n        details[c].gasreq()\n      );\n      c++;\n    }\n    // emit OBState($out, $in, offerIds, wants, gives, makerAddr, gasreqs);\n  }\n\n  /* Log OB with console */\n  function printOfferBook(address $out, address $in) internal view {\n    uint offerId = mgv.best($out, $in);\n    TestToken req_tk = TestToken($in);\n    TestToken ofr_tk = TestToken($out);\n\n    console.log(\n      string.concat(\n        unicode\"Best offer: \",\n        uint2str(offerId),\n        unicode\"\"\n      )\n    );\n    while (offerId != 0) {\n      (P.OfferStruct memory ofr, ) = mgv.offerInfo($out, $in, offerId);\n      console.log(\n        string.concat(\n          unicode\" \",\n          string.concat(offerId < 9 ? \" \" : \"\", uint2str(offerId)), // breaks on id>99\n          unicode\"  \",\n          toEthUnits(ofr.wants, req_tk.symbol()),\n          \"  /  \",\n          toEthUnits(ofr.gives, ofr_tk.symbol())\n        )\n      );\n      offerId = ofr.next;\n    }\n    console.log(unicode\"\");\n  }\n\n  event GasCost(string callname, uint value);\n\n  function execWithCost(\n    string memory callname,\n    address addr,\n    bytes memory data\n  ) internal returns (bytes memory) {\n    uint g0 = gasleft();\n    (bool noRevert, bytes memory retdata) = addr.delegatecall(data);\n    require(noRevert, \"execWithCost should not revert\");\n    emit GasCost(callname, g0 - gasleft());\n    return retdata;\n  }\n\n  struct Balances {\n    uint mgvBalanceWei;\n    uint mgvBalanceFees;\n    uint takerBalanceA;\n    uint takerBalanceB;\n    uint takerBalanceWei;\n    uint[] makersBalanceA;\n    uint[] makersBalanceB;\n    uint[] makersBalanceWei;\n  }\n  enum Info {\n    makerWants,\n    makerGives,\n    nextId,\n    gasreqreceive_on,\n    gasprice,\n    gasreq\n  }\n\n  function isEmptyOB(address $out, address $in) internal view returns (bool) {\n    return mgv.best($out, $in) == 0;\n  }\n\n  function getFee(\n    address $out,\n    address $in,\n    uint price\n  ) internal view returns (uint) {\n    (, P.Local.t local) = mgv.config($out, $in);\n    return ((price * local.fee()) / 10000);\n  }\n\n  function minusFee(\n    address $out,\n    address $in,\n    uint price\n  ) internal view returns (uint) {\n    (, P.Local.t local) = mgv.config($out, $in);\n    return (price * (10_000 - local.fee())) / 10000;\n  }\n\n  function getProvision(\n    address $out,\n    address $in,\n    uint gasreq\n  ) internal view returns (uint) {\n    (P.Global.t glo_cfg, P.Local.t loc_cfg) = mgv.config($out, $in);\n    return ((gasreq + loc_cfg.offer_gasbase()) *\n      uint(glo_cfg.gasprice()) *\n      10**9);\n  }\n\n  function getProvision(\n    address $out,\n    address $in,\n    uint gasreq,\n    uint gasprice\n  ) internal view returns (uint) {\n    (P.Global.t glo_cfg, P.Local.t loc_cfg) = mgv.config($out, $in);\n    uint _gp;\n    if (glo_cfg.gasprice() > gasprice) {\n      _gp = uint(glo_cfg.gasprice());\n    } else {\n      _gp = gasprice;\n    }\n    return ((gasreq + loc_cfg.offer_gasbase()) * _gp * 10**9);\n  }\n\n  // Deploy mangrove\n  function setupMangrove() public returns (AbstractMangrove) {\n    return setupMangrove(false);\n  }\n\n  // Deploy mangrove, inverted or not\n  function setupMangrove(bool inverted) public returns (AbstractMangrove _mgv) {\n    if (inverted) {\n      _mgv = new InvertedMangrove({\n        governance: $(this),\n        gasprice: 40,\n        gasmax: 2_000_000\n      });\n    } else {\n      _mgv = new Mangrove({\n        governance: $(this),\n        gasprice: 40,\n        gasmax: 2_000_000\n      });\n    }\n    vm.label($(_mgv), \"Mangrove\");\n    return _mgv;\n  }\n\n  // Deploy mangrove with a pair\n  function setupMangrove(IERC20 outbound_tkn, IERC20 inbound_tkn)\n    public\n    returns (AbstractMangrove)\n  {\n    return setupMangrove(outbound_tkn, inbound_tkn, false);\n  }\n\n  // Deploy mangrove with a pair, inverted or not\n  function setupMangrove(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    bool inverted\n  ) public returns (AbstractMangrove _mgv) {\n    _mgv = setupMangrove(inverted);\n    setupMarket(address(outbound_tkn), address(inbound_tkn), _mgv);\n  }\n\n  function setupMarket(\n    address $a,\n    address $b,\n    AbstractMangrove _mgv\n  ) internal {\n    not0x($a);\n    not0x($b);\n    _mgv.activate($a, $b, options.defaultFee, 0, 20_000);\n    _mgv.activate($b, $a, options.defaultFee, 0, 20_000);\n    // logging\n    vm.label($a, IERC20($a).symbol());\n    vm.label($b, IERC20($b).symbol());\n  }\n\n  function setupMarket(address $a, address $b) internal {\n    setupMarket($a, $b, mgv);\n  }\n\n  function setupMarket(IERC20 a, IERC20 b) internal {\n    setupMarket(address(a), address(b), mgv);\n  }\n\n  function setupMaker(\n    address $out,\n    address $in,\n    string memory label\n  ) public returns (TestMaker) {\n    TestMaker tm = new TestMaker(mgv, IERC20($out), IERC20($in));\n    vm.deal(address(tm), 100 ether);\n    vm.label(address(tm), label);\n    return tm;\n  }\n\n  function setupMakerDeployer(address $out, address $in)\n    public\n    returns (MakerDeployer)\n  {\n    not0x($(mgv));\n    return (new MakerDeployer(mgv, $out, $in));\n  }\n\n  function setupTaker(\n    address $out,\n    address $in,\n    string memory label\n  ) public returns (TestTaker) {\n    TestTaker tt = new TestTaker(mgv, IERC20($out), IERC20($in));\n    vm.deal(address(tt), 100 ether);\n    vm.label(address(tt), label);\n    return tt;\n  }\n\n  /* **** Token conversion */\n  /* return underlying amount with correct number of decimals */\n  function cash(TestToken t, uint amount) public returns (uint) {\n    // don't use an ongoing vm.prank here\n    uint decimals = stdstore.target(address(t)).sig(\"__decimals()\").read_uint();\n    return amount * 10**decimals;\n  }\n\n  /* return underlying amount divided by 10**power */\n  function cash(\n    TestToken t,\n    uint amount,\n    uint power\n  ) public returns (uint) {\n    return cash(t, amount) / 10**power;\n  }\n\n  /* **** Sugar for address conversion */\n  function $(AbstractMangrove t) internal pure returns (address payable) {\n    return payable(address(t));\n  }\n\n  function $(AccessControlled t) internal pure returns (address payable) {\n    return payable(address(t));\n  }\n\n  function $(TestTaker t) internal pure returns (address payable) {\n    return payable(address(t));\n  }\n\n  function $(Test t) internal pure returns (address payable) {\n    return payable(address(t));\n  }\n\n  function $(IERC20 t) internal pure returns (address payable) {\n    return payable(address(t));\n  }\n}\n"
    },
    "contracts/test/lib/Test2.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.13;\n\nimport \"foundry_lib/forge-std/src/Test.sol\";\nimport {Utilities} from \"./Utilities.sol\";\n\n/* Some ease-of-life additions to forge-std/Test.sol */\n/* You mostly want to inherit `MangroveTest` (which inherits `Test2`) rather than inherit `Test2` directly */\ncontract Test2 is Test, Utilities {\n  function succeed() internal {\n    assertTrue(true);\n  }\n\n  // both mock a call and expect the call to happen\n  function expectToMockCall(\n    address addr,\n    bytes memory req,\n    bytes memory res\n  ) internal {\n    vm.mockCall(addr, req, res);\n    vm.expectCall(addr, req);\n  }\n\n  uint keyIterator = 1;\n\n  // create addr/key pairs, with/without label\n  function freshAccount() internal returns (uint, address payable) {\n    uint key = keyIterator++;\n    address payable addr = payable(vm.addr(key));\n    // set code to nonzero so solidity-inserted extcodesize checks don't fail\n    vm.etch(addr, bytes(\"not zero\"));\n    return (key, addr);\n  }\n\n  function freshAccount(string memory label)\n    internal\n    returns (uint key, address payable addr)\n  {\n    (key, addr) = freshAccount();\n    vm.label(addr, label);\n  }\n\n  function freshKey() internal returns (uint key) {\n    (key, ) = freshAccount();\n  }\n\n  function freshAddress() internal returns (address payable addr) {\n    (, addr) = freshAccount();\n  }\n\n  function freshAddress(string memory label)\n    internal\n    returns (address payable addr)\n  {\n    (, addr) = freshAccount(label);\n  }\n\n  /* expect exact log from address */\n  function expectFrom(address addr) internal {\n    vm.expectEmit(true, true, true, true, addr);\n  }\n\n  /* expect a revert reason */\n  function revertEq(string memory actual_reason, string memory expected_reason)\n    internal\n    returns (bool)\n  {\n    assertEq(actual_reason, expected_reason, \"wrong revert reason\");\n    return true;\n  }\n\n  /* assert address is not 0 */\n  function not0x(address a) internal returns (bool) {\n    if (a == address(0)) {\n      emit log(\"Error: address should not be 0\");\n      emit log_named_address(\"Address\", a);\n      fail();\n    }\n    return (a != address(0));\n  }\n\n  /* inline gas measures */\n  uint private checkpointGasLeft = 1; // Start the slot non0.\n  string checkpointLabel;\n\n  /* start measuring gas */\n  function _gas() internal virtual {\n    // checkpointLabel = label;\n\n    checkpointGasLeft = gasleft();\n  }\n\n  /* stop measuring gas and report */\n  function gas_() internal virtual {\n    uint checkpointGasLeft2 = gasleft();\n\n    // Subtract 100 to account for the warm SLOAD in startMeasuringGas.\n    uint gasDelta = checkpointGasLeft - checkpointGasLeft2 - 100;\n\n    emit log_named_uint(\"Gas used\", gasDelta);\n  }\n\n  /* Logging is put here since solidity libraries cannot be extended. */\n\n  function logary(uint[] memory uints) public view {\n    string memory s = \"\";\n    for (uint i = 0; i < uints.length; i++) {\n      s = string.concat(s, uint2str(uints[i]));\n      if (i < uints.length - 1) {\n        s = string.concat(s, \", \");\n      }\n    }\n    console2.log(s);\n  }\n\n  function logary(int[] memory ints) public view {\n    string memory s = \"\";\n    for (uint i = 0; i < ints.length; i++) {\n      s = string.concat(s, uint2str(uint(ints[i])));\n      if (i < ints.length - 1) {\n        s = string.concat(s, \", \");\n      }\n    }\n    console2.log(s);\n  }\n}\n"
    },
    "contracts/test/lib/agents/TestTaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport {AbstractMangrove} from \"contracts/AbstractMangrove.sol\";\nimport {IERC20, ITaker} from \"contracts/MgvLib.sol\";\nimport {Utilities} from \"contracts/test/lib/Utilities.sol\";\n\ncontract TestTaker is ITaker, Utilities {\n  AbstractMangrove _mgv;\n  address _base;\n  address _quote;\n\n  constructor(\n    AbstractMangrove mgv,\n    IERC20 base,\n    IERC20 quote\n  ) {\n    _mgv = mgv;\n    _base = address(base);\n    _quote = address(quote);\n  }\n\n  receive() external payable {}\n\n  function approveMgv(IERC20 token, uint amount) external {\n    token.approve(address(_mgv), amount);\n  }\n\n  function approve(\n    IERC20 token,\n    address spender,\n    uint amount\n  ) external {\n    token.approve(spender, amount);\n  }\n\n  function approveSpender(address spender, uint amount) external {\n    _mgv.approve(_base, _quote, spender, amount);\n  }\n\n  function take(uint offerId, uint takerWants) external returns (bool success) {\n    //uint taken = TestEvents.min(makerGives, takerWants);\n    (success, , , , ) = this.takeWithInfo(offerId, takerWants);\n  }\n\n  function takeWithInfo(uint offerId, uint takerWants)\n    external\n    returns (\n      bool,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    uint[4][] memory targets = wrap_dynamic(\n      [offerId, takerWants, type(uint96).max, type(uint48).max]\n    );\n    (\n      uint successes,\n      uint got,\n      uint gave,\n      uint totalPenalty,\n      uint feePaid\n    ) = _mgv.snipes(_base, _quote, targets, true);\n    return (successes == 1, got, gave, totalPenalty, feePaid);\n    //return taken;\n  }\n\n  function snipe(\n    AbstractMangrove __mgv,\n    address __base,\n    address __quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives,\n    uint gasreq\n  ) external returns (bool) {\n    uint[4][] memory targets = wrap_dynamic(\n      [offerId, takerWants, takerGives, gasreq]\n    );\n    (uint successes, , , , ) = __mgv.snipes(__base, __quote, targets, true);\n    return successes == 1;\n  }\n\n  function takerTrade(\n    address,\n    address,\n    uint,\n    uint\n  ) external pure override {}\n\n  function marketOrder(uint wants, uint gives)\n    external\n    returns (uint takerGot, uint takerGave)\n  {\n    (takerGot, takerGave, , ) = _mgv.marketOrder(\n      _base,\n      _quote,\n      wants,\n      gives,\n      true\n    );\n  }\n\n  function marketOrder(\n    AbstractMangrove __mgv,\n    address __base,\n    address __quote,\n    uint takerWants,\n    uint takerGives\n  ) external returns (uint takerGot, uint takerGave) {\n    (takerGot, takerGave, , ) = __mgv.marketOrder(\n      __base,\n      __quote,\n      takerWants,\n      takerGives,\n      true\n    );\n  }\n\n  function marketOrderWithFail(uint wants, uint gives)\n    external\n    returns (uint takerGot, uint takerGave)\n  {\n    (takerGot, takerGave, , ) = _mgv.marketOrder(\n      _base,\n      _quote,\n      wants,\n      gives,\n      true\n    );\n  }\n}\n"
    },
    "contracts/test/lib/agents/TestMaker.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.13;\npragma abicoder v2;\n\nimport \"contracts/AbstractMangrove.sol\";\nimport {IERC20, MgvLib as ML, P, IMaker} from \"contracts/MgvLib.sol\";\nimport {Test} from \"foundry_lib/forge-std/src/Test.sol\";\n\ncontract TrivialTestMaker is IMaker {\n  function makerExecute(ML.SingleOrder calldata)\n    external\n    virtual\n    returns (bytes32)\n  {\n    return \"\";\n  }\n\n  function makerPosthook(ML.SingleOrder calldata, ML.OrderResult calldata)\n    external\n    virtual\n  {}\n}\n\ncontract SimpleTestMaker is TrivialTestMaker {\n  AbstractMangrove _mgv;\n  address _base;\n  address _quote;\n  bool _shouldFail; // will set mgv allowance to 0\n  bool _shouldAbort; // will not return bytes32(\"\")\n  bool _shouldRevert; // will revert\n  bool _shouldRepost; // will try to repost offer with identical parameters\n  bytes32 _expectedStatus;\n\n  constructor(\n    AbstractMangrove mgv,\n    IERC20 base,\n    IERC20 quote\n  ) {\n    _mgv = mgv;\n    _base = address(base);\n    _quote = address(quote);\n  }\n\n  receive() external payable {}\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function logExecute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  ) external {\n    emit Execute(mgv, base, quote, offerId, takerWants, takerGives);\n  }\n\n  function shouldRevert(bool should) external {\n    _shouldRevert = should;\n  }\n\n  function shouldFail(bool should) external {\n    _shouldFail = should;\n  }\n\n  function shouldAbort(bool should) external {\n    _shouldAbort = should;\n  }\n\n  function shouldRepost(bool should) external {\n    _shouldRepost = should;\n  }\n\n  function approveMgv(IERC20 token, uint amount) public {\n    token.approve(address(_mgv), amount);\n  }\n\n  function expect(bytes32 mgvData) external {\n    _expectedStatus = mgvData;\n  }\n\n  function transferToken(\n    IERC20 token,\n    address to,\n    uint amount\n  ) external {\n    token.transfer(to, amount);\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    virtual\n    override\n    returns (bytes32)\n  {\n    if (_shouldRevert) {\n      bytes32[1] memory revert_msg = [bytes32(\"testMaker/revert\")];\n      assembly {\n        revert(revert_msg, 32)\n      }\n    }\n    emit Execute(\n      msg.sender,\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId,\n      order.wants,\n      order.gives\n    );\n    if (_shouldFail) {\n      IERC20(order.outbound_tkn).approve(address(_mgv), 0);\n      // bytes32[1] memory refuse_msg = [bytes32(\"testMaker/transferFail\")];\n      // assembly {\n      //   return(refuse_msg, 32)\n      // }\n      //revert(\"testMaker/fail\");\n    }\n    if (_shouldAbort) {\n      return \"abort\";\n    } else {\n      return \"\";\n    }\n  }\n\n  bool _shouldFailHook;\n\n  function setShouldFailHook(bool should) external {\n    _shouldFailHook = should;\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) public virtual override {\n    order; //shh\n    result; //shh\n    if (_shouldFailHook) {\n      revert(\"posthookFail\");\n    }\n\n    if (_shouldRepost) {\n      _mgv.updateOffer(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offer.wants(),\n        order.offer.gives(),\n        order.offerDetail.gasreq(),\n        0,\n        order.offer.prev(),\n        order.offerId\n      );\n    }\n  }\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public returns (uint) {\n    return (_mgv.newOffer(_base, _quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOfferWithFunding(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint amount\n  ) public returns (uint) {\n    return (\n      _mgv.newOffer{value: amount}(\n        _base,\n        _quote,\n        wants,\n        gives,\n        gasreq,\n        0,\n        pivotId\n      )\n    );\n  }\n\n  function newOffer(\n    address base,\n    address quote,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public returns (uint) {\n    return (_mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOfferWithFunding(\n    address base,\n    address quote,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint amount\n  ) public returns (uint) {\n    return (\n      _mgv.newOffer{value: amount}(\n        base,\n        quote,\n        wants,\n        gives,\n        gasreq,\n        0,\n        pivotId\n      )\n    );\n  }\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) public returns (uint) {\n    return (\n      _mgv.newOffer(_base, _quote, wants, gives, gasreq, gasprice, pivotId)\n    );\n  }\n\n  function newOfferWithFunding(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint amount\n  ) public returns (uint) {\n    return (\n      _mgv.newOffer{value: amount}(\n        _base,\n        _quote,\n        wants,\n        gives,\n        gasreq,\n        gasprice,\n        pivotId\n      )\n    );\n  }\n\n  function updateOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint offerId\n  ) public {\n    _mgv.updateOffer(_base, _quote, wants, gives, gasreq, 0, pivotId, offerId);\n  }\n\n  function updateOfferWithFunding(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint offerId,\n    uint amount\n  ) public {\n    _mgv.updateOffer{value: amount}(\n      _base,\n      _quote,\n      wants,\n      gives,\n      gasreq,\n      0,\n      pivotId,\n      offerId\n    );\n  }\n\n  function retractOffer(uint offerId) public returns (uint) {\n    return _mgv.retractOffer(_base, _quote, offerId, false);\n  }\n\n  function retractOfferWithDeprovision(uint offerId) public returns (uint) {\n    return _mgv.retractOffer(_base, _quote, offerId, true);\n  }\n\n  function provisionMgv(uint amount) public {\n    _mgv.fund{value: amount}(address(this));\n  }\n\n  function withdrawMgv(uint amount) public returns (bool) {\n    return _mgv.withdraw(amount);\n  }\n\n  function mgvBalance() public view returns (uint) {\n    return _mgv.balanceOf(address(this));\n  }\n}\n\ncontract TestMaker is SimpleTestMaker, Test {\n  constructor(\n    AbstractMangrove mgv,\n    IERC20 base,\n    IERC20 quote\n  ) SimpleTestMaker(mgv, base, quote) {}\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) public virtual override {\n    if (_expectedStatus != bytes32(\"\")) {\n      assertEq(result.mgvData, _expectedStatus, \"Incorrect status message\");\n    }\n    super.makerPosthook(order, result);\n  }\n}\n"
    },
    "contracts/test/lib/agents/MakerDeployer.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"contracts/Mangrove.sol\";\nimport \"./TestMaker.sol\";\nimport \"contracts/test/lib/tokens/TestToken.sol\";\n\ncontract MakerDeployer {\n  address payable[] makers;\n  bool deployed;\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _base,\n    address _quote\n  ) {\n    mgv = _mgv;\n    base = _base;\n    quote = _quote;\n  }\n\n  function dispatch() external {\n    uint k = makers.length;\n    uint perMaker = address(this).balance / k;\n    require(perMaker > 0, \"0 ether to transfer\");\n    for (uint i = 0; i < k; i++) {\n      address payable maker = makers[i];\n      bool ok = maker.send(perMaker);\n      require(ok);\n    }\n  }\n\n  function length() external view returns (uint) {\n    return makers.length;\n  }\n\n  function getMaker(uint i) external view returns (TestMaker) {\n    return TestMaker(makers[i]);\n  }\n\n  function deploy(uint k) external {\n    if (!deployed) {\n      makers = new address payable[](k);\n      for (uint i = 0; i < k; i++) {\n        makers[i] = payable(\n          address(new TestMaker(mgv, TestToken(base), TestToken(quote)))\n        );\n        TestMaker(makers[i]).approveMgv(TestToken(base), 10 ether);\n        TestMaker(makers[i]).shouldFail(i == 0); //maker-0 is failer\n      }\n    }\n    deployed = true;\n  }\n}\n"
    },
    "contracts/test/lib/tokens/TestToken.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"./ERC20BL.sol\";\n\ncontract TestToken is ERC20BL {\n  mapping(address => bool) admins;\n  uint public __decimals; // full uint to help forge-std's stdstore\n\n  constructor(\n    address admin,\n    string memory name,\n    string memory symbol,\n    uint8 _decimals\n  ) ERC20BL(name, symbol) {\n    admins[admin] = true;\n    __decimals = _decimals;\n  }\n\n  function $(uint amount) public view returns (uint) {\n    return amount * 10**decimals();\n  }\n\n  function decimals() public view override returns (uint8) {\n    return uint8(__decimals);\n  }\n\n  function requireAdmin() internal view {\n    require(admins[msg.sender], \"TestToken/adminOnly\");\n  }\n\n  function addAdmin(address admin) external {\n    requireAdmin();\n    admins[admin] = true;\n  }\n\n  function removeAdmin(address admin) external {\n    requireAdmin();\n    admins[admin] = false;\n  }\n\n  function mint(address to, uint amount) external {\n    requireAdmin();\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint amount) external {\n    requireAdmin();\n    _burn(from, amount);\n  }\n\n  function blacklists(address account) external {\n    requireAdmin();\n    _blacklists(account);\n  }\n\n  function whitelists(address account) external {\n    requireAdmin();\n    _whitelists(account);\n  }\n}\n"
    },
    "contracts/Mangrove.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// Mangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, P} from \"./MgvLib.sol\";\n\nimport {AbstractMangrove} from \"./AbstractMangrove.sol\";\n\n/* <a id=\"Mangrove\"></a> The `Mangrove` contract implements the \"normal\" version of Mangrove, where the taker flashloans the desired amount to each maker. Each time, makers are called after the loan. When the order is complete, each maker is called once again (with the orderbook unlocked). */\ncontract Mangrove is AbstractMangrove {\n\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax\n  ) AbstractMangrove(governance, gasprice, gasmax, \"Mangrove\") {}\n\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    override\n  {}\n\n  function beforePosthook(ML.SingleOrder memory sor) internal override {}\n\n  /* ## Flashloan */\n  /*\n     `flashloan` is for the 'normal' mode of operation. It:\n     1. Flashloans `takerGives` `inbound_tkn` from the taker to the maker and returns false if the loan fails.\n     2. Runs `offerDetail.maker`'s `execute` function.\n     3. Returns the result of the operations, with optional makerData to help the maker debug.\n   */\n  function flashloan(ML.SingleOrder calldata sor, address taker)\n    external\n    override\n    returns (uint gasused)\n  {\n    unchecked {\n      /* `flashloan` must be used with a call (hence the `external` modifier) so its effect can be reverted. But a call from the outside would be fatal. */\n      require(msg.sender == address(this), \"mgv/flashloan/protected\");\n      /* The transfer taker -> maker is in 2 steps. First, taker->mgv. Then\n       mgv->maker. With a direct taker->maker transfer, if one of taker/maker\n       is blacklisted, we can't tell which one. We need to know which one:\n       if we incorrectly blame the taker, a blacklisted maker can block a pair forever; if we incorrectly blame the maker, a blacklisted taker can unfairly make makers fail all the time. Of course we assume the Mangrove is not blacklisted. Also note that this setup doesn't not work well with tokens that take fees or recompute balances at transfer time. */\n      if (transferTokenFrom(sor.inbound_tkn, taker, address(this), sor.gives)) {\n        if (\n          transferToken(sor.inbound_tkn, sor.offerDetail.maker(), sor.gives)\n        ) {\n          gasused = makerExecute(sor);\n        } else {\n          innerRevert([bytes32(\"mgv/makerReceiveFail\"), bytes32(0), \"\"]);\n        }\n      } else {\n        innerRevert([bytes32(\"mgv/takerTransferFail\"), \"\", \"\"]);\n      }\n    }\n  }\n}\n"
    },
    "contracts/InvertedMangrove.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// InvertedMangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {ITaker, MgvLib as ML, P} from \"./MgvLib.sol\";\n\nimport {AbstractMangrove} from \"./AbstractMangrove.sol\";\n\n/* <a id=\"InvertedMangrove\"></a> The `InvertedMangrove` contract implements the \"inverted\" version of Mangrove, where each maker loans money to the taker. The taker is then called, and finally each maker is sent its payment and called again (with the orderbook unlocked). */\ncontract InvertedMangrove is AbstractMangrove {\n\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax\n  ) AbstractMangrove(governance, gasprice, gasmax, \"InvertedMangrove\") {}\n\n  // execute taker trade\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    override\n  {\n    unchecked {\n      ITaker(mor.taker).takerTrade(\n        sor.outbound_tkn,\n        sor.inbound_tkn,\n        mor.totalGot,\n        mor.totalGave\n      );\n      bool success = transferTokenFrom(\n        sor.inbound_tkn,\n        mor.taker,\n        address(this),\n        mor.totalGave\n      );\n      require(success, \"mgv/takerFailToPayTotal\");\n    }\n  }\n\n  /* We use `transferFrom` with takers (instead of checking `balanceOf` before/after the call) for the following reason we want the taker to be awaken after all loans have been made, so either\n     1. The taker gets a list of all makers and loops through them to pay back, or\n     2. we call a new taker method \"payback\" after returning from each maker call, or\n     3. we call transferFrom after returning from each maker call\n\nSo :\n   1. Would mean accumulating a list of all makers, which would make the market order code too complex\n   2. Is OK, but has an extra CALL cost on top of the token transfer, one for each maker. This is unavoidable anyway when calling makerExecute (since the maker must be able to execute arbitrary code at that moment), but we can skip it here.\n   3. Is the cheapest, but it has the drawbacks of `transferFrom`: money must end up owned by the taker, and taker needs to `approve` Mangrove\n   */\n  function beforePosthook(ML.SingleOrder memory sor) internal override {\n    unchecked {\n      /* If `transferToken` returns false here, we're in a special (and bad) situation. The taker is returning part of their total loan to a maker, but the maker can't receive the tokens. Only case we can see: maker is blacklisted. In that case, we send the tokens to the vault, so things have a chance of getting sorted out later (Mangrove is a token black hole). */\n      if (!transferToken(sor.inbound_tkn, sor.offerDetail.maker(), sor.gives)) {\n        /* If that transfer fails there's nothing we can do -- reverting would punish the taker for the maker's blacklisting. */\n        transferToken(sor.inbound_tkn, vault, sor.gives);\n      }\n    }\n  }\n\n  /* # Flashloans */\n  //+clear+\n  /* ## Inverted Flashloan */\n  /*\n     `invertedFlashloan` is for the 'arbitrage' mode of operation. It:\n     0. Calls the maker's `execute` function. If successful (tokens have been sent to taker):\n     2. Runs `taker`'s `execute` function.\n     4. Returns the results ofthe operations, with optional makerData to help the maker debug.\n\n     There are two ways to do the flashloan:\n     1. balanceOf before/after\n     2. run transferFrom ourselves.\n\n     ### balanceOf pros:\n       * maker may `transferFrom` another address they control; saves gas compared to Mangrove's `transferFrom`\n       * maker does not need to `approve` Mangrove\n\n     ### balanceOf cons\n       * if the ERC20 transfer method has a callback to receiver, the method does not work (the receiver can set its balance to 0 during the callback)\n       * if the taker is malicious, they can analyze the maker code. If the maker goes on any Mangrove2, they may execute code provided by the taker. This would reduce the taker balance and make the maker fail. So the taker could steal the maker's balance.\n\n    We choose `transferFrom`.\n    */\n\n  function flashloan(ML.SingleOrder calldata sor, address)\n    external\n    override\n    returns (uint gasused)\n  {\n    unchecked {\n      /* `invertedFlashloan` must be used with a call (hence the `external` modifier) so its effect can be reverted. But a call from the outside would be fatal. */\n      require(msg.sender == address(this), \"mgv/invertedFlashloan/protected\");\n      gasused = makerExecute(sor);\n    }\n  }\n}\n"
    },
    "foundry_lib/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "foundry_lib/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Script.sol\";\nimport \"../lib/ds-test/src/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) public {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) public {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) public {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) public {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) public {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) public {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) public {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) public {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) public {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) public {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) public {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) public {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) public {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) public {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a >= 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        if (a >= 0 && b >= 0 || a < 0 && b < 0) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "contracts/test/lib/Utilities.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.13;\nimport {console2 as console} from \"foundry_lib/forge-std/src/console2.sol\";\n\n/* Some general utility methods.\n/* You mostly want to inherit `MangroveTest` (which inherits Test2` which inherits `Utilities`) rather than inherit `Utilities` directly */\ncontract Utilities {\n  function uint2str(uint _i)\n    internal\n    pure\n    returns (string memory _uintAsString)\n  {\n    unchecked {\n      if (_i == 0) {\n        return \"0\";\n      }\n      uint j = _i;\n      uint len;\n      while (j != 0) {\n        len++;\n        j /= 10;\n      }\n      bytes memory bstr = new bytes(len);\n      uint k = len - 1;\n      while (_i != 0) {\n        bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n        _i /= 10;\n      }\n      return string(bstr);\n    }\n  }\n\n  function int2str(int _i) internal pure returns (string memory) {\n    return uint2str(uint(_i));\n  }\n\n  /* units to e-18 units */\n  function toEthUnits(uint w, string memory units)\n    internal\n    pure\n    returns (string memory eth)\n  {\n    string memory suffix = string.concat(\" \", units);\n\n    if (w == 0) {\n      return (string.concat(\"0\", suffix));\n    }\n    uint i = 0;\n    while (w % 10 == 0) {\n      w = w / 10;\n      i += 1;\n    }\n    if (i >= 18) {\n      w = w * (10**(i - 18));\n      return string.concat(uint2str(w), suffix);\n    } else {\n      uint zeroBefore = 18 - i;\n      string memory zeros = \"\";\n      while (zeroBefore > 1) {\n        zeros = string.concat(zeros, \"0\");\n        zeroBefore--;\n      }\n      return (string.concat(\"0.\", zeros, uint2str(w), suffix));\n    }\n  }\n\n  /* return bytes32 as string */\n  function s32(bytes32 b) internal pure returns (string memory) {\n    string memory s = new string(32);\n    assembly {\n      mstore(add(s, 32), b)\n    }\n    return s;\n  }\n\n  /* log bytes32 as string */\n  function logString32(bytes32 b) internal view {\n    string memory s = new string(32);\n    assembly {\n      mstore(add(s, 32), b)\n    }\n    console.log(s32(b));\n  }\n\n  function getReason(bytes memory returnData)\n    internal\n    pure\n    returns (string memory reason)\n  {\n    /* returnData for a revert(reason) is the result of\n       abi.encodeWithSignature(\"Error(string)\",reason)\n       but abi.decode assumes the first 4 bytes are padded to 32\n       so we repad them. See:\n       https://github.com/ethereum/solidity/issues/6012\n     */\n    bytes memory pointer = abi.encodePacked(bytes28(0), returnData);\n    uint len = returnData.length - 4;\n    assembly {\n      pointer := add(32, pointer)\n      mstore(pointer, len)\n    }\n    reason = abi.decode(pointer, (string));\n  }\n\n  /* *********  ARRAY UTILITIES */\n\n  /* *******\n     wrap_dynamic(x) wraps x in a size-1 dynamic array\n  */\n\n  function wrap_dynamic(uint a) internal pure returns (uint[] memory) {\n    uint[] memory ret = new uint[](1);\n    ret[0] = a;\n    return ret;\n  }\n\n  function wrap_dynamic(uint[1] memory a)\n    internal\n    pure\n    returns (uint[1][] memory)\n  {\n    uint[1][] memory ret = new uint[1][](1);\n    ret[0] = a;\n    return ret;\n  }\n\n  function wrap_dynamic(uint[2] memory a)\n    internal\n    pure\n    returns (uint[2][] memory)\n  {\n    uint[2][] memory ret = new uint[2][](1);\n    ret[0] = a;\n    return ret;\n  }\n\n  function wrap_dynamic(uint[3] memory a)\n    internal\n    pure\n    returns (uint[3][] memory)\n  {\n    uint[3][] memory ret = new uint[3][](1);\n    ret[0] = a;\n    return ret;\n  }\n\n  function wrap_dynamic(uint[4] memory a)\n    internal\n    pure\n    returns (uint[4][] memory)\n  {\n    uint[4][] memory ret = new uint[4][](1);\n    ret[0] = a;\n    return ret;\n  }\n\n  /* *****\n  Internal utility: copy `words` words from `i_ptr` to `o_ptr`\n  */\n  function memcpy(\n    uint i_ptr,\n    uint words,\n    uint o_ptr\n  ) internal pure {\n    while (words > 0) {\n      assembly {\n        function loc(i, w) -> o {\n          o := add(i, mul(sub(w, 1), 32))\n        }\n        mstore(loc(o_ptr, words), mload(loc(i_ptr, words)))\n      }\n      words--;\n    }\n  }\n\n  /* *******\n     dynamic(uint[n] a) turns a into a dynamic array of size n\n  */\n\n  function dynamic(uint[1] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[2] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[3] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[4] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[5] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[6] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[7] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[8] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[9] memory a) internal pure returns (uint[] memory ret) {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(uint[10] memory a)\n    internal\n    pure\n    returns (uint[] memory ret)\n  {\n    ret = new uint[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[1] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[2] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[3] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[4] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[5] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[6] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[7] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[8] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[9] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  function dynamic(int[10] memory a) internal pure returns (int[] memory ret) {\n    ret = new int[](a.length);\n    uint i_ptr;\n    uint o_ptr;\n    assembly {\n      i_ptr := a\n      o_ptr := add(ret, 32)\n    }\n    memcpy(i_ptr, a.length, o_ptr);\n  }\n\n  /* Math abs */\n  function abs(int i) internal pure returns (uint) {\n    if (i < 0) {\n      return uint(-i);\n    } else {\n      return uint(i);\n    }\n  }\n}\n"
    },
    "foundry_lib/forge-std/src/Script.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\nimport \"./console.sol\";\nimport \"./console2.sol\";\n\nabstract contract Script {\n    bool public IS_SCRIPT = true;\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n}\n"
    },
    "foundry_lib/forge-std/lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "foundry_lib/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n}\n"
    },
    "foundry_lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "contracts/test/lib/tokens/ERC20BL.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"./ERC20.sol\";\n\nabstract contract ERC20BL is ERC20 {\n  mapping(address => bool) public _blacklisted;\n\n  constructor(string memory _name, string memory _symbol)\n    ERC20Base(_name, _symbol)\n    ERC20(_name)\n  {}\n\n  modifier notBlackListed(address addr) {\n    require(!_blacklisted[addr], \"ERC20BL/Blacklisted\");\n    _;\n  }\n\n  function _blacklists(address addr) internal virtual {\n    _blacklisted[addr] = true;\n  }\n\n  function _whitelists(address addr) internal virtual {\n    _blacklisted[addr] = false;\n  }\n\n  function transfer(address to, uint amount)\n    public\n    virtual\n    override\n    notBlackListed(to)\n    notBlackListed(msg.sender)\n    returns (bool)\n  {\n    return super.transfer(to, amount);\n  }\n\n  function approve(address spender, uint amount)\n    public\n    virtual\n    override\n    notBlackListed(spender)\n    notBlackListed(msg.sender)\n    returns (bool)\n  {\n    return super.approve(spender, amount);\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override notBlackListed(owner) notBlackListed(spender) {\n    super.permit(owner, spender, value, deadline, v, r, s);\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint amount\n  )\n    public\n    virtual\n    override\n    notBlackListed(from)\n    notBlackListed(to)\n    notBlackListed(msg.sender)\n    returns (bool)\n  {\n    return super.transferFrom(from, to, amount);\n  }\n}\n"
    },
    "contracts/test/lib/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"contracts/MgvLib.sol\";\nimport \"./ERC20Lib.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Base is Context, IERC20 {\n  mapping(address => uint) private _balances;\n\n  mapping(address => mapping(address => uint)) private _allowances;\n\n  uint private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint)\n  {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * NOTE: Does not update the allowance if the current allowance\n   * is the maximum `uint256`.\n   *\n   * Requirements:\n   *\n   * - `from` and `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``from``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    address owner = _msgSender();\n    uint currentAllowance = allowance(owner, spender);\n    require(\n      currentAllowance >= subtractedValue,\n      \"ERC20: decreased allowance below zero\"\n    );\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[from] = fromBalance - amount;\n    }\n    _balances[to] += amount;\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint amount\n  ) internal virtual {\n    uint currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint amount\n  ) internal virtual {}\n}\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20 is ERC20Base, EIP712 {\n  using Counters for Counters.Counter;\n\n  mapping(address => Counters.Counter) private _nonces;\n\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private constant _PERMIT_TYPEHASH =\n    keccak256(\n      \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n  /**\n   * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n   * However, to ensure consistency with the upgradeable transpiler, we will continue\n   * to reserve a slot.\n   * @custom:oz-renamed-from _PERMIT_TYPEHASH\n   */\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n   *\n   * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n   */\n  constructor(string memory name) EIP712(name, \"1\") {}\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n    bytes32 structHash = keccak256(\n      abi.encode(\n        _PERMIT_TYPEHASH,\n        owner,\n        spender,\n        value,\n        _useNonce(owner),\n        deadline\n      )\n    );\n\n    bytes32 hash = _hashTypedDataV4(structHash);\n\n    address signer = ECDSA.recover(hash, v, r, s);\n    require(signer == owner, \"ERC20Permit: invalid signature\");\n\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev See {IERC20Permit-nonces}.\n   */\n  function nonces(address owner) public view virtual returns (uint) {\n    return _nonces[owner].current();\n  }\n\n  /**\n   * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   *\n   * _Available since v4.1._\n   */\n  function _useNonce(address owner) internal virtual returns (uint current) {\n    Counters.Counter storage nonce = _nonces[owner];\n    current = nonce.current();\n    nonce.increment();\n  }\n}\n"
    },
    "contracts/test/lib/tokens/ERC20Lib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    } else if (error == RecoverError.InvalidSignatureV) {\n      revert(\"ECDSA: invalid signature 'v' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature` or error string. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   *\n   * Documentation for signature generation:\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(bytes32 hash, bytes memory signature)\n    internal\n    pure\n    returns (address, RecoverError)\n  {\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else if (signature.length == 64) {\n      bytes32 r;\n      bytes32 vs;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        vs := mload(add(signature, 0x40))\n      }\n      return tryRecover(hash, r, vs);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature)\n    internal\n    pure\n    returns (address)\n  {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n   *\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs &\n      bytes32(\n        0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      );\n    uint8 v = uint8((uint(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n   *\n   * _Available since v4.2._\n   */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (\n      uint(s) >\n      0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n    ) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n    if (v != 27 && v != 28) {\n      return (address(0), RecoverError.InvalidSignatureV);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return\n      keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes memory s)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return\n      keccak256(\n        abi.encodePacked(\n          \"\\x19Ethereum Signed Message:\\n\",\n          Strings.toString(s.length),\n          s\n        )\n      );\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint temp = value;\n    uint length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint value, uint length)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n  /* solhint-disable var-name-mixedcase */\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n  uint private immutable _CACHED_CHAIN_ID;\n  address private immutable _CACHED_THIS;\n\n  bytes32 private immutable _HASHED_NAME;\n  bytes32 private immutable _HASHED_VERSION;\n  bytes32 private immutable _TYPE_HASH;\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n   *\n   * The meaning of `name` and `version` is specified in\n   * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n   *\n   * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n   * - `version`: the current major version of the signing domain.\n   *\n   * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n   * contract upgrade].\n   */\n  constructor(string memory name, string memory version) {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\n      \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = block.chainid;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\n      typeHash,\n      hashedName,\n      hashedVersion\n    );\n    _CACHED_THIS = address(this);\n    _TYPE_HASH = typeHash;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          typeHash,\n          nameHash,\n          versionHash,\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for this domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function _hashTypedDataV4(bytes32 structHash)\n    internal\n    view\n    virtual\n    returns (bytes32)\n  {\n    return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n}\n"
    },
    "contracts/test/toy_strategies/AaveLender.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\nimport \"contracts/test/lib/Fork.sol\";\nimport \"contracts/toy_strategies/single_user/cash_management/AdvancedAaveRetail.sol\";\n\nabstract contract AaveV3ModuleTest is MangroveTest {\n  /* aave expectations */\n  function assertApproxBalanceAndBorrow(\n    AaveV3Module op,\n    IERC20 underlying,\n    uint expected_balance,\n    uint expected_borrow,\n    address account\n  ) public {\n    uint balance = op.overlying(underlying).balanceOf(account);\n    uint borrow = op.borrowed($(underlying), account);\n    console2.log(\"borrow is\", borrow);\n    assertApproxEqAbs(\n      balance,\n      expected_balance,\n      (10**14) / 2,\n      \"wrong balance on lender\"\n    );\n    assertApproxEqAbs(\n      borrow,\n      expected_borrow,\n      (10**14) / 2,\n      \"wrong borrow on lender\"\n    );\n  }\n}\n\n// warning! currently only known to work on Polygon, block 26416000\n// at a later point, Aave disables stable dai borrowing which those tests need\ncontract AaveLenderTest is AaveV3ModuleTest {\n  IERC20 weth;\n  IERC20 dai;\n  AaveDeepRouter router;\n  AdvancedAaveRetail strat;\n\n  receive() external payable {}\n\n  function setUp() public override {\n    Fork.setUp();\n\n    mgv = setupMangrove();\n    mgv.setVault($(mgv));\n\n    dai = IERC20(Fork.DAI);\n    weth = IERC20(Fork.WETH);\n    options.defaultFee = 30;\n    setupMarket(dai, weth);\n\n    weth.approve($(mgv), type(uint).max);\n    dai.approve($(mgv), type(uint).max);\n\n    deal($(weth), $(this), 10 ether);\n    deal($(dai), $(this), 10_000 ether);\n  }\n\n  function test_run() public {\n    deployStrat();\n\n    execTraderStrat();\n  }\n\n  function deployStrat() public {\n    strat = new AdvancedAaveRetail({\n      _mgv: IMangrove($(mgv)),\n      _addressesProvider: Fork.AAVE,\n      deployer: $(this)\n    });\n\n    router = AaveDeepRouter($(strat.router()));\n    // note for later: compound is\n    //   simple/advanced compoudn= Contract.deploy(Fork.COMP,IMangrove($(mgv)),Fork.WETH,$(this));\n    //   market = [Fork.CWETH,Fork.CDAI];\n\n    // aave rejects market entering if underlying balance is 0 (will self enter at first deposit)\n    // enterMarkets = false; // compound should have it set to true\n    // provisioning Mangrove on behalf of MakerContract\n    mgv.fund{value: 2 ether}($(strat));\n\n    // testSigner approves Mangrove for WETH/DAI before trying to take offers\n    weth.approve($(mgv), type(uint).max);\n    dai.approve($(mgv), type(uint).max);\n\n    // offer should get/put base/quote tokens on lender contract (OK since sender is MakerContract admin)\n    // strat.enterMarkets(market); // not on aave\n    IERC20[] memory tokens = new IERC20[](2);\n    tokens[0] = dai;\n    tokens[1] = weth;\n    strat.activate(tokens);\n\n    // One sends 1000 DAI to MakerContract\n    dai.transfer($(strat), 1000 ether);\n\n    // testSigner asks makerContract to approve lender to be able to mint [c/a]Token\n    router.approveLender(weth);\n    // NB in the special case of cEth this is only necessary to repay debt\n    router.approveLender(dai);\n\n    // makerContract deposits some DAI on Lender (remains 100 DAIs on the contract)\n    router.supply(\n      dai,\n      strat.reserve(),\n      900 ether,\n      $(strat) /* from */\n    );\n  }\n\n  function execTraderStrat() public {\n    // TODO logLenderStatus\n    uint offerId = strat.newOffer(\n      IOfferLogic.MakerOrder({\n        outbound_tkn: dai,\n        inbound_tkn: weth,\n        wants: 0.15 ether,\n        gives: 300 ether,\n        gasreq: strat.ofr_gasreq(),\n        gasprice: 0,\n        pivotId: 0,\n        offerId: 0\n      })\n    );\n\n    (, uint got, uint gave, , ) = mgv.snipes({\n      outbound_tkn: $(dai),\n      inbound_tkn: $(weth),\n      targets: wrap_dynamic([offerId, 300 ether, 0.15 ether, type(uint).max]),\n      fillWants: true\n    });\n    assertEq(got, minusFee($(dai), $(weth), 300 ether), \"wrong got amount\");\n\n    // TODO logLenderStatus\n    assertApproxBalanceAndBorrow(router, dai, 700 ether, 0, $(router));\n    assertApproxBalanceAndBorrow(router, weth, gave, 0, $(router));\n\n    offerId = strat.newOffer(\n      IOfferLogic.MakerOrder({\n        outbound_tkn: weth,\n        inbound_tkn: dai,\n        wants: 380 ether,\n        gives: 0.2 ether,\n        gasreq: strat.ofr_gasreq(),\n        gasprice: 0,\n        pivotId: 0,\n        offerId: 0\n      })\n    );\n\n    vm.warp(block.timestamp + 10);\n    (uint successes, , , , ) = mgv.snipes({\n      outbound_tkn: $(weth),\n      inbound_tkn: $(dai),\n      targets: wrap_dynamic([offerId, 0.2 ether, 380 ether, type(uint).max]),\n      fillWants: true\n    });\n    assertEq(successes, 1, \"snipes should succeed\");\n\n    // TODO logLenderStatus\n\n    assertApproxBalanceAndBorrow(router, weth, 0, 0.05 ether, $(router));\n\n    offerId = strat.newOffer(\n      IOfferLogic.MakerOrder({\n        outbound_tkn: dai,\n        inbound_tkn: weth,\n        wants: 0.63 ether,\n        gives: 1500 ether,\n        gasreq: strat.ofr_gasreq(),\n        gasprice: 0,\n        pivotId: 0,\n        offerId: 0\n      })\n    );\n\n    // cannot borrowrepay in same block\n    vm.warp(block.timestamp + 1);\n\n    (, got, , , ) = mgv.snipes({\n      outbound_tkn: $(dai),\n      inbound_tkn: $(weth),\n      targets: wrap_dynamic([offerId, 1500 ether, 0.63 ether, type(uint).max]),\n      fillWants: true\n    });\n    assertEq(\n      got,\n      minusFee($(dai), $(weth), 1500 ether),\n      \"wrong received amount\"\n    );\n\n    // TODO logLenderStatus\n    assertApproxBalanceAndBorrow(router, weth, 0.58 ether, 0, $(router));\n    // TODO check borrowing DAIs and not borrowing WETHs anymore\n  }\n}\n"
    },
    "contracts/test/lib/Fork.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\nimport \"foundry_lib/forge-std/src/Vm.sol\";\n\n/* Only fork we deal with for now is Polygon\n   In the future, strategies for managing multiple forks:\n   * always import Fork, initialize it differently using env vars\n   * always import Fork, but its locations depends on dynamic remapping\n   * have multiple contracts (PolygonFork, AaveFork etc), and pick one depending on environment\n*/\nlibrary Fork {\n  // vm call setup\n  address private constant VM_ADDRESS =\n    address(bytes20(uint160(uint(keccak256(\"hevm cheat code\")))));\n\n  Vm public constant vm = Vm(VM_ADDRESS);\n\n  // polygon mainnet addresses\n  address constant AAVE = 0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb;\n  address constant APOOL = 0x794a61358D6845594F94dc1DB02A252b5b4814aD;\n  address constant WETH = 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619;\n  address constant USDC = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n  address constant AWETH = 0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8;\n  address constant DAI = 0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063;\n  address constant ADAI = 0x82E64f49Ed5EC1bC6e43DAD4FC8Af9bb3A2312EE;\n  address constant CDAI = 0x4eCEDdF62277eD78623f9A94995c680f8fd6C00e;\n  address constant CUSDC = 0x73CF8c5D14Aa0EbC89f18272A568319F5BAB6cBD;\n  address constant CWETH = 0x7ef18d0a9C3Fb1A716FF6c3ED0Edf52a2427F716;\n  uint constant EXPECTED_CHAIN_ID = 137;\n  string constant FORK_NAME = \"Polygon\";\n\n  // temporarily duplicate function\n  function uint2str(uint _i)\n    internal\n    pure\n    returns (string memory _uintAsString)\n  {\n    unchecked {\n      if (_i == 0) {\n        return \"0\";\n      }\n      uint j = _i;\n      uint len;\n      while (j != 0) {\n        len++;\n        j /= 10;\n      }\n      bytes memory bstr = new bytes(len);\n      uint k = len - 1;\n      while (_i != 0) {\n        bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n        _i /= 10;\n      }\n      return string(bstr);\n    }\n  }\n\n  function setUp() public {\n    if (block.chainid != 137) {\n      revert(\n        string.concat(\n          \"Chain id should be \",\n          uint2str(EXPECTED_CHAIN_ID),\n          \" (\",\n          FORK_NAME,\n          \"), is \",\n          uint2str(block.chainid)\n        )\n      );\n    }\n\n    vm.label(AAVE, \"Aave\");\n    vm.label(APOOL, \"Aave Pool\");\n    vm.label(WETH, \"WETH\");\n    vm.label(USDC, \"USDC\");\n    vm.label(AWETH, \"AWETH\");\n    vm.label(DAI, \"DAI\");\n    vm.label(ADAI, \"ADAI\");\n    vm.label(CDAI, \"CDAI\");\n    vm.label(CUSDC, \"CUSDC\");\n    vm.label(CWETH, \"CWETH\");\n  }\n}\n"
    },
    "contracts/toy_strategies/single_user/cash_management/AdvancedAaveRetail.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedAaveRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/single_user/abstract/Persistent.sol\";\nimport \"contracts/strategies/routers/AaveDeepRouter.sol\";\n\ncontract AdvancedAaveRetail is Persistent {\n  constructor(\n    IMangrove _mgv,\n    address _addressesProvider,\n    address deployer\n  ) Persistent(_mgv, 30_000, new AaveDeepRouter(_addressesProvider, 0, 2)) {\n    // Router reserve is by default `router.address`\n    // use `set_reserve(addr)` to change this\n    router().setAdmin(deployer);\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n    }\n  }\n\n  // overriding put to leverage taker's liquidity on aave\n  // this function will deposit incoming liquidity to increase borrow power during trade\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    override\n    returns (uint missingPut)\n  {\n    push(IERC20(order.inbound_tkn), amount);\n    return 0;\n  }\n}\n"
    },
    "contracts/strategies/single_user/abstract/Persistent.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Persistent.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./SingleUser.sol\";\n\n/** Strat class with specialized hooks that repost offer residual after a partial fill */\n/** (Single user variant) */\n\nabstract contract Persistent is SingleUser {\n  constructor(\n    IMangrove _mgv,\n    uint strat_gasreq,\n    AbstractRouter _router\n  ) SingleUser(_mgv, strat_gasreq, _router) {}\n\n  /** Persistent class specific hooks. */\n\n  // Hook that defines how much inbound tokens the residual offer should ask for when repositing itself on the Offer List.\n  // default is to repost the old amount minus the partial fill\n  function __residualWants__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.wants() - order.gives;\n  }\n\n  // Hook that defines how much outbound tokens the residual offer should promise for when repositing itself on the Offer List.\n  // default is to repost the old required amount minus the partial fill\n  // NB this could produce an offer below the density. Offer Maker should perform a density check at repost time if not willing to fail reposting.\n  function __residualGives__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.gives() - order.wants;\n  }\n\n  // Specializing this hook to repost offer residual when trade was a success\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool)\n  {\n    // flushing inbound and remaining outbound tokens to reserve\n    super.__posthookSuccess__(order);\n\n    // now trying to repost residual\n    uint new_gives = __residualGives__(order);\n    // Density check would be too gas costly.\n    // We only treat the special case of `gives==0` (total fill).\n    // Offer below the density will cause Mangrove to throw (revert is catched to log information)\n    if (new_gives == 0) {\n      return true;\n    }\n    uint new_wants = __residualWants__(order);\n    try\n      MGV.updateOffer(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        new_wants,\n        new_gives,\n        order.offerDetail.gasreq(),\n        order.offerDetail.gasprice(),\n        order.offer.next(),\n        order.offerId\n      )\n    {\n      return true;\n    } catch (bytes memory reason) {\n      // `newOffer` can fail when Mango is under provisioned or if `offer.gives` is below density\n      // Log incident only if under provisioned\n      if (keccak256(reason) == keccak256(\"mgv/insufficientProvision\")) {\n        emit LogIncident(\n          MGV,\n          IERC20(order.outbound_tkn),\n          IERC20(order.inbound_tkn),\n          order.offerId,\n          \"Persistent/hook/outOfProvision\"\n        );\n      }\n      return false;\n    }\n  }\n}\n"
    },
    "contracts/strategies/routers/AaveDeepRouter.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveDeepRouter.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"./AaveRouter.sol\";\n\n// Underlying on AAVE\n// Overlying on reserve\n// `this` must approve Lender for outbound token transfer (pull)\n// `this` must approve Lender for inbound token transfer (flush)\n// `this` must be approved by reserve for *overlying* of inbound token transfer\n// `this` must be approved by maker contract for outbound token transfer\n\ncontract AaveDeepRouter is AaveRouter {\n  constructor(\n    address _addressesProvider,\n    uint _referralCode,\n    uint _interestRateMode\n  ) AaveRouter(_addressesProvider, _referralCode, _interestRateMode) {\n    ARSt.get_storage().gas_overhead += 350_000; // additional borrow\n  }\n\n  // 1. pulls aTokens from aToken reserve. Borrows if necessary\n  // 2. redeems underlying on AAVE and forwards received tokens to maker contract\n  function __pull__(\n    IERC20 token,\n    address reserve,\n    address maker,\n    uint amount,\n    bool strict\n  ) internal virtual override returns (uint pulled) {\n    return redeemThenBorrow(token, reserve, amount, strict, maker);\n  }\n}\n"
    },
    "contracts/strategies/single_user/abstract/SingleUser.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SingleUser.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../../MangroveOffer.sol\";\nimport \"contracts/strategies/utils/TransferLib.sol\";\nimport {SingleUserStorage as SUS} from \"./SingleUserStorage.sol\";\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nabstract contract SingleUser is MangroveOffer {\n  constructor(\n    IMangrove _mgv,\n    uint strat_gasreq,\n    AbstractRouter _router\n  ) MangroveOffer(_mgv, strat_gasreq) {\n    // default reserve is router's address if router is defined\n    // if not then default reserve is `this` contract\n    if (address(_router) == address(0)) {\n      set_reserve(address(this));\n    } else {\n      set_reserve(address(_router));\n      set_router(_router);\n    }\n  }\n\n  function reserve() public view returns (address) {\n    return SUS.get_storage().reserve;\n  }\n\n  function set_reserve(address _reserve) public mgvOrAdmin {\n    require(_reserve != address(0), \"SingleUser/0xReserve\");\n    SUS.get_storage().reserve = _reserve;\n  }\n\n  function withdrawToken(\n    IERC20 token,\n    address receiver,\n    uint amount\n  ) external override onlyAdmin returns (bool success) {\n    require(receiver != address(0), \"SingleUser/withdrawToken/0xReceiver\");\n    if (!has_router()) {\n      return TransferLib.transferToken(IERC20(token), receiver, amount);\n    } else {\n      router().withdrawToken(token, reserve(), receiver, amount);\n    }\n  }\n\n  function pull(\n    IERC20 outbound_tkn,\n    uint amount,\n    bool strict\n  ) internal returns (uint) {\n    AbstractRouter _router = MOS.get_storage().router;\n    if (address(_router) == address(0)) {\n      return 0; // nothing to do\n    } else {\n      // letting specific router pull the funds from reserve\n      return _router.pull(outbound_tkn, reserve(), amount, strict);\n    }\n  }\n\n  function push(IERC20 token, uint amount) internal {\n    AbstractRouter _router = MOS.get_storage().router;\n    if (address(_router) == address(0)) {\n      return; // nothing to do\n    } else {\n      // noop if reserve == address(this)\n      _router.push(token, reserve(), amount);\n    }\n  }\n\n  function tokenBalance(IERC20 token) external view override returns (uint) {\n    AbstractRouter _router = MOS.get_storage().router;\n    uint balance = token.balanceOf(reserve());\n    return\n      address(_router) == address(0)\n        ? balance\n        : balance + _router.reserveBalance(token, reserve());\n  }\n\n  function flush(IERC20[] memory tokens) internal {\n    AbstractRouter _router = MOS.get_storage().router;\n    if (address(_router) == address(0)) {\n      return; // nothing to do\n    } else {\n      _router.flush(tokens, reserve());\n    }\n  }\n\n  // Posting a new offer on the (`outbound_tkn,inbound_tkn`) Offer List of Mangrove.\n  // NB #1: Offer maker maker MUST:\n  // * Approve Mangrove for at least `gives` amount of `outbound_tkn`.\n  // * Make sure that `this` contract has enough WEI provision on Mangrove to cover for the new offer bounty (function is payable so that caller can increase provision prior to posting the new offer)\n  // * Make sure that `gasreq` and `gives` yield a sufficient offer density\n  // NB #2: This function will revert when the above points are not met\n  function newOffer(MakerOrder memory mko)\n    external\n    payable\n    override\n    onlyAdmin\n    returns (uint)\n  {\n    mko.offerId = MGV.newOffer{value: msg.value}(\n      address(mko.outbound_tkn),\n      address(mko.inbound_tkn),\n      mko.wants,\n      mko.gives,\n      mko.gasreq >= type(uint24).max ? ofr_gasreq() : mko.gasreq,\n      mko.gasprice,\n      mko.pivotId\n    );\n    return mko.offerId;\n  }\n\n  // Updates offer `offerId` on the (`outbound_tkn,inbound_tkn`) Offer List of Mangrove.\n  // NB #1: Offer maker MUST:\n  // * Make sure that offer maker has enough WEI provision on Mangrove to cover for the new offer bounty in case Mangrove gasprice has increased (function is payable so that caller can increase provision prior to updating the offer)\n  // * Make sure that `gasreq` and `gives` yield a sufficient offer density\n  // NB #2: This function will revert when the above points are not met\n  function updateOffer(MakerOrder memory mko)\n    external\n    payable\n    override\n    onlyAdmin\n  {\n    return\n      MGV.updateOffer{value: msg.value}(\n        address(mko.outbound_tkn),\n        address(mko.inbound_tkn),\n        mko.wants,\n        mko.gives,\n        mko.gasreq > type(uint24).max ? ofr_gasreq() : mko.gasreq,\n        mko.gasprice,\n        mko.pivotId,\n        mko.offerId\n      );\n  }\n\n  // Retracts `offerId` from the (`outbound_tkn`,`inbound_tkn`) Offer list of Mangrove.\n  // Function call will throw if `this` contract is not the owner of `offerId`.\n  // Returned value is the amount of ethers that have been credited to `this` contract balance on Mangrove (always 0 if `deprovision=false`)\n  // NB `mgvOrAdmin` modifier guarantees that this function is either called by contract admin or during trade execution by Mangrove\n  function retractOffer(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId,\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\n  ) public override mgvOrAdmin returns (uint free_wei) {\n    free_wei = MGV.retractOffer(\n      address(outbound_tkn),\n      address(inbound_tkn),\n      offerId,\n      deprovision\n    );\n    require(MGV.withdraw(free_wei), \"SingleUser/withdrawFromMgv/withdrawFail\");\n    (bool noRevert, ) = msg.sender.call{value: free_wei}(\"\");\n    require(noRevert, \"SingleUser/weiTransferFail\");\n  }\n\n  function __put__(\n    uint, /*amount*/\n    ML.SingleOrder calldata\n  ) internal virtual override returns (uint missing) {\n    // singleUser contract do not need to do anything specific with incoming funds during trade\n    return 0;\n  }\n\n  // default `__get__` hook for `SingleUser` is to pull liquidity from immutable `reserve()`\n  // letting router handle the specifics if any\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint missing)\n  {\n    // pulling liquidity from reserve\n    // depending on the router, this may result in pulling more/less liquidity than required\n    // so one should check local balance to compute missing liquidity\n    uint pulled = pull(IERC20(order.outbound_tkn), amount, false);\n    if (pulled >= amount) {\n      return 0;\n    } else {\n      uint local_balance = IERC20(order.outbound_tkn).balanceOf(address(this));\n      return local_balance >= amount ? 0 : amount - local_balance;\n    }\n  }\n\n  ////// Customizable post-hooks.\n\n  // Override this post-hook to implement what `this` contract should do when called back after a successfully executed order.\n  // In this posthook, contract will flush its liquidity towards the reserve (noop if reserve is this contract)\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool success)\n  {\n    IERC20[] memory tokens = new IERC20[](2);\n    tokens[0] = IERC20(order.outbound_tkn); // flushing outbound tokens if this contract pulled more liquidity than required during `makerExecute`\n    tokens[1] = IERC20(order.inbound_tkn); // flushing liquidity brought by taker\n    // sends all tokens to the reserve (noop if reserve() == address(this))\n    flush(tokens);\n    success = true;\n  }\n}\n"
    },
    "contracts/strategies/MangroveOffer.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangroveOffer.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/utils/AccessControlled.sol\";\nimport {MangroveOfferStorage as MOS} from \"./MangroveOfferStorage.sol\";\nimport \"contracts/strategies/interfaces/IOfferLogic.sol\";\nimport \"contracts/IMangrove.sol\";\n\n// Naming scheme:\n// `f() public`: can be used as is in all descendants of `this` contract\n// `_f() internal`: descendant of this contract should provide a public wrapper of this function\n// `__f__() virtual internal`: descendant of this contract may override this function to specialize the strat\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nabstract contract MangroveOffer is AccessControlled, IOfferLogic {\n  // immutable does not impact storage layout\n  IMangrove public immutable MGV;\n  // `this` contract entypoint is `makerExecute` or `makerPosthook` if `msg.sender == address(MGV)`\n  // `this` contract was called on an admin function iff `msg.sender = admin`\n\n  modifier mgvOrAdmin() {\n    require(\n      msg.sender == admin() || msg.sender == address(MGV),\n      \"AccessControlled/Invalid\"\n    );\n    _;\n  }\n\n  // necessary function to withdraw funds from Mangrove\n  receive() external payable virtual {}\n\n  constructor(IMangrove _mgv, uint strat_gasreq) AccessControlled(msg.sender) {\n    require(\n      strat_gasreq == uint24(strat_gasreq),\n      \"MangroveOffer/gasreqTooHigh\"\n    );\n    MGV = _mgv;\n    MOS.get_storage().ofr_gasreq = strat_gasreq;\n  }\n\n  function ofr_gasreq() public view returns (uint) {\n    if (has_router()) {\n      return MOS.get_storage().ofr_gasreq + router().gas_overhead();\n    } else {\n      return MOS.get_storage().ofr_gasreq;\n    }\n  }\n\n  /////// Mandatory callback functions\n\n  // `makerExecute` is the callback function to execute all offers that were posted on Mangrove by `this` contract.\n  // it may not be overriden although it can be customized using `__lastLook__`, `__put__` and `__get__` hooks.\n  // NB #1: When overriding the above hooks, the Offer Makers should make sure they do not revert in order if they wish to post logs in case of bad executions.\n  // NB #2: if `makerExecute` does revert, the offer will be considered to be refusing the trade.\n  // NB #3: `makerExecute` must return the empty bytes to signal to MGV it wishes to perform the trade. Any other returned byes will signal to MGV that `this` contract does not wish to proceed with the trade\n  // NB #4: Reneging on trade by either reverting or returning non empty bytes will have the following effects:\n  // * Offer is removed from the Order Book\n  // * Offer bounty will be withdrawn from offer provision and sent to the offer taker. The remaining provision will be credited to the maker account on Mangrove\n  function makerExecute(ML.SingleOrder calldata order)\n    external\n    override\n    onlyCaller(address(MGV))\n    returns (bytes32 ret)\n  {\n    if (!__lastLook__(order)) {\n      // hook to check order details and decide whether `this` contract should renege on the offer.\n      revert(\"mgvOffer/abort/reneged\");\n    }\n    if (__put__(order.gives, order) > 0) {\n      revert(\"mgvOffer/abort/putFailed\");\n    }\n    if (__get__(order.wants, order) > 0) {\n      revert(\"mgvOffer/abort/getFailed\");\n    }\n    return ret;\n  }\n\n  // `makerPosthook` is the callback function that is called by Mangrove *after* the offer execution.\n  // It may not be overriden although it can be customized via the post-hooks `__posthookSuccess__` and `__posthookFallback__` (see below).\n  // Offer Maker SHOULD make sure the overriden posthooks do not revert in order to be able to post logs in case of bad executions.\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override onlyCaller(address(MGV)) {\n    if (result.mgvData == \"mgv/tradeSuccess\") {\n      // toplevel posthook may ignore returned value which is only usefull for (vertical) compositionality\n      __posthookSuccess__(order);\n    } else {\n      emit LogIncident(\n        MGV,\n        IERC20(order.outbound_tkn),\n        IERC20(order.inbound_tkn),\n        order.offerId,\n        result.makerData\n      );\n      __posthookFallback__(order, result);\n    }\n  }\n\n  // sets default gasreq for `new/updateOffer`\n  function set_gasreq(uint gasreq) public override mgvOrAdmin {\n    require(uint24(gasreq) == gasreq, \"mgvOffer/gasreq/overflow\");\n    MOS.get_storage().ofr_gasreq = gasreq;\n    emit SetGasreq(gasreq);\n  }\n\n  /** Sets the account from which base (resp. quote) tokens need to be fetched or put during trade execution*/\n  /** */\n  /** NB Router might need further approval to work as intended*/\n  function set_router(AbstractRouter router_) public override mgvOrAdmin {\n    require(address(router_) != address(0), \"mgvOffer/set_router/0xRouter\");\n    MOS.get_storage().router = router_;\n    router_.bind(address(this));\n    emit SetRouter(router_);\n  }\n\n  // maker contract need to approve router for reserve push and pull\n  function approveRouter(IERC20 token) public {\n    require(\n      token.approve(address(router()), type(uint).max),\n      \"mgvOffer/approveRouter/Fail\"\n    );\n  }\n\n  function has_router() public view returns (bool) {\n    return address(MOS.get_storage().router) != address(0);\n  }\n\n  function router() public view returns (AbstractRouter) {\n    AbstractRouter router_ = MOS.get_storage().router;\n    require(address(router_) != address(0), \"mgvOffer/0xRouter\");\n    return router_;\n  }\n\n  /// `this` contract needs to approve Mangrove to let it perform outbound token transfer at the end of the `makerExecute` function\n  /// NB if anyone can call this function someone could reset it to 0 for griefing\n  function approveMangrove(IERC20 outbound_tkn) public {\n    require(\n      outbound_tkn.approve(address(MGV), type(uint).max),\n      \"mgvOffer/approveMangrove/Fail\"\n    );\n  }\n\n  ///@notice activation sequence for allowing this contract to be a `token` provider\n  ///@dev this function is public and unrestricted. It should only approve trusted contracts and give infinite approval to avoid griefing\n  ///@param tokens the ERC20s one wishes this contract to be a provider of \n  function activate(IERC20[] memory tokens) public override {\n    for (uint i=0; i<tokens.length; i++) {\n      __activate__(tokens[i]);\n    }\n  }\n\n  function __activate__(IERC20 token) internal virtual {\n    // allowing Mangrove to pull `token` from this contract (for trade execution)\n    approveMangrove(token);\n    if (has_router()) {\n      // allowing router to pull `token` from this contract (for the `push` function of the router)\n      approveRouter(token);\n    }\n  }\n\n  ///@notice withdraws ETH from the provision account on Mangrove and sends collected WEIs to `receiver`\n  ///@dev for multi user strats, the contract provision account on Mangrove is pooled amongst offer owners so admin should only call this function to recover WEIs (e.g. that were erroneously transferred to Mangrove using `MGV.fund()`)\n  /// This contract's balance on Mangrove may contain deprovisioned WEIs after an offer has failed (complement between provision and the bounty that was sent to taker)\n  /// those free WEIs can be retrieved by offer owners by calling `retractOffer` with the `deprovsion` flag. Not by calling this function which is admin only.\n\n  function withdrawFromMangrove(uint amount, address payable receiver)\n    external\n    onlyAdmin\n  {\n    if (amount == type(uint).max) {\n      amount = MGV.balanceOf(address(this));\n      if (amount == 0) {\n        return; // optim\n      }\n    }\n    require(MGV.withdraw(amount), \"mgvOffer/withdrawFromMgv/withdrawFail\");\n    (bool noRevert, ) = receiver.call{value: amount}(\"\");\n    require(noRevert, \"mgvOffer/withdrawFromMgv/payableCallFail\");\n  }\n\n  ////// Default Customizable hooks for Taker Order'execution\n\n  // Define this hook to describe where the inbound token, which are brought by the Offer Taker, should go during Taker Order's execution.\n  // Usage of this hook is the following:\n  // * `amount` is the amount of `inbound` tokens whose deposit location is to be defined when entering this function\n  // * `order` is a recall of the taker order that is at the origin of the current trade.\n  // * Function must return `missingPut` (<=`amount`), which is the amount of `inbound` tokens whose deposit location has not been decided (possibly because of a failure) during this function execution\n  // NB in case of preceding executions of descendant specific `__put__` implementations, `amount` might be lower than `order.gives` (how much `inbound` tokens the taker gave)\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint missingPut);\n\n  // Define this hook to implement fetching `amount` of outbound tokens, possibly from another source than `this` contract during Taker Order's execution.\n  // Usage of this hook is the following:\n  // * `amount` is the amount of `outbound` tokens that still needs to be brought to the balance of `this` contract when entering this function\n  // * `order` is a recall of the taker order that is at the origin of the current trade.\n  // * Function must return `missingGet` (<=`amount`), which is the amount of `outbound` tokens still need to be fetched at the end of this function\n  // NB in case of preceding executions of descendant specific `__get__` implementations, `amount` might be lower than `order.wants` (how much `outbound` tokens the taker wants)\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint missingGet);\n\n  // Override this hook to implement a last look check during Taker Order's execution.\n  // Return value should be `true` if Taker Order is acceptable.\n  // Returning `false` will cause `MakerExecute` to return the \"RENEGED\" bytes, which are interpreted by MGV as a signal that `this` contract wishes to cancel the trade\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (bool proceed)\n  {\n    order; //shh\n    proceed = true;\n  }\n\n  //utils\n  function $(IERC20 token) internal pure returns (address) {\n    return address(token);\n  }\n\n  // Override this post-hook to implement fallback behavior when Taker Order's execution failed unexpectedly. Information from Mangrove is accessible in `result.mgvData` for logging purpose.\n  function __posthookFallback__(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) internal virtual returns (bool success) {\n    order;\n    result;\n    return true;\n  }\n\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (bool)\n  {\n    order;\n    return true;\n  }\n\n  // returns missing provision to repost `offerId` at given `gasreq` and `gasprice`\n  // if `offerId` is not in the Order Book, will simply return how much is needed to post\n  // NB in the case of a multi user contract, this function does not take into account a potential partition of the provision of `this` amongst offer owners\n  function getMissingProvision(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint gasreq, // give > type(uint24).max to use `this.ofr_gasreq()`\n    uint gasprice, // give 0 to use Mangrove's gasprice\n    uint offerId // set this to 0 if one is not reposting an offer\n  ) public view returns (uint) {\n    (P.Global.t globalData, P.Local.t localData) = MGV.config(\n      $(outbound_tkn),\n      $(inbound_tkn)\n    );\n    P.OfferDetail.t offerDetailData = MGV.offerDetails(\n      $(outbound_tkn),\n      $(inbound_tkn),\n      offerId\n    );\n    uint _gp;\n    if (globalData.gasprice() > gasprice) {\n      _gp = globalData.gasprice();\n    } else {\n      _gp = gasprice;\n    }\n    if (gasreq >= type(uint24).max) {\n      gasreq = ofr_gasreq(); // this includes overhead of router if any\n    }\n    uint bounty = (gasreq + localData.offer_gasbase()) * _gp * 10**9; // in WEI\n    // if `offerId` is not in the OfferList, all returned values will be 0\n    uint currentProvisionLocked = (offerDetailData.gasreq() +\n      offerDetailData.offer_gasbase()) *\n      offerDetailData.gasprice() *\n      10**9;\n    uint currentProvision = currentProvisionLocked +\n      MGV.balanceOf(address(this));\n    return (currentProvision >= bounty ? 0 : bounty - currentProvision);\n  }\n}\n"
    },
    "contracts/strategies/utils/TransferLib.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleOrale.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport {IERC20} from \"contracts/MgvLib.sol\";\n\n// TODO-foundry-merge explain what this contract does\n\nlibrary TransferLib {\n  // utils\n  function transferToken(\n    IERC20 token,\n    address recipient,\n    uint amount\n  ) internal returns (bool) {\n    if (amount == 0 || recipient == address(this)) {\n      return true;\n    }\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(token.transfer.selector, recipient, amount)\n    );\n    return (success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function transferTokenFrom(\n    IERC20 token,\n    address spender,\n    address recipient,\n    uint amount\n  ) internal returns (bool) {\n    if (amount == 0 || spender == recipient) {\n      return true;\n    }\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(\n        token.transferFrom.selector,\n        spender,\n        recipient,\n        amount\n      )\n    );\n    return (success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}\n"
    },
    "contracts/strategies/single_user/abstract/SingleUserStorage.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SingleUserStorage.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nlibrary SingleUserStorage {\n  struct Layout {\n    address reserve;\n  }\n\n  function get_storage() internal pure returns (Layout storage st) {\n    bytes32 storagePosition = keccak256(\"Mangrove.SingleUserStorage.Layout\");\n    assembly {\n      st.slot := storagePosition\n    }\n  }\n}\n"
    },
    "contracts/strategies/MangroveOfferStorage.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangroveOffer.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/interfaces/IOfferLogic.sol\";\n\n// Naming scheme:\n// `f() public`: can be used as is in all descendants of `this` contract\n// `_f() internal`: descendant of this contract should provide a public wrapper of this function\n// `__f__() virtual internal`: descendant of this contract may override this function to specialize the strat\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nlibrary MangroveOfferStorage {\n  struct Layout {\n    // default values\n    uint ofr_gasreq;\n    AbstractRouter router;\n  }\n\n  function get_storage() internal pure returns (Layout storage st) {\n    bytes32 storagePosition = keccak256(\"Mangrove.MangroveOfferStorage\");\n    assembly {\n      st.slot := storagePosition\n    }\n  }\n}\n"
    },
    "contracts/strategies/interfaces/IOfferLogic.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SwingingMarketMaker.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity >=0.8.0;\npragma abicoder v2;\nimport \"contracts/IMangrove.sol\";\nimport {IERC20} from \"contracts/MgvLib.sol\";\nimport \"contracts/strategies/routers/AbstractRouter.sol\";\n\ninterface IOfferLogic is IMaker {\n  ///////////////////\n  // MangroveOffer //\n  ///////////////////\n\n  /** @notice Events */\n\n  // Log incident (during post trade execution)\n  event LogIncident(\n    IMangrove mangrove,\n    IERC20 indexed outbound_tkn,\n    IERC20 indexed inbound_tkn,\n    uint indexed offerId,\n    bytes32 reason\n  );\n\n  // Logging change of router address\n  event SetRouter(AbstractRouter);\n  // Logging change in default gasreq\n  event SetGasreq(uint);\n\n  // Offer logic default gas required --value is used in update and new offer if maxUint is given\n  function ofr_gasreq() external returns (uint);\n\n  // returns missing provision on Mangrove, should `offerId` be reposted using `gasreq` and `gasprice` parameters\n  // if `offerId` is not in the `outbound_tkn,inbound_tkn` offer list, the totality of the necessary provision is returned\n  function getMissingProvision(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint gasreq,\n    uint gasprice,\n    uint offerId\n  ) external view returns (uint);\n\n  // Changing ofr_gasreq of the logic\n  function set_gasreq(uint gasreq) external;\n\n  // changing liqudity router of the logic\n  function set_router(AbstractRouter router) external;\n\n  // maker contract approves router for push and pull operations\n  function approveRouter(IERC20 token) external;\n\n  // withdraw `amount` `token` form the contract's (owner) reserve and sends them to `receiver`'s balance\n  function withdrawToken(\n    IERC20 token,\n    address receiver,\n    uint amount\n  ) external returns (bool success);\n\n  ///@return balance the  `token` amount that `msg.sender` has in the contract's reserve\n  function tokenBalance(IERC20 token) external returns (uint balance);\n\n  // allow this contract to act as a LP for Mangrove on `outbound_tkn`\n  function approveMangrove(IERC20 outbound_tkn) external;\n\n  // contract's activation sequence for a specific ERC \n  function activate(IERC20[] memory tokens) external; \n\n  // pulls available free wei from Mangrove balance to `this`\n  function withdrawFromMangrove(uint amount, address payable receiver) external;\n\n  struct MakerOrder {\n    IERC20 outbound_tkn; // address of the ERC20 contract managing outbound tokens\n    IERC20 inbound_tkn; // address of the ERC20 contract managing outbound tokens\n    uint wants; // amount of `inbound_tkn` required for full delivery\n    uint gives; // max amount of `outbound_tkn` promised by the offer\n    uint gasreq; // max gas required by the offer when called. If maxUint256 is used here, default `ofr_gasreq` will be considered instead\n    uint gasprice; // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\n    uint pivotId;\n    uint offerId; // 0 if new offer order\n  }\n\n  function newOffer(MakerOrder memory mko)\n    external\n    payable\n    returns (uint offerId);\n\n  //returns 0 if updateOffer failed (for instance if offer is underprovisioned) otherwise returns `offerId`\n  function updateOffer(MakerOrder memory mko) external payable;\n\n  function retractOffer(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId,\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\n  ) external returns (uint received);\n}\n"
    },
    "contracts/IMangrove.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This file was manually adapted from a file generated by abi-to-sol. It must\n// be kept up-to-date with the actual Mangrove interface. Fully automatic\n// generation is not yet possible due to user-generated types in the external\n// interface lost in the abi generation.\n\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\nimport {MgvLib as ML, P, IMaker} from \"./MgvLib.sol\";\n\ninterface IMangrove {\n  event Approval(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address owner,\n    address spender,\n    uint value\n  );\n  event Credit(address indexed maker, uint amount);\n  event Debit(address indexed maker, uint amount);\n  event Kill();\n  event NewMgv();\n  event OfferFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    address taker,\n    uint takerWants,\n    uint takerGives,\n    bytes32 mgvData\n  );\n  event OfferRetract(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id\n  );\n  event OfferSuccess(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    address taker,\n    uint takerWants,\n    uint takerGives\n  );\n  event OfferWrite(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address maker,\n    uint wants,\n    uint gives,\n    uint gasprice,\n    uint gasreq,\n    uint id,\n    uint prev\n  );\n  event OrderComplete(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address indexed taker,\n    uint takerGot,\n    uint takerGave,\n    uint penalty\n  );\n  event OrderStart();\n  event PosthookFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId\n  );\n  event SetActive(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    bool value\n  );\n  event SetDensity(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetFee(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasbase(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offer_gasbase\n  );\n  event SetGasmax(uint value);\n  event SetGasprice(uint value);\n  event SetGovernance(address value);\n  event SetMonitor(address value);\n  event SetNotify(bool value);\n  event SetUseOracle(bool value);\n  event SetVault(address value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function activate(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee,\n    uint density,\n    uint offer_gasbase\n  ) external;\n\n  function allowances(\n    address,\n    address,\n    address,\n    address\n  ) external view returns (uint);\n\n  function approve(\n    address outbound_tkn,\n    address inbound_tkn,\n    address spender,\n    uint value\n  ) external returns (bool);\n\n  function balanceOf(address) external view returns (uint);\n\n  function best(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint);\n\n  function config(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (P.Global.t, P.Local.t);\n\n  function configInfo(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (P.GlobalStruct memory global, P.LocalStruct memory local);\n\n  function deactivate(address outbound_tkn, address inbound_tkn) external;\n\n  function flashloan(ML.SingleOrder memory sor, address taker)\n    external\n    returns (uint gasused);\n\n  function fund(address maker) external payable;\n\n  function fund() external payable;\n\n  function governance() external view returns (address);\n\n  function isLive(P.Offer.t offer) external pure returns (bool);\n\n  function kill() external;\n\n  function locked(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (bool);\n\n  function marketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants\n  )\n    external\n    returns (\n      uint takerGot,\n      uint takerGave,\n      uint bounty,\n      uint fee\n    );\n\n  function marketOrderFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint takerGot,\n      uint takerGave,\n      uint bounty,\n      uint fee\n    );\n\n  function newOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) external payable returns (uint);\n\n  function nonces(address) external view returns (uint);\n\n  function offerDetails(\n    address,\n    address,\n    uint\n  ) external view returns (P.OfferDetail.t);\n\n  function offerInfo(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  )\n    external\n    view\n    returns (\n      P.OfferStruct memory offer,\n      P.OfferDetailStruct memory offerDetail\n    );\n\n  function offers(\n    address,\n    address,\n    uint\n  ) external view returns (P.Offer.t);\n\n  function permit(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision\n  ) external returns (uint provision);\n\n  function setDensity(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint density\n  ) external;\n\n  function setFee(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee\n  ) external;\n\n  function setGasbase(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offer_gasbase\n  ) external;\n\n  function setGasmax(uint gasmax) external;\n\n  function setGasprice(uint gasprice) external;\n\n  function setGovernance(address governanceAddress) external;\n\n  function setMonitor(address monitor) external;\n\n  function setNotify(bool notify) external;\n\n  function setUseOracle(bool useOracle) external;\n\n  function setVault(address vaultAddress) external;\n\n  function snipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] memory targets,\n    bool fillWants\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint bounty,\n      uint fee\n    );\n\n  function snipesFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] memory targets,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint bounty,\n      uint fee\n    );\n\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external payable;\n\n  function vault() external view returns (address);\n\n  function withdraw(uint amount) external returns (bool noRevert);\n\n  receive() external payable;\n}\n\n// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:\n/*\n[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasmax\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Credit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Debit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Kill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewMgv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mgvData\",\"type\":\"bytes32\"}],\"name\":\"OfferFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OfferRetract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"}],\"name\":\"OfferSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"}],\"name\":\"OfferWrite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerGave\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"OrderComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OrderStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"PosthookFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetDensity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"}],\"name\":\"SetGasbase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetGasmax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetGasprice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"SetGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"SetMonitor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetNotify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetUseOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"SetVault\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"best\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"config\",\"outputs\":[{\"internalType\":\"Global.t\",\"name\":\"_global\",\"type\":\"uint256\"},{\"internalType\":\"Local.t\",\"name\":\"_local\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"configInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"monitor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useOracle\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"notify\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasmax\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"dead\",\"type\":\"bool\"}],\"internalType\":\"struct GlobalStruct\",\"name\":\"global\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"best\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last\",\"type\":\"uint256\"}],\"internalType\":\"struct LocalStruct\",\"name\":\"local\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"Offer.t\",\"name\":\"offer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"OfferDetail.t\",\"name\":\"offerDetail\",\"type\":\"uint256\"},{\"internalType\":\"Global.t\",\"name\":\"global\",\"type\":\"uint256\"},{\"internalType\":\"Local.t\",\"name\":\"local\",\"type\":\"uint256\"}],\"internalType\":\"struct MgvLib.SingleOrder\",\"name\":\"sor\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"flashloan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasused\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"}],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Offer.t\",\"name\":\"offer\",\"type\":\"uint256\"}],\"name\":\"isLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"}],\"name\":\"marketOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerWants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGives\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"marketOrderFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"takerGot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGave\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pivotId\",\"type\":\"uint256\"}],\"name\":\"newOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offerDetails\",\"outputs\":[{\"internalType\":\"OfferDetail.t\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"offerInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"next\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferStruct\",\"name\":\"offer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferDetailStruct\",\"name\":\"offerDetail\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"internalType\":\"Offer.t\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deprovision\",\"type\":\"bool\"}],\"name\":\"retractOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"provision\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"}],\"name\":\"setDensity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offer_gasbase\",\"type\":\"uint256\"}],\"name\":\"setGasbase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasmax\",\"type\":\"uint256\"}],\"name\":\"setGasmax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"}],\"name\":\"setGasprice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceAddress\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"monitor\",\"type\":\"address\"}],\"name\":\"setMonitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"notify\",\"type\":\"bool\"}],\"name\":\"setNotify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"useOracle\",\"type\":\"bool\"}],\"name\":\"setUseOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256[4][]\",\"name\":\"targets\",\"type\":\"uint256[4][]\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"}],\"name\":\"snipes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256[4][]\",\"name\":\"targets\",\"type\":\"uint256[4][]\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"snipesFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"successes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerGave\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pivotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"updateOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"noRevert\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]\n*/\n"
    },
    "contracts/strategies/routers/AbstractRouter.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AbstractRouter.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/utils/AccessControlled.sol\";\nimport {AbstractRouterStorage as ARSt} from \"./AbstractRouterStorage.sol\";\nimport {IERC20} from \"contracts/MgvLib.sol\";\n\nabstract contract AbstractRouter is AccessControlled {\n  function makers(address mkr) public view returns (bool) {\n    return ARSt.get_storage().makers[mkr];\n  }\n\n  function gas_overhead() public view returns (uint) {\n    return ARSt.get_storage().gas_overhead;\n  }\n\n  modifier onlyMakers() {\n    require(makers(msg.sender), \"Router/unauthorized\");\n    _;\n  }\n  modifier makersOrAdmin() {\n    require(msg.sender == admin() || makers(msg.sender), \"Router/unauthorized\");\n    _;\n  }\n\n  constructor(uint overhead) AccessControlled(msg.sender) {\n    require(uint24(overhead) == overhead, \"AbstractRouter/overheadTooHigh\");\n    ARSt.get_storage().gas_overhead = overhead;\n  }\n\n  // pulls `amount` of `token`s from reserve to maker contract's balance if necessary\n  // `reserve` is typically an EOA (for nice UX), the router contract itself (to minimize fragmentation when router is bound to several makers)\n  // or the Maker contract (to minimize transfer costs)\n  function pull(\n    IERC20 token,\n    address reserve,\n    uint amount,\n    bool strict\n  ) external onlyMakers returns (uint pulled) {\n    uint buffer = token.balanceOf(msg.sender);\n    if (buffer >= amount) {\n      return 0;\n    } else {\n      pulled = __pull__({\n        token: token,\n        reserve: reserve,\n        maker: msg.sender,\n        amount: amount,\n        strict: strict\n      });\n    }\n  }\n\n  function __pull__(\n    IERC20 token,\n    address reserve,\n    address maker,\n    uint amount,\n    bool strict\n  ) internal virtual returns (uint);\n\n  // pushes `amount` of `token`s from maker contract to reserve\n  function push(\n    IERC20 token,\n    address reserve,\n    uint amount\n  ) external onlyMakers {\n    __push__({\n      token: token,\n      reserve: reserve,\n      maker: msg.sender,\n      amount: amount\n    });\n  }\n\n  function __push__(\n    IERC20 token,\n    address reserve,\n    address maker,\n    uint amount\n  ) internal virtual;\n\n  function flush(IERC20[] calldata tokens, address reserve)\n    external\n    onlyMakers\n  {\n    for (uint i = 0; i < tokens.length; i++) {\n      uint amount = tokens[i].balanceOf(msg.sender);\n      if (amount > 0) {\n        __push__(tokens[i], reserve, msg.sender, amount);\n      }\n    }\n  }\n\n  // checks amount of `token`s available in the liquidity source\n  function reserveBalance(IERC20 token, address reserve)\n    external\n    view\n    virtual\n    returns (uint);\n\n  // withdraws `amount` of reserve tokens and sends them to `recipient`\n  function withdrawToken(\n    IERC20 token,\n    address reserve,\n    address recipient,\n    uint amount\n  ) public onlyMakers returns (bool) {\n    return __withdrawToken__(token, reserve, recipient, amount);\n  }\n\n  function __withdrawToken__(\n    IERC20 token,\n    address reserve,\n    address to,\n    uint amount\n  ) internal virtual returns (bool);\n\n  // connect a maker contract to this router\n  // if maker contract is `this` router's deployer, it will do so using admin privilege\n  // if `this` router was deployed independently of maker contract, binding must be done by router's deployer\n  function bind(address maker) public makersOrAdmin {\n    ARSt.get_storage().makers[maker] = true;\n  }\n\n  function unbind(address maker) public makersOrAdmin {\n    ARSt.get_storage().makers[maker] = false;\n  }\n}\n"
    },
    "contracts/strategies/routers/AbstractRouterStorage.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AbstractRouterStorage.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nlibrary AbstractRouterStorage {\n  struct Layout {\n    mapping(address => bool) makers;\n    uint gas_overhead;\n  }\n\n  function get_storage() internal pure returns (Layout storage st) {\n    bytes32 storagePosition = keccak256(\n      \"Mangrove.AbstractRouterStorageLib.Layout\"\n    );\n    assembly {\n      st.slot := storagePosition\n    }\n  }\n}\n"
    },
    "contracts/strategies/routers/AaveRouter.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveRouter.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/integrations/AaveV3Module.sol\";\nimport \"contracts/strategies/utils/AccessControlled.sol\";\nimport \"contracts/strategies/utils/TransferLib.sol\";\nimport \"./AbstractRouter.sol\";\n\n// Underlying on AAVE\n// Overlying on reserve\n// `this` must approve Lender for outbound token transfer (pull)\n// `this` must approve Lender for inbound token transfer (flush)\n// `this` must be approved by reserve for *overlying* of inbound token transfer\n// `this` must be approved by maker contract for outbound token transfer\n\n// gas overhead:\n// - supply ~ 250K\n// - borrow ~ 360K\ncontract AaveRouter is AbstractRouter, AaveV3Module {\n  constructor(\n    address _addressesProvider,\n    uint _referralCode,\n    uint _interestRateMode\n  )\n    AaveV3Module(_addressesProvider, _referralCode, _interestRateMode)\n    AbstractRouter(700_000)\n  {}\n\n  // 1. pulls aTokens from reserve\n  // 2. redeems underlying on AAVE to calling maker contract\n  function __pull__(\n    IERC20 token,\n    address reserve,\n    address maker,\n    uint amount,\n    bool strict\n  ) internal virtual override returns (uint pulled) {\n    uint available = reserveBalance(token, reserve);\n    // if strict enable one should pull at most `amount` from reserve\n    if (strict) {\n      amount = amount < available ? amount : available;\n    } else {\n      // one is pulling all availble funds from reserve\n      amount = available;\n    }\n    // transfer below is a noop (almost 0 gas) if reserve == address(this)\n    // needs to temporarily deposit tokens to `this` in order to be able to redeem to maker contract\n    TransferLib.transferTokenFrom(\n      overlying(token),\n      reserve,\n      address(this),\n      amount\n    );\n    // redeem below is a noop if amount_ == 0\n    return _redeem(token, amount, maker);\n  }\n\n  // Liquidity : MAKER --> `onBehalf`\n  function __push__(\n    IERC20 token,\n    address reserve,\n    address maker,\n    uint amount\n  ) internal virtual override {\n    require(\n      TransferLib.transferTokenFrom(token, maker, address(this), amount),\n      \"AaveRouter/push/transferFail\"\n    );\n    // repay and supply on behalf of `reserve`\n    repayThenDeposit(token, reserve, amount);\n  }\n\n  // returns 0 if redeem failed (amount > balance).\n  // Redeems user balance if amount == type(uint).max\n  function __withdrawToken__(\n    IERC20 token,\n    address reserve,\n    address to,\n    uint amount\n  ) internal override returns (bool) {\n    // note there is no possible redeem on behalf\n    require(\n      TransferLib.transferTokenFrom(\n        overlying(token),\n        reserve,\n        address(this),\n        amount\n      ),\n      \"AaveRouter/supply/transferFromFail\"\n    );\n    require(\n      _redeem(token, amount, to) == amount,\n      \"AaveRouter/withdrawToken/Fail\"\n    );\n    return true;\n  }\n\n  // Admin function to manage position on AAVE\n  function borrow(\n    IERC20 token,\n    address reserve,\n    uint amount,\n    address to\n  ) external onlyAdmin {\n    // NB if `reserve` != this, it must approve this router for increasing overlying debt token\n    _borrow(token, amount, reserve);\n    require(\n      TransferLib.transferToken(token, to, amount),\n      \"AaveRouter/borrow/transferFail\"\n    );\n  }\n\n  function repay(\n    IERC20 token,\n    address reserve,\n    uint amount,\n    address from\n  ) external onlyAdmin {\n    require(\n      TransferLib.transferTokenFrom(token, from, reserve, amount),\n      \"AaveRouter/repay/transferFromFail\"\n    );\n    _repay(token, amount, reserve);\n  }\n\n  function supply(\n    IERC20 token,\n    address reserve,\n    uint amount,\n    address from\n  ) external onlyAdmin {\n    require(\n      TransferLib.transferTokenFrom(token, from, reserve, amount),\n      \"AaveRouter/supply/transferFromFail\"\n    );\n    _supply(token, amount, reserve);\n  }\n\n  function claimRewards(\n    IRewardsControllerIsh rewardsController,\n    address[] calldata assets\n  )\n    external\n    onlyAdmin\n    returns (address[] memory rewardsList, uint[] memory claimedAmounts)\n  {\n    return _claimRewards(rewardsController, assets);\n  }\n\n  function reserveBalance(IERC20 token, address reserve)\n    public\n    view\n    virtual\n    override\n    returns (uint available)\n  {\n    (available, ) = maxGettableUnderlying(token, false, reserve);\n  }\n\n  function approveLender(IERC20 token) external {\n    _approveLender(token, type(uint).max);\n  }\n}\n"
    },
    "contracts/strategies/integrations/AaveV3Module.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveModule.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\n// TODO-foundry-merge explain what this contract does\n\nimport {AaveV3ModuleStorage as AMS} from \"./AaveModuleStorage.sol\";\nimport {AaveV3ModuleImplementation as AMI, IERC20, IRewardsControllerIsh, IPoolAddressesProvider, IPool, ICreditDelegationToken, IPool, IPriceOracleGetter, DataTypes} from \"./AaveModuleImplementation.sol\";\n\ncontract AaveV3Module {\n  address public immutable IMPLEMENTATION;\n  IPool public immutable POOL;\n  IPriceOracleGetter public immutable ORACLE;\n  uint public immutable INTEREST_RATE_MODE;\n  uint16 public immutable REFERRAL_CODE;\n\n  constructor(\n    address _addressesProvider,\n    uint _referralCode,\n    uint _interestRateMode\n  ) {\n    REFERRAL_CODE = uint16(_referralCode);\n    INTEREST_RATE_MODE = _interestRateMode;\n\n    address _priceOracle = IPoolAddressesProvider(_addressesProvider)\n      .getAddress(\"PRICE_ORACLE\");\n    address _lendingPool = IPoolAddressesProvider(_addressesProvider).getPool();\n    require(_priceOracle != address(0), \"AaveModule/0xPriceOracle\");\n    require(_lendingPool != address(0), \"AaveModule/0xPool\");\n\n    POOL = IPool(_lendingPool);\n    ORACLE = IPriceOracleGetter(_priceOracle);\n    IMPLEMENTATION = address(\n      new AMI(IPool(_lendingPool), IPriceOracleGetter(_priceOracle))\n    );\n  }\n\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  ///@notice approval the POOL contract by the underlying is necessary for supplying and repaying debt\n  ///@notice user must use this function to do so.\n  function _approveLender(IERC20 token, uint amount) internal {\n    token.approve(address(POOL), amount);\n  }\n\n  ///@notice exits markets\n  function _exitMarket(IERC20 underlying) internal {\n    POOL.setUserUseReserveAsCollateral(address(underlying), false);\n  }\n\n  function _enterMarkets(IERC20[] calldata underlyings) internal {\n    for (uint i = 0; i < underlyings.length; i++) {\n      POOL.setUserUseReserveAsCollateral(address(underlyings[i]), true);\n    }\n  }\n\n  function overlying(IERC20 asset) public view returns (IERC20 aToken) {\n    aToken = IERC20(POOL.getReserveData(address(asset)).aTokenAddress);\n  }\n\n  function debtToken(IERC20 asset)\n    public\n    view\n    returns (ICreditDelegationToken debtTkn)\n  {\n    debtTkn = INTEREST_RATE_MODE == 1\n      ? ICreditDelegationToken(\n        POOL.getReserveData(address(asset)).stableDebtTokenAddress\n      )\n      : ICreditDelegationToken(\n        POOL.getReserveData(address(asset)).variableDebtTokenAddress\n      );\n  }\n\n  function _staticdelegatecall(bytes calldata data) external {\n    require(msg.sender == address(this), \"AaveModule/internalOnly\");\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(data);\n    if (!success) {\n      AMS.revertWithData(retdata);\n    }\n    assembly {\n      return(add(retdata, 32), returndatasize())\n    }\n  }\n\n  /// @param asset the underlying asset to redeem and borrow\n  /// @param tryBorrow compute borrow capacity (costs extra gas)\n  /// @param onBehalf user for whom max redeem/borrow is computed\n  /// @return maxRedeemableUnderlying how much `onBehalf` can redeem of `asset`\n  /// @return maxBorrowAfterRedeemInUnderlying how much `onBehalf` could borrow in `asset` after redeeming `maxRedeemableUnderlying` if `tryBorrow` is `true`, 0 otherwise.\n  /// @dev Return max redeem and borrow capacity conditional on a potential redeem\n  /// @dev Using those values will might make you liquidatable at the next block\n  function maxGettableUnderlying(\n    IERC20 asset,\n    bool tryBorrow,\n    address onBehalf\n  )\n    public\n    view\n    returns (\n      uint maxRedeemableUnderlying,\n      uint maxBorrowAfterRedeemInUnderlying\n    )\n  {\n    (bool success, bytes memory retdata) = address(this).staticcall(\n      abi.encodeWithSelector(\n        this._staticdelegatecall.selector,\n        abi.encodeWithSelector(\n          AMI.$maxGettableUnderlying.selector,\n          asset,\n          tryBorrow,\n          onBehalf\n        )\n      )\n    );\n    if (!success) {\n      AMS.revertWithData(retdata);\n    } else {\n      return abi.decode(retdata, (uint, uint));\n    }\n  }\n\n  function repayThenDeposit(\n    IERC20 token,\n    address onBehalf,\n    uint amount\n  ) internal {\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(\n      abi.encodeWithSelector(\n        AMI.$repayThenDeposit.selector,\n        INTEREST_RATE_MODE,\n        REFERRAL_CODE,\n        token,\n        onBehalf,\n        amount\n      )\n    );\n    if (!success) {\n      AMS.revertWithData(retdata);\n    }\n  }\n\n  ///@notice redeems liquidity on aave, if not enough liquidity is redeemed, tries to borrow what's missing.\n  ///@param token the asset that needs to be redeemed\n  ///@param onBehalf the account whose collateral is beeing redeemed and borrowed upon.\n  ///@dev if `onBehalf != address(this)` then `this` needs to be approved by `onBehalf` using `ICreditDelegationToken.approveDelegation`\n  ///@param amount the target amount of `token` one needs to redeem\n  ///@param strict whether call allows contract to redeem more than amount (for gas optimization).\n  ///@dev function will only try to borrow if less than `amount` was redeemed and will not try to borrow more than what is missing, even if `strict` is not required.\n  ///@dev this is forced by aave v3 currently not allowing to repay a debt that was incurred on the same block (so no gas optim can be used). Repaying on the next block would be dangerous as `onBehalf` position could possibly be liquidated\n  ///@param recipient the target address to which redeemed and borrowed tokens should be sent\n  function redeemThenBorrow(\n    IERC20 token,\n    address onBehalf,\n    uint amount,\n    bool strict,\n    address recipient\n  ) internal returns (uint got) {\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(\n      abi.encodeWithSelector(\n        AMI.$redeemThenBorrow.selector,\n        INTEREST_RATE_MODE,\n        REFERRAL_CODE,\n        token,\n        onBehalf,\n        amount,\n        strict,\n        recipient\n      )\n    );\n    if (success) {\n      got = abi.decode(retdata, (uint));\n    } else {\n      AMS.revertWithData(retdata);\n    }\n  }\n\n  function _borrow(\n    IERC20 token,\n    uint amount,\n    address onBehalf\n  ) internal {\n    POOL.borrow(\n      address(token),\n      amount,\n      INTEREST_RATE_MODE,\n      REFERRAL_CODE,\n      onBehalf\n    );\n  }\n\n  function _redeem(\n    IERC20 token,\n    uint amount,\n    address to\n  ) internal returns (uint redeemed) {\n    redeemed = (amount == 0) ? 0 : POOL.withdraw(address(token), amount, to);\n  }\n\n  function _supply(\n    IERC20 token,\n    uint amount,\n    address onBehalf\n  ) internal {\n    if (amount == 0) {\n      return;\n    } else {\n      POOL.supply(address(token), amount, onBehalf, REFERRAL_CODE);\n    }\n  }\n\n  function _repay(\n    IERC20 token,\n    uint amount,\n    address onBehalf\n  ) internal returns (uint repaid) {\n    repaid = (amount == 0)\n      ? 0\n      : POOL.repay(address(token), amount, INTEREST_RATE_MODE, onBehalf);\n  }\n\n  // rewards claiming.\n  // may use `SingleUser.withdrawToken` to move collected tokens afterwards\n  function _claimRewards(\n    IRewardsControllerIsh rewardsController,\n    address[] calldata assets\n  )\n    internal\n    returns (address[] memory rewardsList, uint[] memory claimedAmounts)\n  {\n    (rewardsList, claimedAmounts) = rewardsController.claimAllRewardsToSelf(\n      assets\n    );\n  }\n\n  // @dev user can only borrow underlying in variable or stable, not both\n  function borrowed(address underlying, address account)\n    public\n    view\n    returns (uint)\n  {\n    DataTypes.ReserveData memory rd = POOL.getReserveData(underlying);\n    uint vborrow = IERC20(rd.variableDebtTokenAddress).balanceOf(account);\n    uint sborrow = IERC20(rd.stableDebtTokenAddress).balanceOf(account);\n    return sborrow >= vborrow ? sborrow : vborrow;\n  }\n}\n"
    },
    "contracts/strategies/integrations/AaveModuleStorage.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveModuleStorage.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../vendor/aave/v3/IPool.sol\";\nimport {IPoolAddressesProvider} from \"../vendor/aave/v3/IPoolAddressesProvider.sol\";\nimport {IRewardsControllerIsh} from \"../vendor/aave/v3/IRewardsControllerIsh.sol\";\nimport {ICreditDelegationToken} from \"../vendor/aave/v3/ICreditDelegationToken.sol\";\n\nimport \"../vendor/aave/v3/IPriceOracleGetter.sol\";\nimport {ReserveConfiguration as RC} from \"../vendor/aave/v3/ReserveConfiguration.sol\";\n\nimport \"contracts/IMangrove.sol\";\n\nlibrary AaveV3ModuleStorage {\n  // address of the lendingPool\n  // struct Layout {\n  // }\n\n  // function get_storage() internal pure returns (Layout storage st) {\n  //   bytes32 storagePosition = keccak256(\n  //     \"Mangrove.AaveV3ModuleStorageLib.Layout\"\n  //   );\n  //   assembly {\n  //     st.slot := storagePosition\n  //   }\n  // }\n\n  function revertWithData(bytes memory retdata) internal pure {\n    if (retdata.length == 0) {\n      revert(\"AaveModuleStorage/revertNoReason\");\n    }\n    assembly {\n      revert(add(retdata, 32), mload(retdata))\n    }\n  }\n}\n"
    },
    "contracts/strategies/integrations/AaveModuleImplementation.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveModuleImplementation.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {AaveV3ModuleStorage as AMS, IRewardsControllerIsh, IPoolAddressesProvider, ICreditDelegationToken, IPool, IPriceOracleGetter, DataTypes, RC} from \"./AaveModuleStorage.sol\";\nimport {IERC20} from \"contracts/MgvLib.sol\";\nimport \"contracts/strategies/utils/TransferLib.sol\";\n\ncontract AaveV3ModuleImplementation {\n  IPool public immutable POOL;\n  IPriceOracleGetter public immutable ORACLE;\n\n  constructor(IPool pool, IPriceOracleGetter oracle) {\n    POOL = pool;\n    ORACLE = oracle;\n  }\n\n  // structs to avoir stack too deep in maxGettableUnderlying\n  struct Underlying {\n    uint ltv;\n    uint liquidationThreshold;\n    uint decimals;\n    uint price;\n  }\n\n  struct Account {\n    uint collateral;\n    uint debt;\n    uint borrowPower;\n    uint redeemPower;\n    uint ltv;\n    uint liquidationThreshold;\n    uint health;\n    uint balanceOfUnderlying;\n  }\n\n  function $maxGettableUnderlying(\n    address asset,\n    bool tryBorrow,\n    address onBehalf\n  ) public view returns (uint, uint) {\n    Underlying memory underlying; // asset parameters\n    Account memory account; // accound parameters\n    (\n      account.collateral,\n      account.debt,\n      account.borrowPower, // avgLtv * sumCollateralEth - sumDebtEth\n      account.liquidationThreshold,\n      account.ltv,\n      account.health // avgLiquidityThreshold * sumCollateralEth / sumDebtEth  -- should be less than 10**18\n    ) = POOL.getUserAccountData(onBehalf);\n    DataTypes.ReserveData memory reserveData = POOL.getReserveData(asset);\n    (\n      underlying.ltv, // collateral factor for lending\n      underlying.liquidationThreshold, // collateral factor for borrowing\n      ,\n      /*liquidationBonus*/\n      underlying.decimals,\n      /*reserveFactor*/\n      /*emode_category*/\n      ,\n\n    ) = RC.getParams(reserveData.configuration);\n    account.balanceOfUnderlying = IERC20(reserveData.aTokenAddress).balanceOf(\n      onBehalf\n    );\n\n    underlying.price = ORACLE.getAssetPrice(asset); // divided by 10**underlying.decimals\n\n    // account.redeemPower = account.liquidationThreshold * account.collateral - account.debt\n    account.redeemPower =\n      (account.liquidationThreshold * account.collateral) /\n      10**4 -\n      account.debt;\n    // max redeem capacity = account.redeemPower/ underlying.liquidationThreshold * underlying.price\n    // unless account doesn't have enough collateral in asset token (hence the min())\n\n    uint maxRedeemableUnderlying = (account.redeemPower * // in 10**underlying.decimals\n      10**(underlying.decimals) *\n      10**4) / (underlying.liquidationThreshold * underlying.price);\n\n    maxRedeemableUnderlying = (maxRedeemableUnderlying <\n      account.balanceOfUnderlying)\n      ? maxRedeemableUnderlying\n      : account.balanceOfUnderlying;\n\n    if (!tryBorrow) {\n      //gas saver\n      return (maxRedeemableUnderlying, 0);\n    }\n    // computing max borrow capacity on the premisses that maxRedeemableUnderlying has been redeemed.\n    // max borrow capacity = (account.borrowPower - (ltv*redeemed)) / underlying.ltv * underlying.price\n\n    uint borrowPowerImpactOfRedeemInUnderlying = (maxRedeemableUnderlying *\n      underlying.ltv) / 10**4;\n\n    uint borrowPowerInUnderlying = (account.borrowPower *\n      10**underlying.decimals) / underlying.price;\n\n    if (borrowPowerImpactOfRedeemInUnderlying > borrowPowerInUnderlying) {\n      // no more borrowPower left after max redeem operation\n      return (maxRedeemableUnderlying, 0);\n    }\n\n    // max borrow power in underlying after max redeem has been withdrawn\n    uint maxBorrowAfterRedeemInUnderlying = borrowPowerInUnderlying -\n      borrowPowerImpactOfRedeemInUnderlying;\n\n    return (maxRedeemableUnderlying, maxBorrowAfterRedeemInUnderlying);\n  }\n\n  function $repayThenDeposit(\n    uint interestRateMode,\n    uint referralCode,\n    IERC20 token,\n    address onBehalf,\n    uint amount\n  ) external {\n    // AAVE repay/deposit throws if amount == 0\n    if (amount == 0) {\n      return;\n    }\n    uint toMint = amount;\n    try\n      // there are several reasons a repay may fail:\n      // * trying to repay more than debt is OK provided debt is not 0 (AAVE throws is debt is 0)\n      // * repaying maxUint will not work when repaying on behalf !\n      // * cannot repay a borrow that has the same block stamp\n      POOL.repay(address(token), amount, interestRateMode, onBehalf)\n    returns (uint repaid) {\n      toMint -= repaid;\n      if (toMint == 0) {\n        return;\n      }\n    } catch {\n      /** Recovering from one of the above 3 cases */\n    }\n    POOL.supply(address(token), toMint, onBehalf, uint16(referralCode));\n  }\n\n  function $redeemThenBorrow(\n    uint interestRateMode,\n    uint referralCode,\n    IERC20 token,\n    address onBehalfOf,\n    uint amount,\n    bool strict,\n    address recipient\n  ) external returns (uint) {\n    (uint redeemable, uint borrowable_after_redeem) = $maxGettableUnderlying(\n      address(token),\n      true, // compute borrow power after redeem\n      onBehalfOf\n    );\n    if (strict) {\n      redeemable = (redeemable < amount) ? redeemable : amount;\n    }\n    // `this` contract must have the aToken to withdraw on AAVE\n    // there is no `withdraw` on behalf as of July 2022\n    require(\n      TransferLib.transferTokenFrom(\n        IERC20(POOL.getReserveData(address(token)).aTokenAddress),\n        onBehalfOf,\n        address(this),\n        redeemable\n      ),\n      \"AaveModule/redeemThenBorrow/aTknTransferFail\"\n    );\n    // redeemed tokens are direclty transfered to `recipient`\n    if (redeemable > 0) {\n      POOL.withdraw(address(token), redeemable, recipient);\n    }\n\n    if (redeemable >= amount || borrowable_after_redeem == 0) {\n      return redeemable;\n    } else {\n      amount -= redeemable;\n      // still missing liquidity to reach target amount\n      borrowable_after_redeem = borrowable_after_redeem > amount\n        ? amount\n        : borrowable_after_redeem;\n      POOL.borrow(\n        address(token),\n        borrowable_after_redeem,\n        interestRateMode,\n        uint16(referralCode),\n        onBehalfOf\n      );\n      // sending borrowed tokens to `recipient`\n      require(\n        TransferLib.transferToken(token, recipient, borrowable_after_redeem),\n        \"AaveModule/redeemThenBorrow/TknTransferFail\"\n      );\n      return redeemable + borrowable_after_redeem;\n    }\n  }\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n **/\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   **/\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   **/\n  event BackUnbacked(\n    address indexed reserve,\n    address indexed backer,\n    uint amount,\n    uint fee\n  );\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   **/\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(\n    address indexed reserve,\n    address indexed user,\n    address indexed to,\n    uint amount\n  );\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   **/\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint debtToCover,\n    uint liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint liquidityRate,\n    uint stableBorrowRate,\n    uint variableBorrowRate,\n    uint liquidityIndex,\n    uint variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   **/\n  event MintedToTreasury(address indexed reserve, uint amountMinted);\n\n  /**\n   * @dev Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function mintUnbacked(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   **/\n  function backUnbacked(\n    address asset,\n    uint amount,\n    uint fee\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function supply(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   **/\n  function supplyWithPermit(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint amount,\n    address to\n  ) external returns (uint);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    address onBehalfOf\n  ) external returns (uint);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   **/\n  function repayWithPermit(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    address onBehalfOf,\n    uint deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   **/\n  function repayWithATokens(\n    address asset,\n    uint amount,\n    uint interestRateMode\n  ) external returns (uint);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  function swapBorrowRateMode(address asset, uint interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n    external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint[] calldata amounts,\n    uint[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint totalCollateralBase,\n      uint totalDebtBase,\n      uint availableBorrowsBase,\n      uint currentLiquidationThreshold,\n      uint ltv,\n      uint healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    view\n    returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint amount,\n    uint balanceFromBefore,\n    uint balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   **/\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   **/\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   **/\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(\n    uint8 id,\n    DataTypes.EModeCategory memory config\n  ) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id)\n    external\n    view\n    returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   **/\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n **/\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(\n    bytes32 indexed id,\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   **/\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress)\n    external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   **/\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   **/\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   **/\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   **/\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   **/\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   **/\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   **/\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/IRewardsControllerIsh.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.10;\n\n/**\n * @title adapted from IRewardsController (AAVE V3 periphery contracts)\n * @author Aave\n * @notice Defines the basic interface for a Rewards Controller.\n */\ninterface IRewardsControllerIsh {\n  /**\n   * @dev Claims reward for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n   * @param assets List of assets to check eligible distributions before claiming rewards\n   * @param amount The amount of rewards to claim\n   * @param to The address that will be receiving the rewards\n   * @param reward The address of the reward token\n   * @return The amount of rewards claimed\n   **/\n  function claimRewards(\n    address[] calldata assets,\n    uint amount,\n    address to,\n    address reward\n  ) external returns (uint);\n\n  /**\n   * @dev Claims reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The\n   * caller must be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n   * @param assets The list of assets to check eligible distributions before claiming rewards\n   * @param amount The amount of rewards to claim\n   * @param user The address to check and claim rewards\n   * @param to The address that will be receiving the rewards\n   * @param reward The address of the reward token\n   * @return The amount of rewards claimed\n   **/\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint amount,\n    address user,\n    address to,\n    address reward\n  ) external returns (uint);\n\n  /**\n   * @dev Claims reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n   * @param assets The list of assets to check eligible distributions before claiming rewards\n   * @param amount The amount of rewards to claim\n   * @param reward The address of the reward token\n   * @return The amount of rewards claimed\n   **/\n  function claimRewardsToSelf(\n    address[] calldata assets,\n    uint amount,\n    address reward\n  ) external returns (uint);\n\n  /**\n   * @dev Claims all rewards for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n   * @param assets The list of assets to check eligible distributions before claiming rewards\n   * @param to The address that will be receiving the rewards\n   * @return rewardsList List of addresses of the reward tokens\n   * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardList\"\n   **/\n  function claimAllRewards(address[] calldata assets, address to)\n    external\n    returns (address[] memory rewardsList, uint[] memory claimedAmounts);\n\n  /**\n   * @dev Claims all rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The caller must\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n   * @param assets The list of assets to check eligible distributions before claiming rewards\n   * @param user The address to check and claim rewards\n   * @param to The address that will be receiving the rewards\n   * @return rewardsList List of addresses of the reward tokens\n   * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n   **/\n  function claimAllRewardsOnBehalf(\n    address[] calldata assets,\n    address user,\n    address to\n  )\n    external\n    returns (address[] memory rewardsList, uint[] memory claimedAmounts);\n\n  /**\n   * @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n   * @param assets The list of assets to check eligible distributions before claiming rewards\n   * @return rewardsList List of addresses of the reward tokens\n   * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n   **/\n  function claimAllRewardsToSelf(address[] calldata assets)\n    external\n    returns (address[] memory rewardsList, uint[] memory claimedAmounts);\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\n/**\n * @title ICreditDelegationToken\n * @author Aave\n * @notice Defines the basic interface for a token supporting credit delegation.\n **/\ninterface ICreditDelegationToken {\n  /**\n   * @dev Emitted on `approveDelegation` and `borrowAllowance\n   * @param fromUser The address of the delegator\n   * @param toUser The address of the delegatee\n   * @param asset The address of the delegated asset\n   * @param amount The amount being delegated\n   */\n  event BorrowAllowanceDelegated(\n    address indexed fromUser,\n    address indexed toUser,\n    address indexed asset,\n    uint amount\n  );\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token.\n   * Delegation will still respect the liquidation constraints (even if delegated, a\n   * delegatee cannot force a delegator HF to go below 1)\n   * @param delegatee The address receiving the delegated borrowing power\n   * @param amount The maximum amount being delegated.\n   **/\n  function approveDelegation(address delegatee, uint amount) external;\n\n  /**\n   * @notice Returns the borrow allowance of the user\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @return The current allowance of `toUser`\n   **/\n  function borrowAllowance(address fromUser, address toUser)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token via ERC712 signature\n   * @param delegator The delegator of the credit\n   * @param delegatee The delegatee that can use the credit\n   * @param value The amount to be delegated\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v The V signature param\n   * @param s The S signature param\n   * @param r The R signature param\n   */\n  function delegationWithSig(\n    address delegator,\n    address delegatee,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  // debtTokens are non transferable ERC20, adding this to get the borrow balance\n  function balanceOf(address account) external view returns (uint);\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n **/\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   **/\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   **/\n  function BASE_CURRENCY_UNIT() external view returns (uint);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint);\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {Errors} from \"./Errors.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint internal constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint internal constant IS_PAUSED_START_BIT_POSITION = 60;\n  uint internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n  uint internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n  /// @dev bit 63 reserved\n\n  uint internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n  uint internal constant BORROW_CAP_START_BIT_POSITION = 80;\n  uint internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n  uint internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n  uint internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n  uint internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n  uint internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n\n  uint internal constant MAX_VALID_LTV = 65535;\n  uint internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n  uint internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n  uint internal constant MAX_VALID_DECIMALS = 255;\n  uint internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n  uint internal constant MAX_VALID_BORROW_CAP = 68719476735;\n  uint internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n  uint internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n  uint internal constant MAX_VALID_EMODE_CATEGORY = 255;\n  uint internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n  uint internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n  uint public constant DEBT_CEILING_DECIMALS = 2;\n  uint16 public constant MAX_RESERVES_COUNT = 128;\n\n  /**\n   * @notice Sets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @param ltv The new ltv\n   **/\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint ltv)\n    internal\n    pure\n  {\n    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @notice Gets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @return The loan to value\n   **/\n  function getLtv(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @notice Sets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @param threshold The new liquidation threshold\n   **/\n  function setLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint threshold\n  ) internal pure {\n    require(\n      threshold <= MAX_VALID_LIQUIDATION_THRESHOLD,\n      Errors.INVALID_LIQ_THRESHOLD\n    );\n\n    self.data =\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation threshold\n   **/\n  function getLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint) {\n    return\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >>\n      LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @param bonus The new liquidation bonus\n   **/\n  function setLiquidationBonus(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint bonus\n  ) internal pure {\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n    self.data =\n      (self.data & LIQUIDATION_BONUS_MASK) |\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation bonus\n   **/\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~LIQUIDATION_BONUS_MASK) >>\n      LIQUIDATION_BONUS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @param decimals The decimals\n   **/\n  function setDecimals(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint decimals\n  ) internal pure {\n    require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n    self.data =\n      (self.data & DECIMALS_MASK) |\n      (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @return The decimals of the asset\n   **/\n  function getDecimals(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the active state of the reserve\n   * @param self The reserve configuration\n   * @param active The active state\n   **/\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & ACTIVE_MASK) |\n      (uint(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the active state of the reserve\n   * @param self The reserve configuration\n   * @return The active state\n   **/\n  function getActive(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~ACTIVE_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @param frozen The frozen state\n   **/\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & FROZEN_MASK) |\n      (uint(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @return The frozen state\n   **/\n  function getFrozen(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~FROZEN_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the paused state of the reserve\n   * @param self The reserve configuration\n   * @param paused The paused state\n   **/\n  function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & PAUSED_MASK) |\n      (uint(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the paused state of the reserve\n   * @param self The reserve configuration\n   * @return The paused state\n   **/\n  function getPaused(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~PAUSED_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n   * amount will be accumulated in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @param borrowable True if the asset is borrowable\n   **/\n  function setBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool borrowable\n  ) internal pure {\n    self.data =\n      (self.data & BORROWABLE_IN_ISOLATION_MASK) |\n      (uint(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowable in isolation flag for the reserve.\n   * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n   * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @return The borrowable in isolation flag\n   **/\n  function getBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @param siloed True if the asset is siloed\n   **/\n  function setSiloedBorrowing(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool siloed\n  ) internal pure {\n    self.data =\n      (self.data & SILOED_BORROWING_MASK) |\n      (uint(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @return The siloed borrowing flag\n   **/\n  function getSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~SILOED_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\n   **/\n  function setBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & BORROWING_MASK) |\n      (uint(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The borrowing state\n   **/\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables stable rate borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n   **/\n  function setStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & STABLE_BORROWING_MASK) |\n      (uint(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the stable rate borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The stable rate borrowing state\n   **/\n  function getStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @param reserveFactor The reserve factor\n   **/\n  function setReserveFactor(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint reserveFactor\n  ) internal pure {\n    require(\n      reserveFactor <= MAX_VALID_RESERVE_FACTOR,\n      Errors.INVALID_RESERVE_FACTOR\n    );\n\n    self.data =\n      (self.data & RESERVE_FACTOR_MASK) |\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @return The reserve factor\n   **/\n  function getReserveFactor(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @param borrowCap The borrow cap\n   **/\n  function setBorrowCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint borrowCap\n  ) internal pure {\n    require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n    self.data =\n      (self.data & BORROW_CAP_MASK) |\n      (borrowCap << BORROW_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @return The borrow cap\n   **/\n  function getBorrowCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @param supplyCap The supply cap\n   **/\n  function setSupplyCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint supplyCap\n  ) internal pure {\n    require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n    self.data =\n      (self.data & SUPPLY_CAP_MASK) |\n      (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @return The supply cap\n   **/\n  function getSupplyCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the debt ceiling in isolation mode for the asset\n   * @param self The reserve configuration\n   * @param ceiling The maximum debt ceiling for the asset\n   **/\n  function setDebtCeiling(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint ceiling\n  ) internal pure {\n    require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n    self.data =\n      (self.data & DEBT_CEILING_MASK) |\n      (ceiling << DEBT_CEILING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n   * @param self The reserve configuration\n   * @return The debt ceiling (0 = isolation mode disabled)\n   **/\n  function getDebtCeiling(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation protocol fee of the reserve\n   * @param self The reserve configuration\n   * @param liquidationProtocolFee The liquidation protocol fee\n   **/\n  function setLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint liquidationProtocolFee\n  ) internal pure {\n    require(\n      liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,\n      Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n    );\n\n    self.data =\n      (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |\n      (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the liquidation protocol fee\n   * @param self The reserve configuration\n   * @return The liquidation protocol fee\n   **/\n  function getLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint) {\n    return\n      (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >>\n      LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @param unbackedMintCap The unbacked mint cap\n   **/\n  function setUnbackedMintCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint unbackedMintCap\n  ) internal pure {\n    require(\n      unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP,\n      Errors.INVALID_UNBACKED_MINT_CAP\n    );\n\n    self.data =\n      (self.data & UNBACKED_MINT_CAP_MASK) |\n      (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @return The unbacked mint cap\n   **/\n  function getUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~UNBACKED_MINT_CAP_MASK) >>\n      UNBACKED_MINT_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the eMode asset category\n   * @param self The reserve configuration\n   * @param category The asset category when the user selects the eMode\n   **/\n  function setEModeCategory(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint category\n  ) internal pure {\n    require(\n      category <= MAX_VALID_EMODE_CATEGORY,\n      Errors.INVALID_EMODE_CATEGORY\n    );\n\n    self.data =\n      (self.data & EMODE_CATEGORY_MASK) |\n      (category << EMODE_CATEGORY_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the eMode asset category\n   * @param self The reserve configuration\n   * @return The eMode category for the asset\n   **/\n  function getEModeCategory(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint)\n  {\n    return\n      (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Gets the configuration flags of the reserve\n   * @param self The reserve configuration\n   * @return The state flag representing active\n   * @return The state flag representing frozen\n   * @return The state flag representing borrowing enabled\n   * @return The state flag representing stableRateBorrowing enabled\n   * @return The state flag representing paused\n   **/\n  function getFlags(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      bool,\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    uint dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) != 0,\n      (dataLocal & ~FROZEN_MASK) != 0,\n      (dataLocal & ~BORROWING_MASK) != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n      (dataLocal & ~PAUSED_MASK) != 0\n    );\n  }\n\n  /**\n   * @notice Gets the configuration parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing ltv\n   * @return The state param representing liquidation threshold\n   * @return The state param representing liquidation bonus\n   * @return The state param representing reserve decimals\n   * @return The state param representing reserve factor\n   * @return The state param representing eMode category\n   **/\n  function getParams(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      uint,\n      uint,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    uint dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\n        LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\n        LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,\n      (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n    );\n  }\n\n  /**\n   * @notice Gets the caps parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing borrow cap\n   * @return The state param representing supply cap.\n   **/\n  function getCaps(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint, uint)\n  {\n    uint dataLocal = self.data;\n\n    return (\n      (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n      (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n    );\n  }\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint currScaledVariableDebt;\n    uint nextScaledVariableDebt;\n    uint currPrincipalStableDebt;\n    uint currAvgStableBorrowRate;\n    uint currTotalStableDebt;\n    uint nextAvgStableBorrowRate;\n    uint nextTotalStableDebt;\n    uint currLiquidityIndex;\n    uint nextLiquidityIndex;\n    uint currVariableBorrowIndex;\n    uint nextVariableBorrowIndex;\n    uint currLiquidityRate;\n    uint currVariableBorrowRate;\n    uint reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint reservesCount;\n    uint debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint maxStableRateBorrowSizePercent;\n    uint reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint amount;\n    address to;\n    uint reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint amount;\n    uint balanceFromBefore;\n    uint balanceToBefore;\n    uint reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint[] amounts;\n    uint[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint flashLoanPremiumToProtocol;\n    uint flashLoanPremiumTotal;\n    uint maxStableRateBorrowSizePercent;\n    uint reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint amount;\n    bytes params;\n    uint16 referralCode;\n    uint flashLoanPremiumToProtocol;\n    uint flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint amount;\n    uint totalPremium;\n    uint flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint amount;\n    InterestRateMode interestRateMode;\n    uint maxStableLoanPercent;\n    uint reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint totalDebt;\n    uint healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint unbacked;\n    uint liquidityAdded;\n    uint liquidityTaken;\n    uint totalStableDebt;\n    uint totalVariableDebt;\n    uint averageStableBorrowRate;\n    uint reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "contracts/strategies/vendor/aave/v3/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_ADMIN = \"1\"; // 'The caller of the function is not a pool admin'\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = \"2\"; // 'The caller of the function is not an emergency admin'\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = \"3\"; // 'The caller of the function is not a pool or emergency admin'\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = \"4\"; // 'The caller of the function is not a risk or pool admin'\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = \"5\"; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant CALLER_NOT_BRIDGE = \"6\"; // 'The caller of the function is not a bridge'\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = \"7\"; // 'Pool addresses provider is not registered'\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = \"8\"; // 'Invalid id for the pool addresses provider'\n  string public constant NOT_CONTRACT = \"9\"; // 'Address is not a contract'\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = \"10\"; // 'The caller of the function is not the pool configurator'\n  string public constant CALLER_NOT_ATOKEN = \"11\"; // 'The caller of the function is not an AToken'\n  string public constant INVALID_ADDRESSES_PROVIDER = \"12\"; // 'The address of the pool addresses provider is invalid'\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = \"13\"; // 'Invalid return value of the flashloan executor function'\n  string public constant RESERVE_ALREADY_ADDED = \"14\"; // 'Reserve has already been added to reserve list'\n  string public constant NO_MORE_RESERVES_ALLOWED = \"15\"; // 'Maximum amount of reserves in the pool reached'\n  string public constant EMODE_CATEGORY_RESERVED = \"16\"; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = \"17\"; // 'Invalid eMode category assignment to asset'\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = \"18\"; // 'The liquidity of the reserve needs to be 0'\n  string public constant FLASHLOAN_PREMIUM_INVALID = \"19\"; // 'Invalid flashloan premium'\n  string public constant INVALID_RESERVE_PARAMS = \"20\"; // 'Invalid risk parameters for the reserve'\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = \"21\"; // 'Invalid risk parameters for the eMode category'\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = \"22\"; // 'Invalid bridge protocol fee'\n  string public constant CALLER_MUST_BE_POOL = \"23\"; // 'The caller of this function must be a pool'\n  string public constant INVALID_MINT_AMOUNT = \"24\"; // 'Invalid amount to mint'\n  string public constant INVALID_BURN_AMOUNT = \"25\"; // 'Invalid amount to burn'\n  string public constant INVALID_AMOUNT = \"26\"; // 'Amount must be greater than 0'\n  string public constant RESERVE_INACTIVE = \"27\"; // 'Action requires an active reserve'\n  string public constant RESERVE_FROZEN = \"28\"; // 'Action cannot be performed because the reserve is frozen'\n  string public constant RESERVE_PAUSED = \"29\"; // 'Action cannot be performed because the reserve is paused'\n  string public constant BORROWING_NOT_ENABLED = \"30\"; // 'Borrowing is not enabled'\n  string public constant STABLE_BORROWING_NOT_ENABLED = \"31\"; // 'Stable borrowing is not enabled'\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = \"32\"; // 'User cannot withdraw more than the available balance'\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = \"33\"; // 'Invalid interest rate mode selected'\n  string public constant COLLATERAL_BALANCE_IS_ZERO = \"34\"; // 'The collateral balance is 0'\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \"35\"; // 'Health factor is lesser than the liquidation threshold'\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = \"36\"; // 'There is not enough collateral to cover a new borrow'\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = \"37\"; // 'Collateral is (mostly) the same currency that is being borrowed'\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \"38\"; // 'The requested amount is greater than the max loan size in stable rate mode'\n  string public constant NO_DEBT_OF_SELECTED_TYPE = \"39\"; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \"40\"; // 'To repay on behalf of a user an explicit amount to repay is needed'\n  string public constant NO_OUTSTANDING_STABLE_DEBT = \"41\"; // 'User does not have outstanding stable rate debt on this reserve'\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = \"42\"; // 'User does not have outstanding variable rate debt on this reserve'\n  string public constant UNDERLYING_BALANCE_ZERO = \"43\"; // 'The underlying balance needs to be greater than 0'\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \"44\"; // 'Interest rate rebalance conditions were not met'\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \"45\"; // 'Health factor is not below the threshold'\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = \"46\"; // 'The collateral chosen cannot be liquidated'\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \"47\"; // 'User did not borrow the specified currency'\n  string public constant SAME_BLOCK_BORROW_REPAY = \"48\"; // 'Borrow and repay in same block is not allowed'\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = \"49\"; // 'Inconsistent flashloan parameters'\n  string public constant BORROW_CAP_EXCEEDED = \"50\"; // 'Borrow cap is exceeded'\n  string public constant SUPPLY_CAP_EXCEEDED = \"51\"; // 'Supply cap is exceeded'\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = \"52\"; // 'Unbacked mint cap is exceeded'\n  string public constant DEBT_CEILING_EXCEEDED = \"53\"; // 'Debt ceiling is exceeded'\n  string public constant ATOKEN_SUPPLY_NOT_ZERO = \"54\"; // 'AToken supply is not zero'\n  string public constant STABLE_DEBT_NOT_ZERO = \"55\"; // 'Stable debt supply is not zero'\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = \"56\"; // 'Variable debt supply is not zero'\n  string public constant LTV_VALIDATION_FAILED = \"57\"; // 'Ltv validation failed'\n  string public constant INCONSISTENT_EMODE_CATEGORY = \"58\"; // 'Inconsistent eMode category'\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = \"59\"; // 'Price oracle sentinel validation failed'\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = \"60\"; // 'Asset is not borrowable in isolation mode'\n  string public constant RESERVE_ALREADY_INITIALIZED = \"61\"; // 'Reserve has already been initialized'\n  string public constant USER_IN_ISOLATION_MODE = \"62\"; // 'User is in isolation mode'\n  string public constant INVALID_LTV = \"63\"; // 'Invalid ltv parameter for the reserve'\n  string public constant INVALID_LIQ_THRESHOLD = \"64\"; // 'Invalid liquidity threshold parameter for the reserve'\n  string public constant INVALID_LIQ_BONUS = \"65\"; // 'Invalid liquidity bonus parameter for the reserve'\n  string public constant INVALID_DECIMALS = \"66\"; // 'Invalid decimals parameter of the underlying asset of the reserve'\n  string public constant INVALID_RESERVE_FACTOR = \"67\"; // 'Invalid reserve factor parameter for the reserve'\n  string public constant INVALID_BORROW_CAP = \"68\"; // 'Invalid borrow cap for the reserve'\n  string public constant INVALID_SUPPLY_CAP = \"69\"; // 'Invalid supply cap for the reserve'\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = \"70\"; // 'Invalid liquidation protocol fee for the reserve'\n  string public constant INVALID_EMODE_CATEGORY = \"71\"; // 'Invalid eMode category for the reserve'\n  string public constant INVALID_UNBACKED_MINT_CAP = \"72\"; // 'Invalid unbacked mint cap for the reserve'\n  string public constant INVALID_DEBT_CEILING = \"73\"; // 'Invalid debt ceiling for the reserve\n  string public constant INVALID_RESERVE_INDEX = \"74\"; // 'Invalid reserve index'\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = \"75\"; // 'ACL admin cannot be set to the zero address'\n  string public constant INCONSISTENT_PARAMS_LENGTH = \"76\"; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = \"77\"; // 'Zero address not valid'\n  string public constant INVALID_EXPIRATION = \"78\"; // 'Invalid expiration'\n  string public constant INVALID_SIGNATURE = \"79\"; // 'Invalid signature'\n  string public constant OPERATION_NOT_SUPPORTED = \"80\"; // 'Operation not supported'\n  string public constant DEBT_CEILING_NOT_ZERO = \"81\"; // 'Debt ceiling is not zero'\n  string public constant ASSET_NOT_LISTED = \"82\"; // 'Asset is not listed'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = \"83\"; // 'Invalid optimal usage ratio'\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = \"84\"; // 'Invalid optimal stable to total debt ratio'\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = \"85\"; // 'The underlying asset cannot be rescued'\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = \"86\"; // 'Reserve has already been added to reserve list'\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = \"87\"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n  string public constant STABLE_BORROWING_ENABLED = \"88\"; // 'Stable borrowing is enabled'\n  string public constant SILOED_BORROWING_VIOLATION = \"89\"; // 'User is trying to borrow multiple assets including a siloed one'\n  string public constant RESERVE_DEBT_NOT_ZERO = \"90\"; // the total debt of the reserve needs to be 0\n}\n"
    },
    "contracts/toy_strategies/multi_user/OfferProxy.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/multi_user/abstract/Persistent.sol\";\nimport \"contracts/strategies/routers/AaveDeepRouter.sol\";\n\ncontract OfferProxy is MultiUserPersistent {\n  constructor(\n    address _addressesProvider,\n    IMangrove _MGV,\n    address deployer\n  )\n    MultiUserPersistent(\n      _MGV,\n      new AaveDeepRouter(_addressesProvider, 0, 2),\n      50_000\n    )\n  {\n    router().setAdmin(deployer);\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n    }\n  }\n\n  function aaveRouter() internal view returns (AaveDeepRouter) {\n    return AaveDeepRouter(address(router()));\n  }\n\n  function __activate__(IERC20 token) internal virtual override {\n    aaveRouter().approveLender(token);\n    super.__activate__(token);\n  }\n\n  function checkList(IERC20 token, uint amount) external view returns (bool) {\n    AaveDeepRouter aaveDR = aaveRouter();\n\n    // checks that `this` contract is active\n    require(token.allowance(address(this), address(MGV)) == type(uint).max, \"OfferProxy/MangroveNotApprovedByContract\");\n    require(token.allowance(address(this), address(aaveDR)) == type(uint).max, \"OfferProxy/RouterNotApprovedByContract\");\n\n    // checks that router can supply and repay on behalf of user\n    require(token.allowance(msg.sender, address(aaveDR.POOL())) >= amount, \"OfferProxy/PoolNotApprovedByMaker\");\n\n    // checks that router can borrow on behalf of user\n    ICreditDelegationToken dTkn = aaveDR.debtToken(token);\n    require(dTkn.borrowAllowance(msg.sender, address(aaveDR)) >= amount, \"OfferProxy/RouterNotDelegatedByMaker\"); \n    return true;\n  }\n}\n"
    },
    "contracts/strategies/multi_user/abstract/Persistent.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Persistent.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./MultiUser.sol\";\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nabstract contract MultiUserPersistent is MultiUser {\n  constructor(\n    IMangrove _mgv,\n    AbstractRouter _router,\n    uint gasreq\n  ) MultiUser(_mgv, _router, gasreq) {}\n\n  function __residualWants__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.wants() - order.gives;\n  }\n\n  function __residualGives__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    returns (uint)\n  {\n    return order.offer.gives() - order.wants;\n  }\n\n  ///@dev posthook takes care of reposting offer residual\n  ///@param order is a reminder of the taker order that was processed during `makerExecute`\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool)\n  {\n    uint new_gives = __residualGives__(order);\n    uint new_wants = __residualWants__(order);\n    if (new_gives == 0) {\n      // gas saving\n      return true;\n    }\n    // if updateOffer fails offer will be retracted\n    return\n      updateOfferInternal(\n        MakerOrder({\n          outbound_tkn: IERC20(order.outbound_tkn),\n          inbound_tkn: IERC20(order.inbound_tkn),\n          wants: new_wants,\n          gives: new_gives,\n          gasreq: order.offerDetail.gasreq(), // keeping the same gasreq\n          gasprice: order.offerDetail.gasprice(), // keeping the same gasprice\n          pivotId: order.offer.next(), // best guess for pivotId\n          offerId: order.offerId\n        }),\n        0 // no value\n      );\n  }\n}\n"
    },
    "contracts/strategies/multi_user/abstract/MultiUser.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangroveOffer.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../../MangroveOffer.sol\";\nimport \"contracts/periphery/MgvReader.sol\";\nimport \"contracts/strategies/interfaces/IOfferLogicMulti.sol\";\n\nabstract contract MultiUser is IOfferLogicMulti, MangroveOffer {\n  struct OfferData {\n    // offer owner address\n    address owner;\n    // under approx of the portion of this contract's balance on mangrove\n    // that can be returned to the user's reserve when this offer is deprovisioned\n    uint96 wei_balance;\n  }\n\n  ///@dev outbound_tkn => inbound_tkn => offerId => OfferData\n  mapping(IERC20 => mapping(IERC20 => mapping(uint => OfferData)))\n    internal offerData;\n\n  constructor(\n    IMangrove _mgv,\n    AbstractRouter _router,\n    uint strat_gasreq\n  ) MangroveOffer(_mgv, strat_gasreq) {\n    require(address(_router) != address(0), \"MultiUser/0xRouter\");\n    // define `_router` as the liquidity router for `this` and declare that `this` is allowed to call router.\n    // NB router also needs to be approved for outbound/inbound token transfers by each user of this contract.\n    set_router(_router);\n  }\n\n  /// @param offerIds an array of offer ids from the `outbound_tkn, inbound_tkn` offer list\n  /// @return _offerOwners an array of the same length where the address at position i is the owner of `offerIds[i]`\n  function offerOwners(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint[] calldata offerIds\n  ) public view override returns (address[] memory _offerOwners) {\n    _offerOwners = new address[](offerIds.length);\n    for (uint i = 0; i < offerIds.length; i++) {\n      _offerOwners[i] = ownerOf(outbound_tkn, inbound_tkn, offerIds[i]);\n    }\n  }\n\n  /// @notice assigns an `owner` to `offerId`  on the `(outbound_tkn, inbound_tkn)` offer list\n  function addOwner(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId,\n    address owner\n  ) internal {\n    offerData[outbound_tkn][inbound_tkn][offerId] = OfferData({\n      owner: owner,\n      wei_balance: uint96(0)\n    });\n    emit NewOwnedOffer(MGV, outbound_tkn, inbound_tkn, offerId, owner);\n  }\n\n  /// @param gasreq the gas required by the offer\n  /// @param provision the amount of native token one is using to provision the offer\n  /// @return gasprice that the `provision` can cover for\n  /// @dev the returned gasprice is slightly lower than the real gasprice that the provision can cover because of the rouding error due to division\n  function derive_gasprice(\n    uint gasreq,\n    uint provision,\n    uint offer_gasbase\n  ) internal pure returns (uint gasprice) {\n    uint num = (offer_gasbase + gasreq) * 10**9;\n    // pre-check to avoir underflow\n    require(provision >= num, \"MultiUser/derive_gasprice/NotEnoughProvision\");\n    unchecked {\n      gasprice = provision / num;\n    }\n  }\n\n  function ownerOf(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId\n  ) public view override returns (address owner) {\n    owner = offerData[outbound_tkn][inbound_tkn][offerId].owner;\n    require(owner != address(0), \"multiUser/unkownOffer\");\n  }\n\n  // splitting newOffer into external/internal in order to let internal calls specify who the owner of the newly created offer should be.\n  // in case `newOffer` is being called during `makerExecute` or `posthook` calls.\n  function newOffer(MakerOrder calldata mko)\n    external\n    payable\n    override\n    returns (uint offerId)\n  {\n    offerId = newOfferInternal(mko, msg.sender, msg.value);\n  }\n\n  function newOfferInternal(\n    MakerOrder memory mko,\n    address owner,\n    uint provision\n  ) internal returns (uint) {\n    (P.Global.t global, P.Local.t local) = MGV.config(\n      address(mko.outbound_tkn),\n      address(mko.inbound_tkn)\n    );\n    // convention for default gasreq value\n    mko.gasreq = (mko.gasreq > type(uint24).max) ? ofr_gasreq() : mko.gasreq;\n    // computing gasprice implied by offer provision\n    mko.gasprice = derive_gasprice(\n      mko.gasreq,\n      provision,\n      local.offer_gasbase()\n    );\n    // mangrove will take max(`mko.gasprice`, `global.gasprice`)\n    // if `mko.gapsrice < global.gasprice` Mangrove will use availble provision of this contract to provision the offer\n    // this would potentially take native tokens that have been released after some offer managed by this contract have failed\n    // so one needs to make sure here that only provision of this call will be used to provision the offer on mangrove\n    require(\n      mko.gasprice >= global.gasprice(),\n      \"MultiUser/newOffer/NotEnoughProvision\"\n    );\n\n    // this call cannot revert for lack of provision (by design)\n    mko.offerId = MGV.newOffer{value: provision}(\n      $(mko.outbound_tkn),\n      $(mko.inbound_tkn),\n      mko.wants,\n      mko.gives,\n      mko.gasreq,\n      mko.gasprice,\n      mko.pivotId\n    );\n    //setting owner of offerId\n    addOwner(mko.outbound_tkn, mko.inbound_tkn, mko.offerId, owner);\n    return mko.offerId;\n  }\n\n  ///@notice update offer with parameters given in `mko`.\n  ///@dev mko.gasreq == max_int indicates one wishes to use ofr_gasreq (default value)\n  ///@dev mko.gasprice is overriden by the value computed by taking into account :\n  /// * value transfered on current tx\n  /// * if offer was deprovisioned after a fail, amount of wei (still on this contract balance on Mangrove) that should be counted as offer owner's\n  /// * if offer is still live, its current locked provision\n  function updateOffer(MakerOrder calldata mko) external payable {\n    require(updateOfferInternal(mko, msg.value), \"MultiUser/updateOfferFail\");\n  }\n\n  // mko.gasprice is ignored (should be 0) because it needs to be derived from provision of the offer\n  // not doing this would allow a user to submit an `new/updateOffer` underprovisioned for the announced gasprice\n  // Mangrove would then erroneously take missing WEIs in `this` contract free balance (possibly coming from uncollected deprovisioned offers after a fail).\n  // need to treat 2 cases:\n  // * if offer is deprovisioned one needs to use msg.value and `offerData.wei_balance` to derive gasprice (deprovioning sets offer.gasprice to 0)\n  // * if offer is still live one should compute its currenlty locked provision $P$ and derive gasprice based on msg.value + $P$ (note if msg.value = 0 offer can be reposted with offer.gasprice)\n\n  struct UpdateData {\n    P.Global.t global;\n    P.Local.t local;\n    P.OfferDetail.t offer_detail;\n    uint provision;\n  }\n\n  function updateOfferInternal(MakerOrder memory mko, uint value)\n    internal\n    returns (bool)\n  {\n    OfferData memory od = offerData[mko.outbound_tkn][mko.inbound_tkn][\n      mko.offerId\n    ];\n    UpdateData memory upd;\n    require(\n      msg.sender == od.owner || msg.sender == address(MGV),\n      \"Multi/updateOffer/unauthorized\"\n    );\n\n    upd.offer_detail = MGV.offerDetails(\n      $(mko.outbound_tkn),\n      $(mko.inbound_tkn),\n      mko.offerId\n    );\n    (upd.global, upd.local) = MGV.config(\n      $(mko.outbound_tkn),\n      $(mko.inbound_tkn)\n    );\n    upd.provision = value;\n    // if `od.free_wei` > 0 then `this` contract has a free wei balance >= `od.free_wei`.\n    // Gasprice must take this into account because Mangrove will pull into available WEIs if gasprice requires it.\n    mko.gasreq = (mko.gasreq > type(uint24).max) ? ofr_gasreq() : mko.gasreq;\n    mko.gasprice = upd.offer_detail.gasprice(); // 0 if offer is deprovisioned\n\n    if (mko.gasprice == 0) {\n      // offer was previously deprovisioned, we add the portion of this contract WEI pool on Mangrove that belongs to this offer (if any)\n      if (od.wei_balance > 0) {\n        upd.provision += od.wei_balance;\n        offerData[mko.outbound_tkn][mko.inbound_tkn][mko.offerId] = OfferData({\n          owner: od.owner,\n          wei_balance: 0\n        });\n      }\n      // gasprice for this offer will be computed using msg.value and available funds on Mangrove attributed to `offerId`'s owner\n      mko.gasprice = derive_gasprice(\n        mko.gasreq,\n        upd.provision,\n        upd.local.offer_gasbase()\n      );\n    } else {\n      // offer is still provisioned as offer.gasprice requires\n      if (value > 0) {\n        // caller wishes to add provision to existing provision\n        // we retrieve current offer provision based on upd.gasprice (which is current offer gasprice)\n        upd.provision +=\n          mko.gasprice *\n          10**9 *\n          (upd.offer_detail.gasreq() + upd.local.offer_gasbase());\n        mko.gasprice = derive_gasprice(\n          mko.gasreq,\n          upd.provision,\n          upd.local.offer_gasbase()\n        );\n      }\n      // if value == 0  we keep upd.gasprice unchanged\n    }\n    require(\n      mko.gasprice >= upd.global.gasprice(),\n      \"MultiUser/updateOffer/NotEnoughProvision\"\n    );\n    try\n      MGV.updateOffer{value: value}(\n        $(mko.outbound_tkn),\n        $(mko.inbound_tkn),\n        mko.wants,\n        mko.gives,\n        mko.gasreq,\n        mko.gasprice,\n        mko.pivotId,\n        mko.offerId\n      )\n    {\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  // Retracts `offerId` from the (`outbound_tkn`,`inbound_tkn`) Offer list of Mangrove. Function call will throw if `this` contract is not the owner of `offerId`.\n  ///@param deprovision is true if offer owner wishes to have the offer's provision pushed to its reserve\n  function retractOffer(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId,\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\n  ) public override returns (uint free_wei) {\n    OfferData memory od = offerData[outbound_tkn][inbound_tkn][offerId];\n    require(\n      od.owner == msg.sender || address(MGV) == msg.sender,\n      \"Multi/retractOffer/unauthorized\"\n    );\n    if (od.wei_balance > 0) {\n      // offer was already retracted and deprovisioned by Mangrove after a trade failure\n      // wei_balance is part of this contract's pooled free wei and can be redeemed by offer owner\n      free_wei = deprovision ? od.wei_balance : 0;\n    } else {\n      free_wei = MGV.retractOffer(\n        $(outbound_tkn),\n        $(inbound_tkn),\n        offerId,\n        deprovision\n      );\n    }\n    if (free_wei > 0) {\n      // pulling free wei from Mangrove to `this`\n      require(MGV.withdraw(free_wei), \"MultiUser/withdrawFail\");\n      // resetting pending returned provision\n      offerData[outbound_tkn][inbound_tkn][offerId] = OfferData({\n        owner: od.owner,\n        wei_balance: 0\n      });\n      // letting router decide what it should do with owner's free wei\n      (bool noRevert, ) = msg.sender.call{value: free_wei}(\"\");\n      require(noRevert, \"MultiUser/weiTransferFail\");\n    }\n  }\n\n  // NB anyone can call but msg.sender will only be able to withdraw from its reserve\n  function withdrawToken(\n    IERC20 token,\n    address receiver,\n    uint amount\n  ) external override returns (bool success) {\n    require(receiver != address(0), \"MultiUser/withdrawToken/0xReceiver\");\n    return router().withdrawToken(token, msg.sender, receiver, amount);\n  }\n\n  function tokenBalance(IERC20 token) external view override returns (uint) {\n    return router().reserveBalance(token, msg.sender);\n  }\n\n  // put received inbound tokens on offer owner reserve\n  // if nothing is done at that stage then it could still be done in the posthook but it cannot be a flush\n  // since `this` contract balance would have the accumulated takers inbound tokens\n  // here we make sure nothing remains unassigned after a trade\n  function __put__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    IERC20 outTkn = IERC20(order.outbound_tkn);\n    IERC20 inTkn = IERC20(order.inbound_tkn);\n    address owner = ownerOf(outTkn, inTkn, order.offerId);\n    router().push(inTkn, owner, amount);\n    return 0;\n  }\n\n  // get outbound tokens from offer owner reserve\n  function __get__(uint amount, ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    IERC20 outTkn = IERC20(order.outbound_tkn);\n    IERC20 inTkn = IERC20(order.inbound_tkn);\n    address owner = ownerOf(outTkn, inTkn, order.offerId);\n    // telling router one is requiring `amount` of `outTkn` for `owner`.\n    // because `pull` is strict, `pulled <= amount` (cannot be greater)\n    // we do not check local balance here because multi user contracts do not keep more balance than what has been pulled\n    uint pulled = router().pull(outTkn, owner, amount, true);\n    return amount - pulled;\n  }\n\n  // if offer failed to execute or reneged Mangrove has deprovisioned it\n  // the wei balance of `this` contract on Mangrove is now positive\n  // this fallback returns an under approx of the provision that has been returned to this contract\n  // being under approx implies `this` contract might accumulate a small amount of wei over time\n  function __posthookFallback__(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) internal virtual override returns (bool success) {\n    result; // ssh\n    IERC20 outTkn = IERC20(order.outbound_tkn);\n    IERC20 inTkn = IERC20(order.inbound_tkn);\n    OfferData memory od = offerData[outTkn][inTkn][order.offerId];\n    // NB if several offers of `this` contract have failed during the market order, the balance of this contract on Mangrove will contain cumulated free provision\n\n    // computing an under approximation of returned provision because of this offer's failure\n    (P.Global.t global, P.Local.t local) = MGV.config(\n      order.outbound_tkn,\n      order.inbound_tkn\n    );\n    uint gaspriceInWei = global.gasprice() * 10**9;\n    uint provision = 10**9 *\n      order.offerDetail.gasprice() *\n      (order.offerDetail.gasreq() + order.offerDetail.offer_gasbase());\n\n    // gas estimate to complete posthook ~ 1500, putting 3000 to be overapproximating\n    uint approxBounty = (order.offerDetail.gasreq() -\n      gasleft() +\n      3000 +\n      local.offer_gasbase()) * gaspriceInWei;\n\n    uint approxReturnedProvision = approxBounty >= provision\n      ? 0\n      : provision - approxBounty;\n\n    // storing the portion of this contract's balance on Mangrove that should be attributed back to the failing offer's owner\n    // those free WEIs can be retrieved by offer owner, by calling `retractOffer` with the `deprovision` flag.\n    offerData[outTkn][inTkn][order.offerId] = OfferData({\n      owner: od.owner,\n      wei_balance: uint96(approxReturnedProvision) // previous wei_balance is always 0 here: if offer failed in the past, `updateOffer` did reuse it\n    });\n    success = true;\n  }\n}\n"
    },
    "contracts/periphery/MgvReader.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvReader.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, P} from \"../MgvLib.sol\";\n\ninterface MangroveLike {\n  function best(address, address) external view returns (uint);\n\n  function offers(\n    address,\n    address,\n    uint\n  ) external view returns (P.Offer.t);\n\n  function offerDetails(\n    address,\n    address,\n    uint\n  ) external view returns (P.OfferDetail.t);\n\n  function offerInfo(\n    address,\n    address,\n    uint\n  ) external view returns (P.OfferStruct memory, P.OfferDetailStruct memory);\n\n  function config(address, address)\n    external\n    view\n    returns (P.Global.t, P.Local.t);\n}\n\ncontract MgvReader {\n  MangroveLike immutable mgv;\n\n  constructor(address _mgv) {\n    mgv = MangroveLike(payable(_mgv));\n  }\n\n  /*\n   * Returns two uints.\n   *\n   * `startId` is the id of the best live offer with id equal or greater than\n   * `fromId`, 0 if there is no such offer.\n   *\n   * `length` is 0 if `startId == 0`. Other it is the number of live offers as good or worse than the offer with\n   * id `startId`.\n   */\n  function offerListEndPoints(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  ) public view returns (uint startId, uint length) {\n    unchecked {\n      if (fromId == 0) {\n        startId = mgv.best(outbound_tkn, inbound_tkn);\n      } else {\n        startId = mgv.offers(outbound_tkn, inbound_tkn, fromId).gives() > 0\n          ? fromId\n          : 0;\n      }\n\n      uint currentId = startId;\n\n      while (currentId != 0 && length < maxOffers) {\n        currentId = mgv.offers(outbound_tkn, inbound_tkn, currentId).next();\n        length = length + 1;\n      }\n\n      return (startId, length);\n    }\n  }\n\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in packed form. First number is id of next offer (0 is we're done). First array is ids, second is offers (as bytes32), third is offerDetails (as bytes32). Array will be of size `min(# of offers in out/in list, maxOffers)`.\n  function packedOfferList(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    public\n    view\n    returns (\n      uint,\n      uint[] memory,\n      P.Offer.t[] memory,\n      P.OfferDetail.t[] memory\n    )\n  {\n    unchecked {\n      (uint currentId, uint length) = offerListEndPoints(\n        outbound_tkn,\n        inbound_tkn,\n        fromId,\n        maxOffers\n      );\n\n      uint[] memory offerIds = new uint[](length);\n      P.Offer.t[] memory offers = new P.Offer.t[](length);\n      P.OfferDetail.t[] memory details = new P.OfferDetail.t[](length);\n\n      uint i = 0;\n\n      while (currentId != 0 && i < length) {\n        offerIds[i] = currentId;\n        offers[i] = mgv.offers(outbound_tkn, inbound_tkn, currentId);\n        details[i] = mgv.offerDetails(outbound_tkn, inbound_tkn, currentId);\n        currentId = offers[i].next();\n        i = i + 1;\n      }\n\n      return (currentId, offerIds, offers, details);\n    }\n  }\n\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in unpacked form. First number is id of next offer (0 if we're done). First array is ids, second is offers (as structs), third is offerDetails (as structs). Array will be of size `min(# of offers in out/in list, maxOffers)`.\n  function offerList(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    public\n    view\n    returns (\n      uint,\n      uint[] memory,\n      P.OfferStruct[] memory,\n      P.OfferDetailStruct[] memory\n    )\n  {\n    unchecked {\n      (uint currentId, uint length) = offerListEndPoints(\n        outbound_tkn,\n        inbound_tkn,\n        fromId,\n        maxOffers\n      );\n\n      uint[] memory offerIds = new uint[](length);\n      P.OfferStruct[] memory offers = new P.OfferStruct[](length);\n      P.OfferDetailStruct[] memory details = new P.OfferDetailStruct[](length);\n\n      uint i = 0;\n      while (currentId != 0 && i < length) {\n        offerIds[i] = currentId;\n        (offers[i], details[i]) = mgv.offerInfo(\n          outbound_tkn,\n          inbound_tkn,\n          currentId\n        );\n        currentId = offers[i].next;\n        i = i + 1;\n      }\n\n      return (currentId, offerIds, offers, details);\n    }\n  }\n\n  function getProvision(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint ofr_gasreq,\n    uint ofr_gasprice\n  ) external view returns (uint) {\n    unchecked {\n      (P.Global.t global, P.Local.t local) = mgv.config(\n        outbound_tkn,\n        inbound_tkn\n      );\n      uint _gp;\n      uint global_gasprice = global.gasprice();\n      if (global_gasprice > ofr_gasprice) {\n        _gp = global_gasprice;\n      } else {\n        _gp = ofr_gasprice;\n      }\n      return (ofr_gasreq + local.offer_gasbase()) * _gp * 10**9;\n    }\n  }\n}\n"
    },
    "contracts/strategies/interfaces/IOfferLogicMulti.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// IOfferLogicMulti.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"./IOfferLogic.sol\";\n\ninterface IOfferLogicMulti is IOfferLogic {\n  /** Multi offer specific Events */\n  // Offer management\n  event NewOwnedOffer(\n    IMangrove mangrove,\n    IERC20 indexed outbound_tkn,\n    IERC20 indexed inbound_tkn,\n    uint indexed offerId,\n    address owner\n  );\n\n  // user provision on Mangrove has increased\n  event CreditMgvUser(\n    IMangrove indexed mangrove,\n    address indexed user,\n    uint amount\n  );\n\n  // user provision on Mangrove has decreased\n  event DebitMgvUser(\n    IMangrove indexed mangrove,\n    address indexed user,\n    uint amount\n  );\n\n  function offerOwners(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint[] calldata offerIds\n  ) external view returns (address[] memory __offerOwners);\n\n  function ownerOf(\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId\n  ) external view returns (address owner);\n}\n"
    },
    "contracts/toy_strategies/multi_user/OasisLike.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/multi_user/abstract/Persistent.sol\";\nimport \"contracts/strategies/routers/SimpleRouter.sol\";\n\ncontract OasisLike is MultiUserPersistent {\n  constructor(IMangrove _MGV, address deployer)\n    MultiUserPersistent(_MGV, new SimpleRouter(), 30_000)\n  {\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n      router().setAdmin(deployer);\n    }\n  }\n}\n"
    },
    "contracts/strategies/routers/SimpleRouter.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//SimpleRouter.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/utils/AccessControlled.sol\";\nimport \"contracts/strategies/utils/TransferLib.sol\";\nimport \"./AbstractRouter.sol\";\n\ncontract SimpleRouter is AbstractRouter(50_000) {\n  // requires approval of `reserve`\n  function __pull__(\n    IERC20 token,\n    address reserve,\n    address maker,\n    uint amount,\n    bool strict\n  ) internal virtual override returns (uint pulled) {\n    strict; // this pull strategy is only strict\n    if (TransferLib.transferTokenFrom(token, reserve, maker, amount)) {\n      return amount;\n    } else {\n      return 0;\n    }\n  }\n\n  // requires approval of Maker\n  function __push__(\n    IERC20 token,\n    address reserve,\n    address maker,\n    uint amount\n  ) internal virtual override {\n    require(\n      TransferLib.transferTokenFrom(token, maker, reserve, amount),\n      \"SimpleRouter/push/transferFail\"\n    );\n  }\n\n  function __withdrawToken__(\n    IERC20 token,\n    address reserve,\n    address to,\n    uint amount\n  ) internal virtual override returns (bool) {\n    return TransferLib.transferTokenFrom(token, reserve, to, amount);\n  }\n\n  function reserveBalance(IERC20 token, address reserve)\n    external\n    view\n    override\n    returns (uint)\n  {\n    return token.balanceOf(reserve);\n  }\n}\n"
    },
    "contracts/toy_strategies/single_user/Reposting.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Reposting.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/single_user/abstract/Persistent.sol\";\nimport \"contracts/strategies/routers/SimpleRouter.sol\";\n\n/* Simply inherits Persistent and is deployable. No additional internal logic. */\ncontract Reposting is Persistent {\n  constructor(IMangrove _MGV, address deployer)\n    Persistent(_MGV, 50_000, new SimpleRouter())\n  {\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n      router().setAdmin(deployer);\n    }\n  }\n}\n"
    },
    "contracts/toy_strategies/single_user/cash_management/SimpleAaveRetail.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleAaveRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/single_user/abstract/Persistent.sol\";\nimport \"contracts/strategies/routers/AaveRouter.sol\";\n\ncontract SimpleAaveRetail is Persistent {\n  constructor(\n    IMangrove _mgv,\n    address _addressesProvider,\n    address deployer\n  ) Persistent(_mgv, 30_000, new AaveRouter(_addressesProvider, 0, 2)) {\n    // Router reserve is by default `router.address`\n    // use `set_reserve(addr)` to change this\n    router().setAdmin(deployer);\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n    }\n  }\n}\n"
    },
    "contracts/test/strategies/Guaave.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\nimport \"contracts/strategies/single_user/market_making/mango/Mango.sol\";\nimport \"contracts/strategies/routers/AaveRouter.sol\";\nimport \"contracts/test/lib/Fork.sol\";\n\n// note: this is a forking test\ncontract GuaaveTest is MangroveTest {\n  uint constant BASE0 = 0.34 ether;\n  uint constant BASE1 = 1000 * 10**6; //because usdc decimals?\n  uint constant NSLOTS = 20;\n  // price increase is delta/BASE_0\n  uint constant DELTA = 34 * 10**6; // because usdc decimals?\n\n  IERC20 weth;\n  IERC20 usdc;\n  address payable maker;\n  address payable taker;\n  Mango mgo;\n  AaveRouter router;\n\n  function setUp() public override {\n    Fork.setUp();\n\n    mgv = setupMangrove();\n    mgv.setVault($(mgv));\n\n    weth = IERC20(Fork.WETH);\n    usdc = IERC20(Fork.USDC);\n    options.defaultFee = 30;\n    setupMarket(weth, usdc);\n\n    weth.approve($(mgv), type(uint).max);\n    usdc.approve($(mgv), type(uint).max);\n\n    maker = freshAddress(\"maker\");\n    taker = freshAddress(\"taker\");\n    deal($(weth), taker, 50 ether + weth.balanceOf(taker), true);\n    deal($(usdc), taker, 100_000 * 10**6 + usdc.balanceOf(taker), true);\n\n    vm.startPrank(maker);\n    mgo = new Mango({\n      mgv: IMangrove($(mgv)), // TODO: remove IMangrove dependency?\n      base: weth,\n      quote: usdc,\n      base_0: 0.34 ether,\n      quote_0: 1000 * 10**6,\n      nslots: NSLOTS,\n      price_incr: DELTA,\n      deployer: maker // reserve address is maker's wallet\n    });\n    vm.stopPrank();\n  }\n\n  /* combine all tests wince they rely on non-zero state */\n  function test_all() public {\n    part_deploy_strat();\n    part_deploy_buffered_router();\n    part_initialize();\n    part_market_order_with_buffer();\n  }\n\n  function part_deploy_strat() public {}\n\n  function part_deploy_buffered_router() public {\n    // default router for Mango is `SimpleRouter` that uses `reserve` to pull and push liquidity\n    // here we want to use aave for (il)liquidity and store liquid overlying at reserve\n    // router will redeem and deposit funds that are mobilized during trade execution\n    vm.startPrank(maker);\n    router = new AaveRouter({\n      _addressesProvider: Fork.AAVE,\n      _referralCode: 0,\n      _interestRateMode: 1 // stable rate\n    });\n    // adding makerContract to allowed pullers of router's liquidity\n    router.bind($(mgo));\n\n    // liquidity router will pull funds from AAVE\n    mgo.set_router(router);\n    mgo.set_reserve($(router));\n\n    // computing necessary provision (which has changed because of new router GAS_OVERHEAD)\n    uint prov = mgo.getMissingProvision({\n      outbound_tkn: weth,\n      inbound_tkn: usdc,\n      gasreq: mgo.ofr_gasreq(),\n      gasprice: 0,\n      offerId: 0\n    });\n\n    vm.stopPrank();\n    mgv.fund{value: prov * (NSLOTS * 2)}($(mgo));\n    vm.startPrank(maker);\n    deal($(weth), $(mgo), 17 ether + weth.balanceOf($(mgo)), true);\n\n    // to mint awETH\n    router.approveLender(weth);\n    // to mint aUSDC\n    router.approveLender(usdc);\n    // to allow router to pull/push from Mango\n    mgo.approveRouter(weth);\n    mgo.approveRouter(usdc);\n\n    // putting ETH as collateral on AAVE\n    router.supply(\n      weth,\n      mgo.reserve(),\n      17 ether,\n      $(mgo) /* maker contract was funded above */\n    );\n    router.borrow(\n      usdc,\n      mgo.reserve(),\n      2000 * 10**6,\n      $(mgo) /* maker contract is buffer */\n    );\n    vm.stopPrank();\n\n    // TODO-foundry-merge: implement logLenderStatus in solidity\n  }\n\n  function part_initialize() public {\n    vm.startPrank(maker);\n    init(1000 * 10**6, 0.3 ether);\n    vm.stopPrank();\n    // note: js tests would log the usdc/weth and weth/usdc OBs at this point\n  }\n\n  function part_market_order_with_buffer() public {\n    IERC20 aweth = IERC20(Fork.AWETH);\n    uint takerWants = 3 ether;\n    vm.startPrank(taker);\n    weth.approve($(mgv), type(uint).max);\n    usdc.approve($(mgv), type(uint).max);\n    uint awETHBalance = aweth.balanceOf($(router));\n    // if we don't move timestamp forward, final balance is 6 times lower than it should, not sure exactly why. theories: interest rate? aave borrow/repay blocker?\n    vm.warp(block.timestamp + 1);\n    mgv.marketOrder($(weth), $(usdc), takerWants, 100_000 * 10**6, true);\n    // note: js tests would logLenderStatus at this point\n    vm.stopPrank();\n    uint expected = awETHBalance - takerWants; //maker pays before Mangrove fees\n    uint actual = aweth.balanceOf($(router));\n    assertApproxEqAbs(expected, actual, 10**9, \"wrong final balance\");\n  }\n\n  // init procedure\n  // TODO explain\n  function init(uint bidAmount, uint askAmount) internal {\n    uint slice = 5;\n    uint[] memory pivotIds = new uint[](NSLOTS);\n    uint[] memory amounts = new uint[](NSLOTS);\n    for (uint i = 0; i < NSLOTS; i++) {\n      amounts[i] = i < NSLOTS / 2 ? bidAmount : askAmount;\n    }\n\n    for (uint i = 0; i < NSLOTS / slice; i++) {\n      mgo.initialize({\n        reset: true,\n        lastBidPosition: NSLOTS / 2 - 1, // stats asking at NSLOTS/2\n        from: slice * i,\n        to: slice * (i + 1),\n        pivotIds: [pivotIds, pivotIds],\n        tokenAmounts: amounts\n      });\n      // enable for more info\n      // console.log(string.concat(\"Offers \",uint2str(slice * i),\",\",uint2str(slice * (i + 1)),\" initialized\"));\n    }\n  }\n}\n"
    },
    "contracts/strategies/single_user/market_making/mango/Mango.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Mango.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./MangoStorage.sol\";\nimport \"./MangoImplementation.sol\";\nimport \"../../abstract/Persistent.sol\";\nimport \"../../../routers/AbstractRouter.sol\";\nimport \"../../../routers/SimpleRouter.sol\";\n\n/** Discrete automated market making strat */\n/** This AMM is headless (no price model) and market makes on `NSLOTS` price ranges*/\n/** current `Pmin` is the price of an offer at position `0`, current `Pmax` is the price of an offer at position `NSLOTS-1`*/\n/** Initially `Pmin = P(0) = QUOTE_0/BASE_0` and the general term is P(i) = __quote_progression__(i)/BASE_0 */\n/** NB `__quote_progression__` is a hook that defines how price increases with positions and is by default an arithmetic progression, i.e __quote_progression__(i) = QUOTE_0 + `delta`*i */\n/** When one of its offer is matched on Mangrove, the headless strat does the following: */\n/** Each time this strat receives b `BASE` tokens (bid was taken) at price position i, it increases the offered (`BASE`) volume of the ask at position i+1 of 'b'*/\n/** Each time this strat receives q `QUOTE` tokens (ask was taken) at price position i, it increases the offered (`QUOTE`) volume of the bid at position i-1 of 'q'*/\n/** In case of a partial fill of an offer at position i, the offer residual is reposted (see `Persistent` strat class)*/\n\ncontract Mango is Persistent {\n  // emitted when init function has been called and AMM becomes active\n  event Initialized(uint from, uint to);\n\n  address private immutable IMPLEMENTATION;\n\n  uint public immutable NSLOTS;\n  IERC20 public immutable BASE;\n  IERC20 public immutable QUOTE;\n\n  // Asks and bids offer Ids are stored in `ASKS` and `BIDS` arrays respectively.\n\n  constructor(\n    IMangrove mgv,\n    IERC20 base,\n    IERC20 quote,\n    uint base_0,\n    uint quote_0,\n    uint nslots,\n    uint price_incr,\n    address deployer\n  )\n    Persistent(\n      mgv,\n      250_000, // gas cost for trade execution (w/o taking routing specific gas cost)\n      new SimpleRouter() // routes liqudity from (to) reserve to (from) this contract\n    )\n  {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    // sanity check\n    require(\n      nslots > 0 &&\n        address(mgv) != address(0) &&\n        uint16(nslots) == nslots &&\n        uint96(base_0) == base_0 &&\n        uint96(quote_0) == quote_0,\n      \"Mango/constructor/invalidArguments\"\n    );\n\n    NSLOTS = nslots;\n\n    // implementation should have correct immutables\n    IMPLEMENTATION = address(\n      new MangoImplementation(\n        mgv,\n        base,\n        quote,\n        uint96(base_0),\n        uint96(quote_0),\n        nslots\n      )\n    );\n    BASE = base;\n    QUOTE = quote;\n    // setting local storage\n    mStr.asks = new uint[](nslots);\n    mStr.bids = new uint[](nslots);\n    mStr.delta = price_incr;\n    // logs `BID/ASKatMin/MaxPosition` events when only 1 slot remains\n    mStr.min_buffer = 1;\n\n    // activates Mango on `quote` and `base`\n    __activate__(base);\n    __activate__(quote);\n\n    // in order to let deployer's EOA have control over liquidity\n    set_reserve(deployer);\n\n    // `this` deployed the router, letting admin take control over it.\n    router().setAdmin(deployer);\n\n    // setting admin of contract if a static address deployment was used\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n    }\n  }\n\n  // populate mangrove order book with bids or/and asks in the price range R = [`from`, `to`[\n  // tokenAmounts are always expressed `gives`units, i.e in BASE when asking and in QUOTE when bidding\n  function initialize(\n    bool reset,\n    uint lastBidPosition, // if `lastBidPosition` is in R, then all offers before `lastBidPosition` (included) will be bids, offers strictly after will be asks.\n    uint from, // first price position to be populated\n    uint to, // last price position to be populated\n    uint[][2] calldata pivotIds, // `pivotIds[0][i]` ith pivots for bids, `pivotIds[1][i]` ith pivot for asks\n    uint[] calldata tokenAmounts // `tokenAmounts[i]` is the amount of `BASE` or `QUOTE` tokens (dePENDING on `withBase` flag) that is used to fixed one parameter of the price at position `from+i`.\n  ) public mgvOrAdmin {\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(\n      abi.encodeWithSelector(\n        MangoImplementation.$initialize.selector,\n        reset,\n        lastBidPosition,\n        from,\n        to,\n        pivotIds,\n        tokenAmounts\n      )\n    );\n    if (!success) {\n      MangoStorage.revertWithData(retdata);\n    } else {\n      emit Initialized({from: from, to: to});\n    }\n  }\n\n  function reset_pending() external onlyAdmin {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    mStr.pending_base = 0;\n    mStr.pending_quote = 0;\n  }\n\n  /** Setters and getters */\n  function delta() external view onlyAdmin returns (uint) {\n    return MangoStorage.get_storage().delta;\n  }\n\n  function set_delta(uint _delta) public mgvOrAdmin {\n    MangoStorage.get_storage().delta = _delta;\n  }\n\n  function shift() external view onlyAdmin returns (int) {\n    return MangoStorage.get_storage().shift;\n  }\n\n  function pending() external view onlyAdmin returns (uint[2] memory) {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    return [mStr.pending_base, mStr.pending_quote];\n  }\n\n  // with ba=0:bids only, ba=1: asks only ba>1 all\n  function retractOffers(\n    uint ba,\n    uint from,\n    uint to\n  ) external onlyAdmin returns (uint collected) {\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(\n      abi.encodeWithSelector(\n        MangoImplementation.$retractOffers.selector,\n        ba,\n        from,\n        to\n      )\n    );\n    if (!success) {\n      MangoStorage.revertWithData(retdata);\n    } else {\n      return abi.decode(retdata, (uint));\n    }\n  }\n\n  /** Shift the price (induced by quote amount) of n slots down or up */\n  /** price at position i will be shifted (up or down dePENDING on the sign of `shift`) */\n  /** New positions 0<= i < s are initialized with amount[i] in base tokens if `withBase`. In quote tokens otherwise*/\n  function set_shift(\n    int s,\n    bool withBase,\n    uint[] calldata amounts\n  ) public mgvOrAdmin {\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(\n      abi.encodeWithSelector(\n        MangoImplementation.$set_shift.selector,\n        s,\n        withBase,\n        amounts\n      )\n    );\n    if (!success) {\n      MangoStorage.revertWithData(retdata);\n    }\n  }\n\n  function set_min_offer_type(uint m) external mgvOrAdmin {\n    MangoStorage.get_storage().min_buffer = m;\n  }\n\n  function _staticdelegatecall(bytes calldata data)\n    external\n    onlyCaller(address(this))\n  {\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(data);\n    if (!success) {\n      MangoStorage.revertWithData(retdata);\n    }\n    assembly {\n      return(add(retdata, 32), returndatasize())\n    }\n  }\n\n  // return Mango offer Ids on Mangrove. If `liveOnly` will only return offer Ids that are live (0 otherwise).\n  function get_offers(bool liveOnly)\n    external\n    view\n    returns (uint[][2] memory offers)\n  {\n    (bool success, bytes memory retdata) = address(this).staticcall(\n      abi.encodeWithSelector(\n        this._staticdelegatecall.selector,\n        abi.encodeWithSelector(\n          MangoImplementation.$get_offers.selector,\n          liveOnly\n        )\n      )\n    );\n    if (!success) {\n      MangoStorage.revertWithData(retdata);\n    } else {\n      return abi.decode(retdata, (uint[][2]));\n    }\n  }\n\n  // starts reneging all offers\n  // NB reneged offers will not be reposted\n  function pause() public mgvOrAdmin {\n    MangoStorage.get_storage().paused = true;\n  }\n\n  function restart() external onlyAdmin {\n    MangoStorage.get_storage().paused = false;\n  }\n\n  function is_paused() external view returns (bool) {\n    return MangoStorage.get_storage().paused;\n  }\n\n  // this overrides is read during `makerExecute` call (see `MangroveOffer`)\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool proceed)\n  {\n    order; //shh\n    proceed = !MangoStorage.get_storage().paused;\n  }\n\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool)\n  {\n    (bool success, bytes memory retdata) = IMPLEMENTATION.delegatecall(\n      abi.encodeWithSelector(\n        MangoImplementation.$posthookSuccess.selector,\n        order\n      )\n    );\n    if (!success) {\n      MangoStorage.revertWithData(retdata);\n    } else {\n      return abi.decode(retdata, (bool));\n    }\n  }\n}\n"
    },
    "contracts/strategies/single_user/market_making/mango/MangoStorage.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangoStorage.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/routers/AbstractRouter.sol\";\n\nlibrary MangoStorage {\n  /** Strat specific events */\n\n  struct Layout {\n    uint[] asks;\n    uint[] bids;\n    // amount of base (resp quote) tokens that failed to be published on the Market\n    uint pending_base;\n    uint pending_quote;\n    // offerId -> index in ASKS/BIDS maps\n    mapping(uint => uint) index_of_bid; // bidId -> index\n    mapping(uint => uint) index_of_ask; // askId -> index\n    // Price shift is in number of price increments (or decrements when shift < 0) since deployment of the strat.\n    // e.g. for arithmetic progression, `shift = -3` indicates that Pmin is now (`QUOTE_0` - 3*`delta`)/`BASE_0`\n    int shift;\n    // parameter for price progression\n    // NB for arithmetic progression, price(i+1) = price(i) + delta/`BASE_0`\n    uint delta; // quote increment\n    // triggers `__boundariesReached__` whenever amounts of bids/asks is below `min_buffer`\n    uint min_buffer;\n    // puts the strat into a (cancellable) state where it reneges on all incoming taker orders.\n    // NB reneged offers are removed from Mangrove's OB\n    bool paused;\n    // Base and quote router contract\n    AbstractRouter router;\n    // reserve address for the router (external treasury -e.g EOA-, Mango or the router itself)\n    // if the router is lender based, this is the location of the overlying\n    address reserve;\n  }\n\n  function get_storage() internal pure returns (Layout storage st) {\n    bytes32 storagePosition = keccak256(\"Mangrove.MangoStorage.Layout\");\n    assembly {\n      st.slot := storagePosition\n    }\n  }\n\n  function revertWithData(bytes memory retdata) internal pure {\n    if (retdata.length == 0) {\n      revert(\"MangoStorage/revertNoReason\");\n    }\n    assembly {\n      revert(add(retdata, 32), mload(retdata))\n    }\n  }\n\n  function quote_price_jumps(\n    uint delta,\n    uint position,\n    uint quote_min\n  ) internal pure returns (uint) {\n    return delta * position + quote_min;\n  }\n}\n"
    },
    "contracts/strategies/single_user/market_making/mango/MangoImplementation.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangoImplementation.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"./MangoStorage.sol\";\nimport \"../../abstract/Persistent.sol\";\nimport \"contracts/strategies/utils/TransferLib.sol\";\n\n//import \"../Routers/AbstractRouter.sol\";\n\n/** Discrete automated market making strat */\n/** This AMM is headless (no price model) and market makes on `NSLOTS` price ranges*/\n/** current `Pmin` is the price of an offer at position `0`, current `Pmax` is the price of an offer at position `NSLOTS-1`*/\n/** Initially `Pmin = P(0) = QUOTE_0/BASE_0` and the general term is P(i) = __quote_progression__(i)/BASE_0 */\n/** NB `__quote_progression__` is a hook that defines how price increases with positions and is by default an arithmetic progression, i.e __quote_progression__(i) = QUOTE_0 + `delta`*i */\n/** When one of its offer is matched on Mangrove, the headless strat does the following: */\n/** Each time this strat receives b `BASE` tokens (bid was taken) at price position i, it increases the offered (`BASE`) volume of the ask at position i+1 of 'b'*/\n/** Each time this strat receives q `QUOTE` tokens (ask was taken) at price position i, it increases the offered (`QUOTE`) volume of the bid at position i-1 of 'q'*/\n/** In case of a partial fill of an offer at position i, the offer residual is reposted (see `Persistent` strat class)*/\n\ncontract MangoImplementation is Persistent {\n  event BidAtMaxPosition();\n  // emitted when strat has reached max amount of Asks and needs rebalancing (should shift of x<0 positions in order to have ask prices that are better for the taker)\n  event AskAtMinPosition();\n\n  modifier delegated() {\n    require(address(this) == PROXY, \"MangoImplementation/invalidCall\");\n    _;\n  }\n\n  // total number of Asks (resp. Bids)\n  uint immutable NSLOTS;\n  // initial min price given by `QUOTE_0/BASE_0`\n  uint96 immutable BASE_0;\n  uint96 immutable QUOTE_0;\n  // Market on which Mango will be acting\n  IERC20 immutable BASE;\n  IERC20 immutable QUOTE;\n\n  address immutable PROXY;\n\n  constructor(\n    IMangrove mgv,\n    IERC20 base,\n    IERC20 quote,\n    uint96 base_0,\n    uint96 quote_0,\n    uint nslots\n  )\n    Persistent(\n      mgv,\n      0,\n      AbstractRouter(address(0)) /* router*/\n    )\n  {\n    // setting immutable fields to match those of `Mango`\n    BASE = base;\n    QUOTE = quote;\n    NSLOTS = nslots;\n    BASE_0 = base_0;\n    QUOTE_0 = quote_0;\n    PROXY = msg.sender;\n  }\n\n  // populate mangrove order book with bids or/and asks in the price range R = [`from`, `to`[\n  // tokenAmounts are always expressed `gives`units, i.e in BASE when asking and in QUOTE when bidding\n  function $initialize(\n    bool reset,\n    uint lastBidPosition, // if `lastBidPosition` is in R, then all offers before `lastBidPosition` (included) will be bids, offers strictly after will be asks.\n    uint from, // first price position to be populated\n    uint to, // last price position to be populated\n    uint[][2] calldata pivotIds, // `pivotIds[0][i]` ith pivots for bids, `pivotIds[1][i]` ith pivot for asks\n    uint[] calldata tokenAmounts // `tokenAmounts[i]` is the amount of `BASE` or `QUOTE` tokens (dePENDING on `withBase` flag) that is used to fixed one parameter of the price at position `from+i`.\n  ) external delegated {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    // making sure a router has been defined between deployment and initialization\n    require(address(router()) != address(0), \"Mango/initialize/0xRouter\");\n    /** Initializing Asks and Bids */\n    /** NB we assume Mangrove is already provisioned for posting NSLOTS asks and NSLOTS bids*/\n    /** NB cannot post newOffer with infinite gasreq since fallback ofr_gasreq is not defined yet (and default is likely wrong) */\n    require(to > from, \"Mango/initialize/invalidSlice\");\n    require(\n      tokenAmounts.length == NSLOTS &&\n        pivotIds.length == 2 &&\n        pivotIds[0].length == NSLOTS &&\n        pivotIds[1].length == NSLOTS,\n      \"Mango/initialize/invalidArrayLength\"\n    );\n    require(lastBidPosition < NSLOTS - 1, \"Mango/initialize/NoSlotForAsks\"); // bidding => slice doesn't fill the book\n    uint pos;\n    for (pos = from; pos < to; pos++) {\n      // if shift is not 0, must convert\n      uint i = index_of_position(pos);\n\n      if (pos <= lastBidPosition) {\n        uint bidPivot = pivotIds[0][pos];\n        bidPivot = bidPivot > 0\n          ? bidPivot // taking pivot from the user\n          : pos > 0\n          ? mStr.bids[index_of_position(pos - 1)]\n          : 0; // otherwise getting last inserted offer as pivot\n        updateBid({\n          index: i,\n          reset: reset, // overwrites old value\n          amount: tokenAmounts[pos],\n          pivotId: bidPivot\n        });\n        if (mStr.asks[i] > 0) {\n          // if an ASK is also positioned, remove it to prevent spread crossing\n          // (should not happen if this is the first initialization of the strat)\n          retractOffer(BASE, QUOTE, mStr.asks[i], false);\n        }\n      } else {\n        uint askPivot = pivotIds[1][pos];\n        askPivot = askPivot > 0\n          ? askPivot // taking pivot from the user\n          : pos > 0\n          ? mStr.asks[index_of_position(pos - 1)]\n          : 0; // otherwise getting last inserted offer as pivot\n        updateAsk({\n          index: i,\n          reset: reset,\n          amount: tokenAmounts[pos],\n          pivotId: askPivot\n        });\n        if (mStr.bids[i] > 0) {\n          // if a BID is also positioned, remove it to prevent spread crossing\n          // (should not happen if this is the first initialization of the strat)\n          retractOffer(QUOTE, BASE, mStr.bids[i], false);\n        }\n      }\n    }\n  }\n\n  // with ba=0:bids only, ba=1: asks only ba>1 all\n  function $retractOffers(\n    uint ba,\n    uint from,\n    uint to\n  ) external delegated returns (uint collected) {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    for (uint i = from; i < to; i++) {\n      if (ba > 0) {\n        // asks or bids+asks\n        collected += mStr.asks[i] > 0\n          ? retractOffer(BASE, QUOTE, mStr.asks[i], true)\n          : 0;\n      }\n      if (ba == 0 || ba > 1) {\n        // bids or bids + asks\n        collected += mStr.bids[i] > 0\n          ? retractOffer(QUOTE, BASE, mStr.bids[i], true)\n          : 0;\n      }\n    }\n  }\n\n  /** Shift the price (induced by quote amount) of n slots down or up */\n  /** price at position i will be shifted (up or down dePENDING on the sign of `shift`) */\n  /** New positions 0<= i < s are initialized with amount[i] in base tokens if `withBase`. In quote tokens otherwise*/\n  function $set_shift(\n    int s,\n    bool withBase,\n    uint[] calldata amounts\n  ) external delegated {\n    require(\n      amounts.length == (s < 0 ? uint(-s) : uint(s)),\n      \"Mango/set_shift/notEnoughAmounts\"\n    );\n    if (s < 0) {\n      negative_shift(uint(-s), withBase, amounts);\n    } else {\n      positive_shift(uint(s), withBase, amounts);\n    }\n  }\n\n  // return Mango offer Ids on Mangrove. If `liveOnly` will only return offer Ids that are live (0 otherwise).\n  function $get_offers(bool liveOnly)\n    external\n    view\n    returns (uint[][2] memory offers)\n  {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    offers[0] = new uint[](NSLOTS);\n    offers[1] = new uint[](NSLOTS);\n    for (uint i = 0; i < NSLOTS; i++) {\n      uint askId = mStr.asks[index_of_position(i)];\n      uint bidId = mStr.bids[index_of_position(i)];\n\n      offers[0][i] = (MGV.offers($(QUOTE), $(BASE), bidId).gives() > 0 ||\n        !liveOnly)\n        ? mStr.bids[index_of_position(i)]\n        : 0;\n      offers[1][i] = (MGV.offers($(BASE), $(QUOTE), askId).gives() > 0 ||\n        !liveOnly)\n        ? mStr.asks[index_of_position(i)]\n        : 0;\n    }\n  }\n\n  // posts or updates ask at position of `index`\n  // returns the amount of `BASE` tokens that failed to be published at that position\n  // `writeOffer` is split into `writeAsk` and `writeBid` to avoid stack too deep exception\n  function writeAsk(\n    uint index,\n    uint wants,\n    uint gives,\n    uint pivotId\n  ) internal returns (uint) {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    if (mStr.asks[index] == 0) {\n      // offer slot not initialized yet\n      try\n        MGV.newOffer({\n          outbound_tkn: $(BASE),\n          inbound_tkn: $(QUOTE),\n          wants: wants,\n          gives: gives,\n          gasreq: ofr_gasreq(),\n          gasprice: 0,\n          pivotId: pivotId\n        })\n      returns (uint offerId) {\n        mStr.asks[index] = offerId;\n        mStr.index_of_ask[mStr.asks[index]] = index;\n        return 0;\n      } catch (bytes memory reason) {\n        // `newOffer` can fail when Mango is underprovisioned or if `offer.gives` is below density\n        if (keccak256(reason) == keccak256(\"mgv/insufficientProvision\")) {\n          emit LogIncident(MGV, BASE, QUOTE, 0, \"Mango/newAsk/outOfProvision\");\n        }\n        return gives;\n      }\n    } else {\n      try\n        MGV.updateOffer({\n          outbound_tkn: $(BASE),\n          inbound_tkn: $(QUOTE),\n          wants: wants,\n          gives: gives,\n          gasreq: ofr_gasreq(),\n          gasprice: 0,\n          pivotId: pivotId,\n          offerId: mStr.asks[index]\n        })\n      {\n        // updateOffer succeeded\n        return 0;\n      } catch (bytes memory reason) {\n        // update offer might fail because residual is below density (this is OK)\n        // it may also fail because there is not enough provision on Mangrove (this is Not OK so we log)\n        if (keccak256(reason) == keccak256(\"mgv/insufficientProvision\")) {\n          emit LogIncident(\n            MGV,\n            BASE,\n            QUOTE,\n            mStr.asks[index],\n            \"Mango/updateAsk/outOfProvision\"\n          );\n        }\n        // updateOffer failed but `offer` might still be live (i.e with `offer.gives>0`)\n        uint oldGives = MGV.offers($(BASE), $(QUOTE), mStr.asks[index]).gives();\n        // if not during initialize we necessarily have gives > oldGives\n        // otherwise we are trying to reset the offer and oldGives is irrelevant\n        return (gives > oldGives) ? gives - oldGives : gives;\n      }\n    }\n  }\n\n  function writeBid(\n    uint index,\n    uint wants,\n    uint gives,\n    uint pivotId\n  ) internal returns (uint) {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    if (mStr.bids[index] == 0) {\n      try\n        MGV.newOffer({\n          outbound_tkn: $(QUOTE),\n          inbound_tkn: $(BASE),\n          wants: wants,\n          gives: gives,\n          gasreq: ofr_gasreq(),\n          gasprice: 0,\n          pivotId: pivotId\n        })\n      returns (uint offerId) {\n        mStr.bids[index] = offerId;\n        mStr.index_of_bid[mStr.bids[index]] = index;\n        return 0;\n      } catch (bytes memory reason) {\n        if (keccak256(reason) == keccak256(\"mgv/insufficientProvision\")) {\n          emit LogIncident(MGV, QUOTE, BASE, 0, \"Mango/newBid/outOfProvision\");\n        }\n        return gives;\n      }\n    } else {\n      try\n        MGV.updateOffer({\n          outbound_tkn: $(QUOTE),\n          inbound_tkn: $(BASE),\n          wants: wants,\n          gives: gives,\n          gasreq: ofr_gasreq(),\n          gasprice: 0,\n          pivotId: pivotId,\n          offerId: mStr.bids[index]\n        })\n      {\n        return 0;\n      } catch (bytes memory reason) {\n        if (keccak256(reason) == keccak256(\"mgv/insufficientProvision\")) {\n          emit LogIncident(\n            MGV,\n            QUOTE,\n            BASE,\n            mStr.bids[index],\n            \"Mango/writeBid/updateOfferFail\"\n          );\n        }\n        // updateOffer failed but `offer` might still be live (i.e with `offer.gives>0`)\n        uint oldGives = MGV.offers($(QUOTE), $(BASE), mStr.bids[index]).gives();\n        // if not during initialize we necessarily have gives > oldGives\n        // otherwise we are trying to reset the offer and oldGives is irrelevant\n        return (gives > oldGives) ? gives - oldGives : gives;\n      }\n    }\n  }\n\n  /** Writes (creates or updates) a maker offer on Mangrove's order book*/\n  function safeWriteOffer(\n    uint index,\n    IERC20 outbound_tkn,\n    uint wants,\n    uint gives,\n    bool withPending, // whether `gives` amount includes current pending tokens\n    uint pivotId\n  ) internal {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    if (outbound_tkn == BASE) {\n      uint not_published = writeAsk(index, wants, gives, pivotId);\n      if (not_published > 0) {\n        // Ask could not be written on the book (density or provision issue)\n        mStr.pending_base = withPending\n          ? not_published\n          : (mStr.pending_base + not_published);\n      } else {\n        if (withPending) {\n          mStr.pending_base = 0;\n        }\n      }\n    } else {\n      uint not_published = writeBid(index, wants, gives, pivotId);\n      if (not_published > 0) {\n        mStr.pending_quote = withPending\n          ? not_published\n          : (mStr.pending_quote + not_published);\n      } else {\n        if (withPending) {\n          mStr.pending_quote = 0;\n        }\n      }\n    }\n  }\n\n  // returns the value of x in the ring [0,m]\n  // i.e if x>=0 this is just x % m\n  // if x<0 this is m + (x % m)\n  function modulo(int x, uint m) internal pure returns (uint) {\n    if (x >= 0) {\n      return uint(x) % m;\n    } else {\n      return uint(int(m) + (x % int(m)));\n    }\n  }\n\n  /** Minimal amount of quotes for the general term of the `quote_progression` */\n  /** If min price was not shifted this is just `QUOTE_0` */\n  /** In general this is QUOTE_0 + shift*delta */\n  function quote_min() internal view returns (uint) {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    int qm = int(uint(QUOTE_0)) + mStr.shift * int(mStr.delta);\n    require(qm > 0, \"Mango/quote_min/ShiftUnderflow\");\n    return (uint(qm));\n  }\n\n  /** Returns the price position in the order book of the offer associated to this index `i` */\n  function position_of_index(uint i) internal view returns (uint) {\n    // position(i) = (i+shift) % N\n    return modulo(int(i) - MangoStorage.get_storage().shift, NSLOTS);\n  }\n\n  /** Returns the index in the ring of offers at which the offer Id at position `p` in the book is stored */\n  function index_of_position(uint p) internal view returns (uint) {\n    return modulo(int(p) + MangoStorage.get_storage().shift, NSLOTS);\n  }\n\n  /**Next index in the ring of offers */\n  function next_index(uint i) internal view returns (uint) {\n    return (i + 1) % NSLOTS;\n  }\n\n  /**Previous index in the ring of offers */\n  function prev_index(uint i) internal view returns (uint) {\n    return i > 0 ? i - 1 : NSLOTS - 1;\n  }\n\n  /** Function that determines the amount of quotes that are offered at position i of the OB dePENDING on initial_price and paramater delta*/\n  /** Here the default is an arithmetic progression */\n  function quote_progression(uint position) internal view returns (uint) {\n    return\n      MangoStorage.quote_price_jumps(\n        MangoStorage.get_storage().delta,\n        position,\n        quote_min()\n      );\n  }\n\n  /** Returns the quantity of quote tokens for an offer at position `p` given an amount of Base tokens (eq. 2)*/\n  function quotes_of_position(uint p, uint base_amount)\n    internal\n    view\n    returns (uint)\n  {\n    return (quote_progression(p) * base_amount) / BASE_0;\n  }\n\n  /** Returns the quantity of base tokens for an offer at position `p` given an amount of quote tokens (eq. 3)*/\n  function bases_of_position(uint p, uint quote_amount)\n    internal\n    view\n    returns (uint)\n  {\n    return (quote_amount * BASE_0) / quote_progression(p);\n  }\n\n  /** Recenter the order book by shifting min price up `s` positions in the book */\n  /** As a consequence `s` Bids will be cancelled and `s` new asks will be posted */\n  function positive_shift(\n    uint s,\n    bool withBase,\n    uint[] calldata amounts\n  ) internal {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    require(s < NSLOTS, \"Mango/shift/positiveShiftTooLarge\");\n    uint index = index_of_position(0);\n    mStr.shift += int(s); // updating new shift\n    // Warning: from now on position_of_index reflects the new shift\n    // One must progress relative to index when retracting offers\n    uint cpt = 0;\n    while (cpt < s) {\n      // slots occupied by [Bids[index],..,Bids[index+`s` % N]] are retracted\n      if (mStr.bids[index] != 0) {\n        retractOffer({\n          outbound_tkn: QUOTE,\n          inbound_tkn: BASE,\n          offerId: mStr.bids[index],\n          deprovision: false\n        });\n      }\n\n      // slots are replaced by `s` Asks.\n      // NB the price of Ask[index] is computed given the new position associated to `index`\n      // because the shift has been updated above\n\n      // `pos` is the offer position in the OB (not the array)\n      uint pos = position_of_index(index);\n      uint new_gives;\n      uint new_wants;\n      if (withBase) {\n        // posting new ASKS with base amount fixed\n        new_gives = amounts[cpt];\n        new_wants = quotes_of_position(pos, amounts[cpt]);\n      } else {\n        // posting new ASKS with quote amount fixed\n        new_wants = amounts[cpt];\n        new_gives = bases_of_position(pos, amounts[cpt]);\n      }\n      safeWriteOffer({\n        index: index,\n        outbound_tkn: BASE,\n        wants: new_wants,\n        gives: new_gives,\n        withPending: false, // don't add pending liqudity in new offers (they are far from mid price)\n        pivotId: pos > 0 ? mStr.asks[index_of_position(pos - 1)] : 0\n      });\n      cpt++;\n      index = next_index(index);\n    }\n  }\n\n  /** Recenter the order book by shifting max price down `s` positions in the book */\n  /** As a consequence `s` Asks will be cancelled and `s` new Bids will be posted */\n  function negative_shift(\n    uint s,\n    bool withBase,\n    uint[] calldata amounts\n  ) internal {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    require(s < NSLOTS, \"Mango/shift/NegativeShiftTooLarge\");\n    uint index = index_of_position(NSLOTS - 1);\n    mStr.shift -= int(s); // updating new shift\n    // Warning: from now on position_of_index reflects the new shift\n    // One must progress relative to index when retracting offers\n    uint cpt;\n    while (cpt < s) {\n      // slots occupied by [Asks[index-`s` % N],..,Asks[index]] are retracted\n      if (mStr.asks[index] != 0) {\n        retractOffer({\n          outbound_tkn: BASE,\n          inbound_tkn: QUOTE,\n          offerId: mStr.asks[index],\n          deprovision: false\n        });\n      }\n      // slots are replaced by `s` Bids.\n      // NB the price of Bids[index] is computed given the new position associated to `index`\n      // because the shift has been updated above\n\n      // `pos` is the offer position in the OB (not the array)\n      uint pos = position_of_index(index);\n      uint new_gives;\n      uint new_wants;\n      if (withBase) {\n        // amounts in base\n        new_wants = amounts[cpt];\n        new_gives = quotes_of_position(pos, amounts[cpt]);\n      } else {\n        // amounts in quote\n        new_wants = bases_of_position(pos, amounts[cpt]);\n        new_gives = amounts[cpt];\n      }\n      safeWriteOffer({\n        index: index,\n        outbound_tkn: QUOTE,\n        wants: new_wants,\n        gives: new_gives,\n        withPending: false,\n        pivotId: pos < NSLOTS - 1 ? mStr.bids[index_of_position(pos + 1)] : 0\n      });\n      cpt++;\n      index = prev_index(index);\n    }\n  }\n\n  // residual gives is default (i.e offer.gives - order.wants) + PENDING\n  // this overrides the corresponding function in `Persistent`\n  function __residualGives__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    if (order.outbound_tkn == $(BASE)) {\n      // Ask offer\n      return super.__residualGives__(order) + mStr.pending_base;\n    } else {\n      // Bid offer\n      return super.__residualGives__(order) + mStr.pending_quote;\n    }\n  }\n\n  // for reposting partial filled offers one always gives the residual (default behavior)\n  // and adapts wants to the new price (if different).\n  // this overrides the corresponding function in `Persistent`\n  function __residualWants__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    if (order.outbound_tkn == address(BASE)) {\n      // Ask offer (wants QUOTE)\n      uint index = mStr.index_of_ask[order.offerId];\n      uint residual_base = __residualGives__(order); // default\n      if (residual_base == 0) {\n        return 0;\n      }\n      return quotes_of_position(position_of_index(index), residual_base);\n    } else {\n      // Bid order (wants BASE)\n      uint index = mStr.index_of_bid[order.offerId];\n      uint residual_quote = __residualGives__(order); // default\n      if (residual_quote == 0) {\n        return 0;\n      }\n      return bases_of_position(position_of_index(index), residual_quote);\n    }\n  }\n\n  // TODO add LogIncident and Bid/AskatMax logs\n  function $posthookSuccess(ML.SingleOrder calldata order)\n    external\n    delegated\n    returns (bool success)\n  {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n\n    // manage source of BASE and QUOTE whose reserve may have changed during the trade execution\n    IERC20[] memory tokens = new IERC20[](2);\n    tokens[0] = BASE;\n    tokens[1] = QUOTE;\n\n    // reposting residual of offer using override `__newWants__` and `__newGives__` for new price\n    if (order.outbound_tkn == $(BASE)) {\n      // order is an Ask\n      //// Reposting Offer residual\n      if (!super.__posthookSuccess__(order)) {\n        // residual could not be reposted --either below density or Mango went out of provision on Mangrove\n        mStr.pending_base = __residualGives__(order); // this includes previous `pending_base`\n      } else {\n        mStr.pending_base = 0;\n      }\n      //// Posting dual bid offer\n      uint index = mStr.index_of_ask[order.offerId];\n\n      uint pos = position_of_index(index);\n      // bid for some BASE token with the received QUOTE tokens @ pos-1\n      if (pos > 0) {\n        // updateBid will include PENDING_QUOTES if any\n        updateBid({\n          index: index_of_position(pos - 1),\n          reset: false, // top up old value with received amount\n          amount: order.gives, // in QUOTES\n          pivotId: 0\n        });\n        if (pos - 1 <= mStr.min_buffer) {\n          emit BidAtMaxPosition();\n        }\n        return true;\n      } else {\n        // Ask cannot be at Pmin unless a shift has eliminated all bids\n        revert(\"Mango/BidOutOfRange\");\n      }\n    } else {\n      // Bid offer (`this` contract just bought some BASE)\n\n      if (!super.__posthookSuccess__(order)) {\n        // residual could not be reposted --either below density or Mango went out of provision on Mangrove\n        mStr.pending_quote = __residualGives__(order); // this includes previous `PENDING_QUOTE`\n      } else {\n        mStr.pending_quote = 0;\n      }\n\n      uint index = mStr.index_of_bid[order.offerId];\n      // offer was not posted using newOffer\n      uint pos = position_of_index(index);\n      // ask for some QUOTE tokens in exchange of the received BASE tokens @ pos+1\n      if (pos < NSLOTS - 1) {\n        // updateAsk will include mStr.pending_baseS if any\n        updateAsk({\n          index: index_of_position(pos + 1),\n          reset: false, // top up old value with received amount\n          amount: order.gives, // in BASE\n          pivotId: 0\n        });\n        if (pos + 1 >= NSLOTS - mStr.min_buffer) {\n          emit AskAtMinPosition();\n        }\n        return true;\n      } else {\n        revert(\"Mango/AskOutOfRange\");\n      }\n    }\n  }\n\n  function updateBid(\n    uint index,\n    bool reset, // whether this call is part of an `initialize` procedure\n    uint amount, // in QUOTE tokens\n    uint pivotId\n  ) internal {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    // outbound : QUOTE, inbound: BASE\n    P.Offer.t offer = MGV.offers($(QUOTE), $(BASE), mStr.bids[index]);\n\n    uint position = position_of_index(index);\n\n    uint new_gives = reset\n      ? amount\n      : (amount + offer.gives() + mStr.pending_quote);\n    uint new_wants = bases_of_position(position, new_gives);\n\n    uint pivot;\n    if (offer.gives() == 0) {\n      // offer was not live\n      if (pivotId != 0) {\n        pivot = pivotId;\n      } else {\n        if (position > 0) {\n          pivot = mStr.bids[index_of_position(position - 1)]; // if this offer is no longer in the book will start form best\n        } else {\n          pivot = offer.prev(); // trying previous offer on Mangrove as a pivot\n        }\n      }\n    } else {\n      // offer is live, so reusing its id for pivot\n      pivot = mStr.bids[index];\n    }\n    safeWriteOffer({\n      index: index,\n      outbound_tkn: QUOTE,\n      wants: new_wants,\n      gives: new_gives,\n      withPending: !reset,\n      pivotId: pivot\n    });\n  }\n\n  function updateAsk(\n    uint index,\n    bool reset, // whether this call is part of an `initialize` procedure\n    uint amount, // in BASE tokens\n    uint pivotId\n  ) internal {\n    MangoStorage.Layout storage mStr = MangoStorage.get_storage();\n    // outbound : BASE, inbound: QUOTE\n    P.Offer.t offer = MGV.offers($(BASE), $(QUOTE), mStr.asks[index]);\n    uint position = position_of_index(index);\n\n    uint new_gives = reset\n      ? amount\n      : (amount + offer.gives() + mStr.pending_base); // in BASE\n    uint new_wants = quotes_of_position(position, new_gives);\n\n    uint pivot;\n    if (offer.gives() == 0) {\n      // offer was not live\n      if (pivotId != 0) {\n        pivot = pivotId;\n      } else {\n        if (position > 0) {\n          pivot = mStr.asks[index_of_position(position - 1)]; // if this offer is no longer in the book will start form best\n        } else {\n          pivot = offer.prev(); // trying previous offer on Mangrove as a pivot\n        }\n      }\n    } else {\n      // offer is live, so reusing its id for pivot\n      pivot = mStr.asks[index];\n    }\n    safeWriteOffer({\n      index: index,\n      outbound_tkn: BASE,\n      wants: new_wants,\n      gives: new_gives,\n      withPending: !reset,\n      pivotId: pivot\n    });\n  }\n}\n"
    },
    "contracts/test/core/Permit.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\n/*  *** JS CHEAT SHEET ******************************\n\n  Cheat sheet about ethers.js sig generation\n\n  // Follow https://eips.ethereum.org/EIPS/eip-2612\n\n  declare owner: Signer;\n\n  const domain = {\n    name: \"Mangrove\",\n    version: \"1\",\n    chainId: 31337, // hardhat chainid\n    verifyingContract: mgvAddress,\n  };\n\n  const types = {\n    Permit: [\n      { name: \"base\", type: \"address\" },\n      { name: \"quote\", type: \"address\" },\n      { name: \"owner\", type: \"address\" },\n      { name: \"spender\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"nonce\", type: \"uint256\" },\n      { name: \"deadline\", type: \"uint256\" },\n    ],\n  };\n\n  const data = {\n    base: baseAddress,\n    quote: quoteAddress,\n    owner: await owner.getAddress(),\n    spender: permit.address,\n    value: value,\n    nonce: 0,\n    deadline: deadline,\n  };\n\n  owner._signTypedData(domain, types, data);\n\n*/\n\nimport \"contracts/test/lib/MangroveTest.sol\";\nimport {Vm} from \"foundry_lib/forge-std/src/Vm.sol\";\n\ncontract PermitTest is MangroveTest, TrivialTestMaker {\n  using stdStorage for StdStorage;\n  using mgvPermitData for mgvPermitData.t;\n\n  uint bad_owner_key;\n  address bad_owner;\n  uint good_owner_key;\n  address good_owner;\n  mgvPermitData.t permit_data;\n\n  function setUp() public override {\n    super.setUp();\n\n    (bad_owner_key, bad_owner) = freshAccount(\"bad owner\");\n    (good_owner_key, good_owner) = freshAccount(\"good owner\");\n\n    vm.prank(good_owner);\n    quote.approve($(mgv), type(uint).max);\n    deal($(quote), good_owner, 2 ether);\n\n    permit_data = mgvPermitData.t({\n      outbound_tkn: $(base),\n      inbound_tkn: $(quote),\n      owner: good_owner,\n      spender: $(this),\n      value: 1 ether,\n      nonce: 0,\n      deadline: block.timestamp + 1,\n      key: good_owner_key,\n      mgv: mgv,\n      permit_typehash: mgv.PERMIT_TYPEHASH(),\n      domain_separator: mgv.DOMAIN_SEPARATOR()\n    });\n  }\n\n  function snipeFor(uint value, address who)\n    internal\n    returns (\n      uint,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    return\n      mgv.snipesFor(\n        $(base),\n        $(quote),\n        wrap_dynamic([uint(1), value, value, 300_000]),\n        true,\n        who\n      );\n  }\n\n  function newOffer(uint amount) internal {\n    mgv.newOffer($(base), $(quote), amount, amount, 100_000, 0, 0);\n  }\n\n  function test_no_allowance(uint96 value) external {\n    /* You can use 0 from someone who gave you an allowance of 0. */\n    vm.assume(value > 0); //can't create a 0 offer\n    deal($(base), $(this), value);\n    deal($(quote), good_owner, value);\n    newOffer(value);\n    vm.expectRevert(\"mgv/lowAllowance\");\n    snipeFor(value, good_owner);\n  }\n\n  function test_wrong_owner() public {\n    permit_data.signer(bad_owner_key);\n    vm.expectRevert(\"mgv/permit/invalidSignature\");\n    permit_data.submit();\n  }\n\n  function test_wrong_deadline() public {\n    permit_data.deadline = 0;\n    vm.expectRevert(\"mgv/permit/expired\");\n    permit_data.submit();\n  }\n\n  function test_late_nonce() public {\n    permit_data.nonce = 1;\n    vm.expectRevert(\"mgv/permit/invalidSignature\");\n    permit_data.submit();\n  }\n\n  function test_early_nonce() public {\n    stdstore\n      .target($(mgv))\n      .sig(mgv.nonces.selector)\n      .with_key(good_owner)\n      .checked_write(1);\n\n    vm.expectRevert(\"mgv/permit/invalidSignature\");\n    permit_data.submit();\n  }\n\n  function test_wrong_outbound() public {\n    permit_data.outbound_tkn = address(1);\n    permit_data.submit();\n    assertEq(\n      mgv.allowances($(base), $(quote), good_owner, $(this)),\n      0,\n      \"Allowance should be 0\"\n    );\n  }\n\n  function test_wrong_inbound() public {\n    permit_data.inbound_tkn = address(1);\n    permit_data.submit();\n    assertEq(\n      mgv.allowances($(base), $(quote), good_owner, $(this)),\n      0,\n      \"Allowance should be 0\"\n    );\n  }\n\n  function test_wrong_spender() public {\n    permit_data.spender = address(1);\n    permit_data.submit();\n    assertEq(\n      mgv.allowances($(base), $(quote), good_owner, $(this)),\n      0,\n      \"Allowance should be 0\"\n    );\n  }\n\n  function test_good_permit(uint96 value) public {\n    permit_data.value = value;\n    permit_data.submit();\n\n    assertEq(\n      mgv.allowances($(base), $(quote), good_owner, $(this)),\n      value,\n      \"Allowance not set\"\n    );\n  }\n\n  function test_allowance_works() public {\n    uint value = 1 ether;\n    // set allowance manually\n    stdstore\n      .target($(mgv))\n      .sig(mgv.allowances.selector)\n      .with_key($(base))\n      .with_key($(quote))\n      .with_key(good_owner)\n      .with_key($(this))\n      .checked_write(value);\n\n    deal($(base), $(this), value);\n    deal($(quote), good_owner, value);\n    newOffer(value);\n    (uint successes, uint takerGot, uint takerGave, , ) = snipeFor(\n      value / 2,\n      good_owner\n    );\n    assertEq(successes, 1, \"Snipe should succeed\");\n    assertEq(takerGot, value / 2, \"takerGot should be 1 ether\");\n    assertEq(takerGave, value / 2, \"takerGot should be 1 ether\");\n\n    assertEq(\n      mgv.allowances($(base), $(quote), good_owner, $(this)),\n      value / 2 + (value % 2),\n      \"Allowance incorrectly decreased\"\n    );\n  }\n}\n\n/* Permit utilities */\n\nlibrary mgvPermitData {\n  Vm private constant vm =\n    Vm(address(uint160(uint(keccak256(\"hevm cheat code\")))));\n\n  struct t {\n    address outbound_tkn;\n    address inbound_tkn;\n    address owner;\n    address spender;\n    uint value;\n    uint nonce;\n    uint deadline;\n    // used at submit() time\n    uint key;\n    // easier to store here (avoids an extra `mgv` arg to lib fns)\n    AbstractMangrove mgv;\n    // must preread from mangrove since calling mgv\n    // just-in-time will trip up `expectRevert`\n    // (looking for a fix to this)\n    bytes32 permit_typehash;\n    bytes32 domain_separator;\n  }\n\n  function signer(t storage p, uint key) internal returns (t storage) {\n    p.key = key;\n    return p;\n  }\n\n  function sign(t storage p)\n    internal\n    returns (\n      uint8 v,\n      bytes32 r,\n      bytes32 s\n    )\n  {\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        p.domain_separator,\n        keccak256(\n          abi.encode(\n            p.permit_typehash,\n            p.outbound_tkn,\n            p.inbound_tkn,\n            p.owner,\n            p.spender,\n            p.value,\n            p.nonce,\n            p.deadline\n          )\n        )\n      )\n    );\n    return vm.sign(p.key, digest);\n  }\n\n  function submit(t storage p) internal {\n    (uint8 v, bytes32 r, bytes32 s) = sign(p);\n    p.mgv.permit({\n      outbound_tkn: p.outbound_tkn,\n      inbound_tkn: p.inbound_tkn,\n      owner: p.owner,\n      spender: p.spender,\n      value: p.value,\n      deadline: p.deadline,\n      v: v,\n      r: r,\n      s: s\n    });\n  }\n}\n"
    },
    "contracts/test/strategies/Mango.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\nimport \"contracts/strategies/single_user/market_making/mango/Mango.sol\";\nimport \"contracts/strategies/routers/SimpleRouter.sol\";\n\ncontract MangoTest is MangroveTest {\n  struct Book {\n    uint[] bids;\n    uint[] asks;\n  }\n\n  uint constant BASE0 = 0.34 ether;\n  uint constant BASE1 = 1000 * 10**6; //because usdc decimals?\n  uint constant NSLOTS = 10;\n  // price increase is delta/BASE_0\n  uint constant DELTA = 34 * 10**6; // because usdc decimals?\n\n  TestToken weth;\n  TestToken usdc;\n  address payable maker;\n  address payable taker;\n  Mango mgo;\n\n  function setUp() public override {\n    options.base.symbol = \"WETH\";\n    options.quote.symbol = \"USDC\";\n    options.quote.decimals = 6;\n    options.defaultFee = 30;\n\n    // deploying mangrove and opening WETH/USDC market.\n    super.setUp();\n    // rename for convenience\n    weth = base;\n    usdc = quote;\n\n    maker = freshAddress(\"maker\");\n    taker = freshAddress(\"taker\");\n    deal($(weth), taker, cash(weth, 50));\n    deal($(usdc), taker, cash(usdc, 100_000));\n\n    vm.startPrank(maker);\n    mgo = new Mango({\n      mgv: IMangrove($(mgv)), // TODO: remove IMangrove dependency?\n      base: weth,\n      quote: usdc,\n      base_0: cash(weth, 34, 2),\n      quote_0: cash(usdc, 1000),\n      nslots: NSLOTS,\n      price_incr: DELTA,\n      deployer: maker\n    });\n    vm.stopPrank();\n  }\n\n  /* combine all tests wince they rely on non-zero state */\n  function test_all() public {\n    part_deploy_strat();\n    part_market_order();\n    part_negative_shift();\n    part_positive_shift();\n    part_partial_fill();\n    part_text_residual_1();\n    part_text_residual_2();\n    part_kill();\n    part_restart_fixed_shift();\n  }\n\n  function part_deploy_strat() public {\n    vm.startPrank(maker);\n    // reserve has to approve liquidity router of Mango for ETH and USDC transfer\n    // since reserve here is an EOA we do it direclty\n    usdc.approve($(mgo.router()), type(uint).max);\n    weth.approve($(mgo.router()), type(uint).max);\n    vm.stopPrank();\n\n    // funds come from maker's wallet by default\n    // liquidity router will pull the funds from the wallet when needed\n    deal($(weth), maker, cash(weth, 17));\n    deal($(usdc), maker, cash(usdc, 50000));\n\n    uint prov = mgo.getMissingProvision({\n      outbound_tkn: weth,\n      inbound_tkn: usdc,\n      gasreq: mgo.ofr_gasreq(),\n      gasprice: 0,\n      offerId: 0\n    });\n\n    mgv.fund{value: prov * 20}($(mgo));\n\n    vm.startPrank(maker);\n    init(cash(usdc, 1000), cash(weth, 3, 1));\n    vm.stopPrank();\n\n    Book memory book = get_offers(false);\n\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(1), 2, 3, 4, 5, 0, 0, 0, 0, 0])\n    );\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), 0, 0, 0, 0, 1, 2, 3, 4, 5])\n    );\n  }\n\n  function part_market_order() public {\n    vm.prank(taker);\n    weth.approve($(mgv), type(uint).max);\n    vm.prank(taker);\n    usdc.approve($(mgv), type(uint).max);\n\n    vm.prank(taker);\n    (uint got, uint gave, uint bounty, ) = mgv.marketOrder(\n      $(weth),\n      $(usdc),\n      cash(weth, 5, 1),\n      cash(usdc, 3000),\n      true\n    );\n\n    Book memory book = get_offers(false);\n    assertEq(\n      got,\n      minusFee($(weth), $(usdc), 0.5 ether),\n      \"incorrect received amount\"\n    );\n    assertEq(bounty, 0, \"taker should not receive bounty\");\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(1), 2, 3, 4, 5, 6, 0, 0, 0, 0])\n    );\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), 0, 0, 0, 0, -1, 2, 3, 4, 5])\n    );\n\n    vm.prank(taker);\n    (got, gave, bounty, ) = mgv.marketOrder(\n      $(usdc),\n      $(weth),\n      cash(usdc, 3500),\n      cash(weth, 15, 1),\n      true\n    );\n\n    assertEq(\n      got,\n      minusFee($(usdc), $(weth), cash(usdc, 3500)),\n      \"incorrect received amount\"\n    );\n\n    assertEq(bounty, 0, \"taker should not receive bounty\");\n\n    book = get_offers(false);\n\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(1), 2, 3, 4, -5, -6, 0, 0, 0, 0])\n    );\n\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), 0, 0, 0, 6, 1, 2, 3, 4, 5])\n    );\n  }\n\n  function part_negative_shift() public {\n    vm.prank(maker);\n    mgo.set_shift({\n      s: -2,\n      withBase: false,\n      amounts: dynamic([cash(usdc, 1000), cash(usdc, 1000)])\n    });\n\n    Book memory book = get_offers(false);\n\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(8), 7, 1, 2, 3, 4, -5, -6, 0, 0])\n    );\n\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(-4), -5, 0, 0, 0, 0, 6, 1, 2, 3])\n    );\n  }\n\n  function part_positive_shift() public {\n    vm.prank(maker);\n    mgo.set_shift({\n      s: 3,\n      withBase: true,\n      amounts: dynamic([cash(weth, 3, 1), cash(weth, 3, 1), cash(weth, 3, 1)])\n    });\n\n    Book memory book = get_offers(false);\n\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(2), 3, 4, -5, -6, 0, 0, -8, -7, -1])\n    );\n\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), 0, 0, 6, 1, 2, 3, 4, 5, 7])\n    );\n  }\n\n  function part_partial_fill() public {\n    // scenario:\n    // - set density so high that offer can no longer be updated\n    // - run a market order and check that bid is not updated after ask is being consumed\n    // - verify takerGave is pending\n    // - put back the density and run another market order\n    mgv.setDensity($(weth), $(usdc), cash(weth, 1));\n    vm.prank(taker);\n    (uint got, uint gave, uint bounty, ) = mgv.marketOrder(\n      $(usdc),\n      $(weth),\n      cash(usdc, 1, 2),\n      cash(weth, 1),\n      true\n    );\n\n    uint best_id = mgv.best($(weth), $(usdc));\n    P.Offer.t best_offer = mgv.offers($(weth), $(usdc), best_id);\n    uint old_gives = best_offer.gives();\n\n    vm.prank(maker);\n    uint pendingBase = mgo.pending()[0];\n\n    assertEq(pendingBase, gave, \"Taker liquidity should be pending\");\n\n    vm.prank(taker);\n    (got, gave, bounty, ) = mgv.marketOrder(\n      $(usdc),\n      $(weth),\n      cash(usdc, 1, 2),\n      cash(weth, 1),\n      true\n    );\n\n    vm.prank(maker);\n    uint pendingBase_ = mgo.pending()[0];\n\n    assertEq(pendingBase_, pendingBase + gave, \"Missing pending base\");\n\n    mgv.setDensity($(weth), $(usdc), 100);\n\n    vm.prank(taker);\n    mgv.marketOrder($(usdc), $(weth), cash(usdc, 1, 2), cash(weth, 1), true);\n\n    vm.prank(maker);\n    uint pendingBase__ = mgo.pending()[0];\n\n    assertEq(pendingBase__, 0, \"There should be no more pending base\");\n\n    best_id = mgv.best($(weth), $(usdc));\n    best_offer = mgv.offers($(weth), $(usdc), best_id);\n\n    assertEq(\n      best_offer.gives(),\n      old_gives + pendingBase_ + gave,\n      \"Incorrect given amount\"\n    );\n  }\n\n  function part_text_residual_1() public {\n    mgv.setDensity($(usdc), $(weth), cash(usdc, 1));\n    mgv.setDensity($(weth), $(usdc), cash(weth, 1));\n\n    // market order will take the following best offer\n    uint best_id = mgv.best($(usdc), $(weth));\n    P.Offer.t best_offer = mgv.offers($(usdc), $(weth), best_id);\n\n    vm.prank(taker);\n    (uint got, uint gave, uint bounty, ) = mgv.marketOrder(\n      $(usdc),\n      $(weth),\n      cash(usdc, 100),\n      cash(weth, 1),\n      true\n    );\n\n    // because density reqs are so high on both semi order book, best will not be able to self repost\n    // and residual will be added to USDC (quote) pending pool\n    // and what taker gave will not be added in the dual offer and added to the WETH (base) pending pool\n\n    vm.startPrank(maker);\n    uint pendingBase = mgo.pending()[0];\n    uint pendingQuote = mgo.pending()[1];\n    vm.stopPrank();\n\n    assertEq(gave, pendingBase, \"gave was not added to pending base pool\");\n\n    assertEq(\n      best_offer.gives() - cash(usdc, 100),\n      pendingQuote,\n      \"Residual was not added to pending quote pool\"\n    );\n\n    // second market order should produce the same effect (best has changed because old best was not able to repost)\n    best_id = mgv.best($(usdc), $(weth));\n    best_offer = mgv.offers($(usdc), $(weth), best_id);\n\n    vm.prank(taker);\n    (got, gave, bounty, ) = mgv.marketOrder(\n      $(usdc),\n      $(weth),\n      cash(usdc, 100),\n      cash(weth, 1),\n      true\n    );\n\n    vm.startPrank(maker);\n    uint pendingBase_ = mgo.pending()[0];\n    uint pendingQuote_ = mgo.pending()[1];\n    vm.stopPrank();\n\n    assertEq(\n      pendingBase + gave,\n      pendingBase_,\n      \"gave was not added to pending base pool\"\n    );\n    assertEq(\n      best_offer.gives() - cash(usdc, 100) + pendingQuote,\n      pendingQuote_,\n      \"Residual was not added to pending quote pool\"\n    );\n\n    // putting density back to normal\n    mgv.setDensity($(usdc), $(weth), 100);\n    mgv.setDensity($(weth), $(usdc), 100);\n\n    // Offer 3 and 4 were unable to repost so they should be out of the book\n\n    Book memory book = get_offers(false);\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(2), -3, -4, -5, -6, 0, 0, -8, -7, -1])\n    );\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), 0, 0, 6, 1, 2, 3, 4, 5, 7])\n    );\n  }\n\n  function part_text_residual_2() public {\n    vm.startPrank(maker);\n    uint pendingBase_ = mgo.pending()[0];\n    uint pendingQuote_ = mgo.pending()[1];\n    vm.stopPrank();\n\n    // this market order should produce the following observables:\n    // - offer 2 is now going to repost its residual which will be augmented with the content of the USDC pending pool\n    // - the dual offer of offer 2 will be created with id 8 and will offer takerGave + the content of the WETH pending pool\n    // - both pending pools should be empty\n\n    P.Offer.t old_offer2 = mgv.offers($(usdc), $(weth), 2);\n\n    vm.prank(taker);\n    (, uint gave, , ) = mgv.marketOrder(\n      $(usdc),\n      $(weth),\n      cash(usdc, 100),\n      cash(weth, 1),\n      true\n    );\n\n    Book memory book = get_offers(false);\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(2), -3, -4, -5, -6, 0, 0, -8, -7, -1])\n    );\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), 8, 0, 6, 1, 2, 3, 4, 5, 7])\n    );\n\n    vm.startPrank(maker);\n    uint pendingBase__ = mgo.pending()[0];\n    uint pendingQuote__ = mgo.pending()[1];\n    vm.stopPrank();\n\n    assertEq(pendingBase__, 0, \"Pending base pool should be empty\");\n    assertEq(pendingQuote__, 0, \"Pending quote pool should be empty\");\n\n    uint best_id = mgv.best($(weth), $(usdc));\n    P.Offer.t offer8 = mgv.offers($(weth), $(usdc), best_id);\n    assertEq(best_id, 8, \"Best offer on WETH,USDC offer list should be #8\");\n\n    assertEq(offer8.gives(), gave + pendingBase_, \"Incorrect offer gives\");\n\n    P.Offer.t offer2 = mgv.offers($(usdc), $(weth), 2);\n\n    assertEq(\n      offer2.gives(),\n      pendingQuote_ + old_offer2.gives() - cash(usdc, 100),\n      \"Incorrect offer gives\"\n    );\n  }\n\n  function part_kill() public {\n    vm.prank(maker);\n    mgo.pause();\n\n    vm.prank(taker);\n    (uint got, uint gave, , ) = mgv.marketOrder(\n      $(usdc),\n      $(weth),\n      cash(usdc, 2500),\n      cash(weth, 15, 1),\n      true\n    );\n\n    assertEq(got, 0, \"got should be 0\");\n    assertEq(gave, 0, \"gave should be 0\");\n\n    Book memory book = get_offers(false);\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(-2), -3, -4, -5, -6, 0, 0, -8, -7, -1])\n    );\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), 8, 0, 6, 1, 2, 3, 4, 5, 7])\n    );\n  }\n\n  function part_restart_fixed_shift() public {\n    vm.startPrank(maker);\n    mgo.restart();\n    init(cash(usdc, 500), cash(weth, 15, 2));\n    vm.stopPrank();\n\n    Book memory book = get_offers(false);\n    checkOB(\n      $(usdc),\n      $(weth),\n      book.bids,\n      dynamic([int(2), 3, 4, 5, 6, 0, 0, -8, -7, -1])\n    );\n    checkOB(\n      $(weth),\n      $(usdc),\n      book.asks,\n      dynamic([int(0), -8, 0, -6, -1, 2, 3, 4, 5, 7])\n    );\n  }\n\n  /* ********* Utility methods ************ */\n\n  // get internal view of mango's offers\n  function get_offers(bool liveOnly) internal view returns (Book memory) {\n    uint[][2] memory res = mgo.get_offers(liveOnly);\n    return Book({bids: res[0], asks: res[1]});\n  }\n\n  // given offerIds and offerStatuses, for id in offerStatuses,\n  // * check that offers[abs(id)] is live iff id > 0\n  // * check that abs(id)==offerIds[i]\n  function checkOB(\n    address $out,\n    address $in,\n    uint[] memory offerIds,\n    int[] memory offerStatuses\n  ) internal {\n    int sid;\n\n    for (uint i = 0; i < offerStatuses.length; i++) {\n      sid = offerStatuses[i];\n      assertEq(\n        mgv.offers($out, $in, abs(sid)).gives() > 0,\n        sid > 0,\n        string.concat(\"wrong offer status \", int2str(sid))\n      );\n      assertEq(offerIds[i], abs(sid), \"Offer misplaced\");\n    }\n  }\n\n  // init procedure\n  // TODO explain\n  function init(uint bidAmount, uint askAmount) internal {\n    uint slice = NSLOTS / 2; // require(NSLOTS%2==0)?\n    uint[] memory pivotIds = new uint[](NSLOTS);\n    uint[] memory amounts = new uint[](NSLOTS);\n    for (uint i = 0; i < NSLOTS; i++) {\n      amounts[i] = i < NSLOTS / 2 ? bidAmount : askAmount;\n    }\n\n    for (uint i = 0; i < 2; i++) {\n      mgo.initialize({\n        reset: true,\n        lastBidPosition: 4,\n        from: slice * i,\n        to: slice * (i + 1),\n        pivotIds: [pivotIds, pivotIds],\n        tokenAmounts: amounts\n      });\n    }\n  }\n}\n"
    },
    "contracts/strategies/single_user/SimpleMaker.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleMaker.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/strategies/single_user/abstract/SingleUser.sol\";\nimport \"contracts/strategies/routers/AbstractRouter.sol\";\n\n/* Simply inherits SingleUser and is deployable. No internal logic. */\ncontract SimpleMaker is SingleUser {\n  constructor(IMangrove _MGV, address deployer)\n    SingleUser(_MGV, 50_000, AbstractRouter(address(0)))\n  {\n    // if contract is deployed with static address, then one must set admin to something else than msg.sender\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n    }\n  }\n}\n"
    },
    "contracts/toy_strategies/single_user/abstract/Defensive.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Defensive.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/single_user/abstract/SingleUser.sol\";\nimport \"../../interfaces/IOracle.sol\";\n\n/** Strat class with simple oracle based last-look management */\n/** (Single user variant) */\n\nabstract contract Defensive is SingleUser {\n  uint16 slippage_num;\n  uint16 constant slippage_den = 10**4;\n  IOracle public oracle;\n\n  // emitted when no price data is available for given token\n  event MissingPrice(address token);\n\n  constructor(address _oracle) {\n    require(!(_oracle == address(0)), \"SingleUser/Defensive/0xOracle\");\n    oracle = IOracle(_oracle);\n  }\n\n  function setSlippage(uint _slippage) external onlyAdmin {\n    require(\n      uint16(_slippage) == _slippage && uint16(_slippage) <= slippage_den,\n      \"SingelUser/Defensive/SlippageInvalid\"\n    );\n    slippage_num = uint16(_slippage);\n  }\n\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool)\n  {\n    uint offer_gives_REF = order.wants * oracle.getPrice(order.outbound_tkn); // returns price in oracle base units (i.e ETH or USD)\n    uint offer_wants_REF = order.gives * oracle.getPrice(order.inbound_tkn); // returns price is oracle base units (i.e ETH or USD)\n    // abort trade if price data is not available\n    if (offer_gives_REF == 0) {\n      emit MissingPrice(order.outbound_tkn);\n      return false;\n    }\n    if (offer_wants_REF == 0) {\n      emit MissingPrice(order.inbound_tkn);\n      return false;\n    }\n    // if offer_gives_REF * (1-slippage) > offer_wants_REF one is getting arb'ed\n    // i.e slippage_den * OGR - slippage_num * OGR > OWR * slippage_den\n    return\n      offer_gives_REF * slippage_den - offer_gives_REF * slippage_num <=\n      offer_wants_REF * slippage_den;\n  }\n}\n"
    },
    "contracts/test/periphery/MgvOrder.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"contracts/test/lib/MangroveTest.sol\";\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\n// import \"../../AbstractMangrove.sol\";\nimport {MgvLib as ML, P, IMaker} from \"contracts/MgvLib.sol\";\nimport {IMangrove} from \"contracts/IMangrove.sol\";\n\n// import \"hardhat/console.sol\";\n\n// import \"../Toolbox/sol\";\n\n// import \"../Agents/TestToken.sol\";\n// import \"../Agents/TestMaker.sol\";\n\nimport {MangroveOrderEnriched as MgvOrder} from \"contracts/periphery/MangroveOrderEnriched.sol\";\nimport \"contracts/strategies/interfaces/IOrderLogic.sol\";\n\ncontract MangroveOrder_Test is MangroveTest {\n  // to check ERC20 logging\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  // to check incident logging\n  event LogIncident(\n    IMangrove mangrove,\n    IERC20 indexed outbound_tkn,\n    IERC20 indexed inbound_tkn,\n    uint indexed offerId,\n    bytes32 reason\n  );\n\n  event OrderSummary(\n    IMangrove mangrove,\n    IERC20 indexed base,\n    IERC20 indexed quote,\n    address indexed taker,\n    bool selling,\n    uint takerGot,\n    uint takerGave,\n    uint penalty,\n    uint restingOrderId\n  );\n\n  MgvOrder mgo;\n  TestMaker bid_maker;\n  TestMaker ask_maker;\n  TestTaker sell_taker;\n\n  receive() external payable {}\n\n  function setUp() public override {\n    super.setUp();\n    mgv.setFee($(base), $(quote), 30);\n    mgv.setFee($(quote), $(base), 30);\n    // to prevent test runner (taker) from receiving fees!\n    mgv.setVault($(mgv));\n\n    // this contract is admin of MgvOrder and its router\n    mgo = new MgvOrder(IMangrove(payable(mgv)), $(this));\n    // mgvOrder needs to approve mangrove for inbound & outbound token transfer (inbound when acting as a taker, outbound when matched as a maker)\n    IERC20[] memory tokens = new IERC20[](2);\n    tokens[0] = base;\n    tokens[1] = quote;\n    mgo.activate(tokens);\n\n    // `this` contract will act as `MgvOrder` user\n    deal($(base), $(this), 10 ether);\n    deal($(quote), $(this), 10 ether);\n    // base.mint($(this), 10 ether);\n    // quote.mint($(this), 10 ether);\n\n    // user approves `mgo` to pull quote or base when doing a market order\n    quote.approve($(mgo.router()), 10 ether);\n    base.approve($(mgo.router()), 10 ether);\n\n    // `sell_taker` will take resting offer\n    sell_taker = setupTaker($(quote), $(base), \"sell-taker\");\n    deal($(base), $(sell_taker), 10 ether);\n    // tka.mint($(sell_taker), 10 ether);\n\n    // if seller wants to sell direclty on mangrove\n    vm.prank($(sell_taker));\n    base.approve($(mgv), 10 ether);\n    // sell_taker.approve(tka, $(mgv), 10 ether);\n    // if seller wants to sell via mgo\n    // sell_taker.approve(tka, $(mgo), 10 ether);\n    vm.prank($(sell_taker));\n    quote.approve($(mgv), 10 ether);\n\n    // populating order book with offers\n    bid_maker = setupMaker($(quote), $(base), \"bid-maker\");\n    vm.deal($(bid_maker), 10 ether);\n    ask_maker = setupMaker($(base), $(quote), \"ask-maker\");\n    vm.deal($(ask_maker), 10 ether);\n\n    vm.prank($(bid_maker));\n    quote.approve($(mgv), 10 ether);\n    // bid_maker.approveMgv(tkb, 10 ether);\n    deal($(quote), $(bid_maker), 10 ether);\n    // tkb.mint($(bid_maker), 10 ether);\n\n    deal($(base), $(ask_maker), 10 ether);\n    // tka.mint($(ask_maker), 10 ether);\n    vm.prank($(ask_maker));\n    base.approve($(mgv), 10 ether);\n    // ask_maker.approveMgv(tka, 10 ether);\n\n    bid_maker.newOfferWithFunding(1 ether, 0.1 ether, 50_000, 0, 0, 0.1 ether);\n    bid_maker.newOfferWithFunding(1 ether, 0.11 ether, 50_000, 0, 0, 0.1 ether);\n    bid_maker.newOfferWithFunding(1 ether, 0.12 ether, 50_000, 0, 0, 0.1 ether);\n\n    ask_maker.newOfferWithFunding(0.13 ether, 1 ether, 50_000, 0, 0, 0.1 ether);\n    ask_maker.newOfferWithFunding(0.14 ether, 1 ether, 50_000, 0, 0, 0.1 ether);\n    ask_maker.newOfferWithFunding(0.15 ether, 1 ether, 50_000, 0, 0, 0.1 ether);\n  }\n\n  function test_admin() public {\n    assertEq(mgv.governance(), mgo.admin(), \"Invalid admin address\");\n  }\n\n  function test_partial_filled_buy_order_returns_residual() public {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      makerWants: 2 ether,\n      gives: 0.26 ether,\n      makerGives: 0.26 ether,\n      restingOrder: false,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    expectFrom($(quote)); // checking quote is sent to mgv and remainder is sent back to taker\n    emit Transfer($(this), $(mgo), 0.26 ether);\n    expectFrom($(quote)); // checking quote is sent to mgv and remainder is sent back to taker\n    emit Transfer($(mgo), $(this), 0.13 ether);\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    assertEq(\n      res.takerGot,\n      minusFee($(base), $(quote), 1 ether),\n      \"Incorrect partial fill of taker order\"\n    );\n    assertEq(\n      res.takerGave,\n      0.13 ether,\n      \"Incorrect partial fill of taker order\"\n    );\n  }\n\n  function test_partial_filled_buy_order_reverts_when_noPartialFill_enabled()\n    public\n  {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: true,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      makerWants: 2 ether,\n      gives: 0.26 ether,\n      makerGives: 0.26 ether,\n      restingOrder: false,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    vm.expectRevert(\"mgvOrder/mo/noPartialFill\");\n    mgo.take{value: 0.1 ether}(buyOrder);\n  }\n\n  function test_partial_filled_buy_order_returns_provision() public {\n    uint balBefore = $(this).balance;\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      makerWants: 2 ether,\n      gives: 0.26 ether,\n      makerGives: 0.26 ether,\n      restingOrder: false,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    assertEq(\n      res.takerGot,\n      minusFee($(base), $(quote), 1 ether),\n      \"Incorrect taker got\"\n    );\n    assertEq(balBefore, $(this).balance, \"Take function did not return funds\");\n  }\n\n  function test_partial_filled_buy_order_returns_bounty() public {\n    uint balBefore = $(this).balance;\n    ask_maker.shouldRevert(true);\n\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether,\n      makerWants: 2 ether,\n      makerGives: 0.26 ether,\n      restingOrder: false,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    assertTrue(res.bounty > 0, \"Bounty should not be zero\");\n    assertEq(\n      balBefore + res.bounty,\n      $(this).balance,\n      \"Take function did not return bounty\"\n    );\n  }\n\n  function test_resting_buy_order_reverts_when_unprovisioned() public {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether,\n      makerWants: 2 ether,\n      makerGives: 0.26 ether,\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    vm.expectRevert(\"MultiUser/derive_gasprice/NotEnoughProvision\");\n    mgo.take{value: 0.0001 ether}(buyOrder);\n  }\n\n  function test_filled_resting_buy_order_ignores_resting_option() public {\n    uint balQuoteBefore = quote.balanceOf($(this));\n    uint balBaseBefore = base.balanceOf($(this));\n\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 1 ether,\n      gives: 0.13 ether,\n      makerWants: 1 ether,\n      makerGives: 0.13 ether,\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    assertEq(\n      quote.balanceOf($(this)),\n      balQuoteBefore - res.takerGave,\n      \"incorrect quote balance\"\n    );\n    assertEq(\n      base.balanceOf($(this)),\n      balBaseBefore + res.takerGot,\n      \"incorrect base balance\"\n    );\n  }\n\n  function test_filled_resting_buy_order_returns_provision() public {\n    uint balWeiBefore = $(this).balance;\n\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 1 ether,\n      gives: 0.13 ether,\n      makerWants: 1 ether,\n      makerGives: 0.13 ether,\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take(buyOrder);\n    res; // ssh\n    assertEq($(this).balance, balWeiBefore, \"incorrect wei balance\");\n  }\n\n  function test_resting_buy_order_is_successfully_posted() public {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether, // with 2% slippage\n      makerWants: 2 ether,\n      makerGives: 0.2548 ether, //without 2% slippage\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    uint bal_quote_before = mgo.router().reserveBalance(quote, $(this));\n    uint bal_base_before = mgo.router().reserveBalance(quote, $(this));\n    assertEq(mgv.balanceOf($(mgo)), 0, \"Invalid balance on Mangrove\");\n\n    expectFrom($(mgo));\n    emit OrderSummary(\n      IMangrove(payable(mgv)),\n      base,\n      quote,\n      $(this),\n      false, //buying\n      minusFee($(base), $(quote), 1 ether),\n      0.13 ether,\n      0,\n      4 // TODO when checkEmit is available, get offer id after post\n    );\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    assertTrue(\n      res.offerId > 0,\n      \"Resting offer failed to be published on mangrove\"\n    );\n\n    // checking resting order parameters\n    P.Offer.t offer = mgv.offers($(quote), $(base), res.offerId);\n    assertEq(\n      offer.wants(),\n      buyOrder.makerWants - (res.takerGot + res.fee),\n      \"Incorrect wants for bid resting order\"\n    );\n    assertEq(\n      offer.gives(),\n      buyOrder.makerGives - res.takerGave,\n      \"Incorrect gives for bid resting order\"\n    );\n\n    // checking `mgo` mappings\n    assertEq(\n      mgo.ownerOf(quote, base, res.offerId),\n      $(this),\n      \"Invalid offer owner\"\n    );\n    assertEq(\n      mgo.router().reserveBalance(quote, $(this)),\n      bal_quote_before - res.takerGave,\n      \"Invalid quote balance\"\n    );\n    assertEq(\n      mgo.router().reserveBalance(base, $(this)),\n      bal_base_before + res.takerGot,\n      \"Invalid quote balance\"\n    );\n  }\n\n  function test_resting_buy_order_can_be_partially_filled() public {\n    //mgv.setFee($(quote), $(base), 0);\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether,\n      makerWants: 2 ether,\n      makerGives: 0.26 ether,\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    uint oldLocalBaseBal = base.balanceOf($(this));\n    uint oldRemoteQuoteBal = mgo.router().reserveBalance(quote, $(this)); // quote balance of test runner\n\n    // logOfferBook(mgv,$(base),$(quote),4);\n    // logOfferBook(mgv,$(quote),$(base),4);\n\n    (\n      bool success,\n      uint sell_takerGot,\n      uint sell_takerGave,\n      ,\n      uint fee\n    ) = sell_taker.takeWithInfo({offerId: res.offerId, takerWants: 0.1 ether});\n\n    assertTrue(success, \"Resting order failed\");\n    // offer delivers\n    assertEq(\n      sell_takerGot,\n      minusFee($(quote), $(base), 0.1 ether),\n      \"Incorrect received amount for seller taker\"\n    );\n    // inbound token forwarded to test runner\n    assertEq(\n      base.balanceOf($(this)),\n      oldLocalBaseBal + sell_takerGave,\n      \"Incorrect forwarded amount to initial taker\"\n    );\n\n    assertEq(\n      mgo.router().reserveBalance(quote, $(this)),\n      oldRemoteQuoteBal - (sell_takerGot + fee),\n      \"Incorrect token balance on mgo\"\n    );\n\n    // checking resting order residual\n    P.Offer.t offer = mgv.offers($(quote), $(base), res.offerId);\n\n    assertEq(\n      offer.gives(),\n      buyOrder.gives - res.takerGave - 0.1 ether,\n      \"Incorrect gives for bid resting order\"\n    );\n  }\n\n  function test_resting_offer_retracts_when_unable_to_repost() public {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether,\n      makerWants: 2 ether,\n      makerGives: 0.26 ether,\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    // test runner quote balance on the gateway\n    uint oldWeiBalance = $(this).balance;\n\n    // increasing density on mangrove so that resting offer can no longer repost\n    mgv.setDensity($(quote), $(base), 1 ether);\n    expectFrom($(mgv));\n    emit OfferRetract($(quote), $(base), res.offerId);\n    (bool success, , , , ) = sell_taker.takeWithInfo({\n      offerId: res.offerId,\n      takerWants: 0\n    });\n    assertTrue(success, \"snipe failed\");\n    assertEq($(this).balance, oldWeiBalance, \"retract should not deprovision\");\n  }\n\n  function test_user_can_retract_resting_offer() public {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether,\n      makerWants: 2 ether,\n      makerGives: 0.26 ether,\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    uint userWeiBalanceOld = $(this).balance;\n    uint credited = mgo.retractOffer(quote, base, res.offerId, true);\n    assertEq(\n      $(this).balance,\n      userWeiBalanceOld + credited,\n      \"Incorrect provision received\"\n    );\n  }\n\n  function test_failing_resting_offer_releases_uncollected_provision() public {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether,\n      makerWants: 2 ether,\n      makerGives: 0.26 ether,\n      restingOrder: true,\n      retryNumber: 0,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n\n    uint provision = 5 ether;\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: provision}(\n      buyOrder\n    );\n    // native token reserve for user\n    uint native_reserve_before = $(this).balance;\n\n    // removing base/quote approval to make resting offer fail when matched\n    quote.approve($(mgo.router()), 0);\n    base.approve($(mgo.router()), 0);\n\n    (, , , uint bounty, ) = sell_taker.takeWithInfo({\n      offerId: res.offerId,\n      takerWants: 1\n    });\n    assertTrue(bounty > 0, \"snipe should have failed\");\n    // collecting released provision\n    mgo.retractOffer(quote, base, res.offerId, true);\n    uint native_reserve_after = $(this).balance;\n    uint userReleasedProvision = native_reserve_after - native_reserve_before;\n    assertTrue(userReleasedProvision > 0, \"No released provision\");\n    // making sure approx is not too bad (UserreleasedProvision in O(provision - res.bounty))\n    assertEq(\n      (provision - res.bounty) / userReleasedProvision,\n      1,\n      \"invalid amount of released provision\"\n    );\n  }\n\n  function test_iterative_market_order_completes() public {\n    ask_maker.shouldRepost(true);\n    expectFrom($(mgv));\n    emit OrderComplete(\n      $(base),\n      $(quote),\n      $(mgo),\n      minusFee($(base), $(quote), 1 ether),\n      0.13 ether,\n      0,\n      getFee($(base), $(quote), 1 ether)\n    );\n    expectFrom($(mgv));\n    emit OrderComplete(\n      $(base),\n      $(quote),\n      $(mgo),\n      minusFee($(base), $(quote), 1 ether),\n      0.13 ether,\n      0,\n      getFee($(base), $(quote), 1 ether)\n    );\n    expectFrom($(mgo));\n    emit OrderSummary(\n      IMangrove(payable(mgv)),\n      base,\n      quote,\n      $(this),\n      false,\n      minusFee($(base), $(quote), 2 ether),\n      0.26 ether,\n      0,\n      0\n    );\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false, //i.e buying\n      wants: 2 ether,\n      gives: 0.26 ether,\n      makerWants: 2 ether,\n      makerGives: 0.26 ether,\n      restingOrder: true,\n      retryNumber: 1,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    IOrderLogic.TakerOrderResult memory res = mgo.take{value: 0.1 ether}(\n      buyOrder\n    );\n    assertEq(\n      res.takerGot,\n      minusFee($(base), $(quote), 2 ether),\n      \"Iterative market order was not complete\"\n    );\n  }\n\n  function test_ownership_relation() public {\n    IOrderLogic.TakerOrder memory buyOrder = IOrderLogic.TakerOrder({\n      base: base,\n      quote: quote,\n      partialFillNotAllowed: false,\n      selling: false,\n      wants: 2 ether,\n      gives: 0.1 ether,\n      makerWants: 2 ether,\n      makerGives: 0.1 ether,\n      restingOrder: true,\n      retryNumber: 1,\n      gasForMarketOrder: 6_500_000,\n      blocksToLiveForRestingOrder: 0 //NA\n    });\n    expectFrom($(mgo));\n    emit OrderSummary(\n      IMangrove(payable(mgv)),\n      base,\n      quote,\n      $(this),\n      false,\n      0,\n      0,\n      0,\n      4 // TODO when checkEmit is available, get offer id after post\n    );\n    mgo.take{value: 0.1 ether}(buyOrder);\n    expectFrom($(mgo));\n    emit OrderSummary(\n      IMangrove(payable(mgv)),\n      base,\n      quote,\n      $(this),\n      false,\n      0,\n      0,\n      0,\n      5 // TODO when checkEmit is available, get offer id after post\n    );\n    mgo.take{value: 0.1 ether}(buyOrder);\n    (uint[] memory live, uint[] memory dead) = mgo.offersOfOwner(\n      $(this),\n      quote,\n      base\n    );\n    assertTrue(live.length == 2 && dead.length == 0, \"Incorrect offer list\");\n    mgo.retractOffer(quote, base, live[0], false);\n    (live, dead) = mgo.offersOfOwner($(this), quote, base);\n    assertTrue(\n      live.length == 1 && dead.length == 1,\n      \"Incorrect offer list after retract\"\n    );\n  }\n}\n"
    },
    "contracts/periphery/MangroveOrderEnriched.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Persistent.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"./MangroveOrder.sol\";\n\ncontract MangroveOrderEnriched is MangroveOrder {\n  // `next[out_tkn][in_tkn][owner][id] = id'` with `next[out_tkn][in_tkn][owner][0]==0` iff owner has now offers on the semi book (out,in)\n  mapping(IERC20 => mapping(IERC20 => mapping(address => mapping(uint => uint)))) next;\n\n  constructor(IMangrove _MGV, address deployer) MangroveOrder(_MGV, deployer) {}\n\n  function __logOwnerShipRelation__(\n    address owner,\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId\n  ) internal virtual override {\n    uint head = next[outbound_tkn][inbound_tkn][owner][0];\n    next[outbound_tkn][inbound_tkn][owner][0] = offerId;\n    if (head != 0) {\n      next[outbound_tkn][inbound_tkn][owner][offerId] = head;\n    }\n  }\n\n  // we let the following view function consume loads of gas units in exchange of a rather minimalistic state bookeeping\n  function offersOfOwner(\n    address owner,\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn\n  ) external view returns (uint[] memory live, uint[] memory dead) {\n    uint head = next[outbound_tkn][inbound_tkn][owner][0];\n    uint id = head;\n    uint n_live = 0;\n    uint n_dead = 0;\n    while (id != 0) {\n      if (MGV.isLive(MGV.offers($(outbound_tkn), $(inbound_tkn), id))) {\n        n_live++;\n      } else {\n        n_dead++;\n      }\n      id = next[outbound_tkn][inbound_tkn][owner][id];\n    }\n    live = new uint[](n_live);\n    dead = new uint[](n_dead);\n    id = head;\n    n_live = 0;\n    n_dead = 0;\n    while (id != 0) {\n      if (MGV.isLive(MGV.offers($(outbound_tkn), $(inbound_tkn), id))) {\n        live[n_live++] = id;\n      } else {\n        dead[n_dead++] = id;\n      }\n      id = next[outbound_tkn][inbound_tkn][owner][id];\n    }\n    return (live, dead);\n  }\n}\n"
    },
    "contracts/strategies/interfaces/IOrderLogic.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SwingingMarketMaker.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity >=0.8.0;\npragma abicoder v2;\nimport \"contracts/IMangrove.sol\";\nimport {IERC20} from \"contracts/MgvLib.sol\";\n\ninterface IOrderLogic {\n  struct TakerOrder {\n    IERC20 base; //identifying Mangrove market\n    IERC20 quote;\n    bool partialFillNotAllowed; //revert if taker order cannot be filled and resting order failed or is not enabled\n    bool selling; // whether this is a selling order (otherwise a buy order)\n    uint wants; // if `selling` amount of quote tokens, otherwise amount of base tokens\n    uint makerWants; // taker wants before slippage (`makerWants == wants` when `!selling`)\n    uint gives; // if `selling` amount of base tokens, otherwise amount of quote tokens\n    uint makerGives; // taker gives before slippage (`makerGives == gives` when `selling`)\n    bool restingOrder; // whether the complement of the partial fill (if any) should be posted as a resting limit order\n    uint retryNumber; // number of times filling the taker order should be retried (0 means 1 attempt).\n    uint gasForMarketOrder; // gas limit per market order attempt\n    uint blocksToLiveForRestingOrder; // number of blocks the resting order should be allowed to live, 0 means forever\n  }\n\n  struct TakerOrderResult {\n    uint takerGot;\n    uint takerGave;\n    uint bounty;\n    uint fee;\n    uint offerId;\n  }\n\n  event OrderSummary(\n    IMangrove mangrove,\n    IERC20 indexed base,\n    IERC20 indexed quote,\n    address indexed taker,\n    bool selling,\n    uint takerGot,\n    uint takerGave,\n    uint penalty,\n    uint restingOrderId\n  );\n\n  function expiring(\n    IERC20,\n    IERC20,\n    uint\n  ) external returns (uint);\n\n  function take(TakerOrder memory)\n    external\n    payable\n    returns (TakerOrderResult memory);\n}\n"
    },
    "contracts/periphery/MangroveOrder.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Persistent.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/multi_user/abstract/Persistent.sol\";\nimport \"contracts/strategies/interfaces/IOrderLogic.sol\";\nimport \"contracts/strategies/routers/SimpleRouter.sol\";\n\ncontract MangroveOrder is MultiUserPersistent, IOrderLogic {\n  // `blockToLive[token1][token2][offerId]` gives block number beyond which the offer should renege on trade.\n  mapping(IERC20 => mapping(IERC20 => mapping(uint => uint))) public expiring;\n\n  constructor(IMangrove _MGV, address deployer)\n    MultiUserPersistent(_MGV, new SimpleRouter(), 90_000)\n  {\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n      router().setAdmin(deployer);\n    }\n  }\n\n  // transfer with no revert\n\n  function __lastLook__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool)\n  {\n    uint exp = expiring[IERC20(order.outbound_tkn)][IERC20(order.inbound_tkn)][\n      order.offerId\n    ];\n    return (exp == 0 || block.number <= exp);\n  }\n\n  // revert when order was partially filled and it is not allowed\n  function checkCompleteness(\n    TakerOrder calldata tko,\n    TakerOrderResult memory res\n  ) internal pure returns (bool isPartial) {\n    // revert if sell is partial and `partialFillNotAllowed` and not posting residual\n    if (tko.selling) {\n      return res.takerGave >= tko.gives;\n    } else {\n      return res.takerGot + res.fee >= tko.wants;\n    }\n  }\n\n  // `this` contract MUST have approved Mangrove for inbound token transfer\n  // `msg.sender` MUST have approved `this` contract for at least the same amount\n  // provision for posting a resting order MAY be sent when calling this function\n  // gasLimit of this `tx` MUST be at least `(retryNumber+1)*gasForMarketOrder`\n  // msg.value SHOULD contain enough native token to cover for the resting order provision\n  // msg.value MUST be 0 if `!restingOrder` otherwise tranfered WEIs are burnt.\n\n  function take(TakerOrder calldata tko)\n    external\n    payable\n    returns (TakerOrderResult memory res)\n  {\n    (IERC20 outbound_tkn, IERC20 inbound_tkn) = tko.selling\n      ? (tko.quote, tko.base)\n      : (tko.base, tko.quote);\n    // pulling directly from msg.sender would require caller to approve `this` in addition to the `this.router()`\n    // so pulling funds from taker's reserve (note this can be the taker's wallet depending on the router)\n    uint pulled = router().pull(inbound_tkn, msg.sender, tko.gives, true);\n    require(pulled == tko.gives, \"mgvOrder/mo/transferInFail\");\n    // passing an iterated market order with the transfered funds\n    for (uint i = 0; i < tko.retryNumber + 1; i++) {\n      if (tko.gasForMarketOrder != 0 && gasleft() < tko.gasForMarketOrder) {\n        break;\n      }\n      (uint takerGot_, uint takerGave_, uint bounty_, uint fee_) = MGV\n        .marketOrder({\n          outbound_tkn: $(outbound_tkn), // expecting quote (outbound) when selling\n          inbound_tkn: $(inbound_tkn),\n          takerWants: tko.wants, // `tko.wants` includes user defined slippage\n          takerGives: tko.gives,\n          fillWants: tko.selling ? false : true // only buy order should try to fill takerWants\n        });\n      res.takerGot += takerGot_;\n      res.takerGave += takerGave_;\n      res.bounty += bounty_;\n      res.fee += fee_;\n      if (takerGot_ == 0 && bounty_ == 0) {\n        break;\n      }\n    }\n    bool isComplete = checkCompleteness(tko, res);\n    // requiring `partialFillNotAllowed` => `isComplete \\/ restingOrder`\n    require(\n      !tko.partialFillNotAllowed || isComplete || tko.restingOrder,\n      \"mgvOrder/mo/noPartialFill\"\n    );\n\n    // sending received tokens to taker's reserve\n    if (res.takerGot > 0) {\n      router().push(outbound_tkn, msg.sender, res.takerGot);\n    }\n\n    // at this points the following invariants hold:\n    // 1. taker received `takerGot` outbound tokens\n    // 2. `this` contract inbound token balance is now equal to `tko.gives - takerGave`.\n    // NB: this amount cannot be redeemed by taker since `creditToken` was not called\n    // 3. `this` contract's WEI balance is credited of `msg.value + bounty`\n\n    if (tko.restingOrder && !isComplete) {\n      // resting limit order for the residual of the taker order\n      // this call will credit offer owner virtual account on Mangrove with msg.value before trying to post the offer\n      // `offerId_==0` if mangrove rejects the update because of low density.\n      // If user does not have enough funds, call will revert\n      res.offerId = newOfferInternal({\n        mko: MakerOrder({\n          outbound_tkn: inbound_tkn,\n          inbound_tkn: outbound_tkn,\n          wants: tko.makerWants - (res.takerGot + res.fee), // tko.makerWants is before slippage\n          gives: tko.makerGives - res.takerGave,\n          gasreq: ofr_gasreq(),\n          gasprice: 0,\n          pivotId: 0,\n          offerId: 0 // irrelevant for new offer\n        }), // offer should be best in the book\n        owner: msg.sender,\n        provision: msg.value\n      });\n\n      // if one wants to maintain an inverse mapping owner => offerIds\n      __logOwnerShipRelation__({\n        owner: msg.sender,\n        outbound_tkn: inbound_tkn,\n        inbound_tkn: outbound_tkn,\n        offerId: res.offerId\n      });\n\n      emit OrderSummary({\n        mangrove: MGV,\n        base: tko.base,\n        quote: tko.quote,\n        selling: tko.selling,\n        taker: msg.sender,\n        takerGot: res.takerGot,\n        takerGave: res.takerGave,\n        penalty: res.bounty,\n        restingOrderId: res.offerId\n      });\n\n      if (res.offerId == 0) {\n        // unable to post resting order\n        // reverting when partial fill is not an option\n        require(!tko.partialFillNotAllowed, \"mgvOrder/mo/noPartialFill\");\n        // sending partial fill to taker --when partial fill is allowed\n        require(\n          TransferLib.transferToken(\n            inbound_tkn,\n            msg.sender,\n            tko.gives - res.takerGave\n          ),\n          \"mgvOrder/mo/transferInFail\"\n        );\n        // msg.value is no longer needed so sending it back to msg.sender along with possible collected bounty\n        if (msg.value + res.bounty > 0) {\n          (bool noRevert, ) = msg.sender.call{value: msg.value + res.bounty}(\n            \"\"\n          );\n          require(noRevert, \"mgvOrder/mo/refundProvisionFail\");\n        }\n        return res;\n      } else {\n        // offer was successfully posted\n        // crediting caller's balance with amount of offered tokens (transfered from caller at the begining of this function)\n        // NB `inbount_tkn` is now the outbound token for the resting order\n        router().push(inbound_tkn, msg.sender, tko.gives - res.takerGave);\n\n        // setting a time to live for the resting order\n        if (tko.blocksToLiveForRestingOrder > 0) {\n          expiring[inbound_tkn][outbound_tkn][res.offerId] =\n            block.number +\n            tko.blocksToLiveForRestingOrder;\n        }\n        return res;\n      }\n    } else {\n      // either fill was complete or taker does not want to post residual as a resting order\n      // transfering remaining inbound tokens to msg.sender\n      router().push(inbound_tkn, msg.sender, tko.gives - res.takerGave);\n\n      // transfering potential bounty and msg.value back to the taker\n      if (msg.value + res.bounty > 0) {\n        // NB this calls gives reentrancy power to caller\n        (bool noRevert, ) = msg.sender.call{value: msg.value + res.bounty}(\"\");\n        require(noRevert, \"mgvOrder/mo/refundFail\");\n      }\n      emit OrderSummary({\n        mangrove: MGV,\n        base: tko.base,\n        quote: tko.quote,\n        selling: tko.selling,\n        taker: msg.sender,\n        takerGot: res.takerGot,\n        takerGave: res.takerGave,\n        penalty: res.bounty,\n        restingOrderId: 0\n      });\n      return res;\n    }\n  }\n\n  function __posthookSuccess__(ML.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool noFailure)\n  {\n    noFailure = super.__posthookSuccess__(order);\n    if (!noFailure) {\n      // if offer failed to be reposted, if is now off the book but provision is still locked\n      retractOffer(\n        IERC20(order.outbound_tkn),\n        IERC20(order.inbound_tkn),\n        order.offerId,\n        true\n      );\n    }\n  }\n\n  function __logOwnerShipRelation__(\n    address owner,\n    IERC20 outbound_tkn,\n    IERC20 inbound_tkn,\n    uint offerId\n  ) internal virtual {\n    owner; //ssh\n    outbound_tkn; //ssh\n    inbound_tkn; //ssh\n    offerId; //ssh\n  }\n}\n"
    },
    "contracts/strategies/integrations/CompoundModule.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// CompoundModule.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/interfaces/ICompound.sol\";\nimport \"contracts/strategies/vendor/compound/Exponential.sol\";\nimport \"contracts/IMangrove.sol\";\nimport {IERC20} from \"contracts/MgvLib.sol\";\n\ninterface WETH is IERC20 {\n  function deposit() external payable;\n\n  function withdraw(uint) external;\n}\n\n// TODO-foundry-merge explain what this contract does\n\ncontract CompoundModule is Exponential {\n  event ErrorOnRedeem(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    uint errorCode\n  );\n  event ErrorOnMint(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    uint errorCode\n  );\n\n  event ComptrollerError(address comp, uint errorCode);\n\n  // mapping : ERC20 -> cERC20\n  mapping(IERC20 => IcERC20) overlyings;\n\n  // address of the comptroller\n  IComptroller public immutable comptroller;\n\n  // address of the price oracle used by the comptroller\n  ICompoundPriceOracle public immutable oracle;\n\n  WETH immutable weth;\n\n  constructor(address _unitroller, address wethAddress) {\n    comptroller = IComptroller(_unitroller); // unitroller is a proxy for comptroller calls\n    require(_unitroller != address(0), \"Invalid comptroller address\");\n    ICompoundPriceOracle _oracle = IComptroller(_unitroller).oracle(); // pricefeed used by the comptroller\n    require(address(_oracle) != address(0), \"Failed to get price oracle\");\n    oracle = _oracle;\n    weth = WETH(wethAddress);\n  }\n\n  function isCeth(IcERC20 ctoken) internal view returns (bool) {\n    return (keccak256(abi.encodePacked(ctoken.symbol())) ==\n      keccak256(abi.encodePacked(\"cETH\")));\n  }\n\n  //dealing with cEth special case\n  function underlying(IcERC20 ctoken) internal view returns (IERC20) {\n    require(ctoken.isCToken(), \"Invalid ctoken address\");\n    if (isCeth(ctoken)) {\n      // cETH has no underlying() function...\n      return IERC20(weth);\n    } else {\n      return IERC20(ctoken.underlying());\n    }\n  }\n\n  function _approveLender(IcERC20 ctoken, uint amount) internal returns (bool) {\n    IERC20 token = underlying(ctoken);\n    return token.approve(address(ctoken), amount);\n  }\n\n  function _enterMarkets(address[] calldata ctokens) internal {\n    uint[] memory results = comptroller.enterMarkets(ctokens);\n    for (uint i = 0; i < ctokens.length; i++) {\n      require(results[i] == 0, \"Failed to enter market\");\n      IERC20 token = underlying(IcERC20(ctokens[i]));\n      // adding ctoken.underlying --> ctoken mapping\n      overlyings[token] = IcERC20(ctokens[i]);\n    }\n  }\n\n  function _exitMarket(IcERC20 ctoken) internal {\n    require(\n      comptroller.exitMarket(address(ctoken)) == 0,\n      \"failed to exit marker\"\n    );\n  }\n\n  function _claimComp() internal {\n    comptroller.claimComp(address(this));\n  }\n\n  function isPooled(IERC20 token) public view returns (bool) {\n    IcERC20 ctoken = overlyings[token];\n    return comptroller.checkMembership(address(this), ctoken);\n  }\n\n  /// @notice struct to circumvent stack too deep error in `maxGettableUnderlying` function\n  struct Heap {\n    uint ctokenBalance;\n    uint cDecimals;\n    uint decimals;\n    uint exchangeRateMantissa;\n    uint liquidity;\n    uint collateralFactorMantissa;\n    uint maxRedeemable;\n    uint balanceOfUnderlying;\n    uint priceMantissa;\n    uint underlyingLiquidity;\n    MathError mErr;\n    uint errCode;\n  }\n\n  function heapError(Heap memory heap) private pure returns (bool) {\n    return (heap.errCode != 0 || heap.mErr != MathError.NO_ERROR);\n  }\n\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\n  /// returns (R, B|R)\n  function maxGettableUnderlying(address _ctoken, address account)\n    public\n    view\n    returns (uint, uint)\n  {\n    IcERC20 ctoken = IcERC20(_ctoken);\n    Heap memory heap;\n    // NB balance below is underestimated unless accrue interest was triggered earlier in the transaction\n    (heap.errCode, heap.ctokenBalance, , heap.exchangeRateMantissa) = ctoken\n      .getAccountSnapshot(address(this)); // underapprox\n    heap.priceMantissa = oracle.getUnderlyingPrice(ctoken); //18 decimals\n\n    // balanceOfUnderlying(A) : cA.balance * exchange_rate(cA,A)\n\n    (heap.mErr, heap.balanceOfUnderlying) = mulScalarTruncate(\n      Exp({mantissa: heap.exchangeRateMantissa}),\n      heap.ctokenBalance // ctokens have 8 decimals precision\n    );\n\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n\n    // max amount of outbound_Tkn token than can be borrowed\n    (\n      heap.errCode,\n      heap.liquidity, // is USD:18 decimals\n      /*shortFall*/\n\n    ) = comptroller.getAccountLiquidity(account); // underapprox\n\n    // to get liquidity expressed in outbound_Tkn token instead of USD\n    (heap.mErr, heap.underlyingLiquidity) = divScalarByExpTruncate(\n      heap.liquidity,\n      Exp({mantissa: heap.priceMantissa})\n    );\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n    (, heap.collateralFactorMantissa, ) = comptroller.markets(address(ctoken));\n\n    // if collateral factor is 0 then any token can be redeemed from the pool w/o impacting borrow power\n    // also true if market is not entered\n    if (\n      heap.collateralFactorMantissa == 0 ||\n      !comptroller.checkMembership(account, ctoken)\n    ) {\n      return (heap.balanceOfUnderlying, heap.underlyingLiquidity);\n    }\n\n    // maxRedeem:[underlying] = liquidity:[USD / 18 decimals ] / (price(outbound_tkn):[USD.underlying^-1 / 18 decimals] * collateralFactor(outbound_tkn): [0-1] 18 decimals)\n    (heap.mErr, heap.maxRedeemable) = divScalarByExpTruncate(\n      heap.liquidity,\n      mul_(\n        Exp({mantissa: heap.collateralFactorMantissa}),\n        Exp({mantissa: heap.priceMantissa})\n      )\n    );\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n    heap.maxRedeemable = min(heap.maxRedeemable, heap.balanceOfUnderlying);\n    // B|R = B - R*CF\n    return (\n      heap.maxRedeemable,\n      sub_(\n        heap.underlyingLiquidity, //borrow power\n        mul_ScalarTruncate(\n          Exp({mantissa: heap.collateralFactorMantissa}),\n          heap.maxRedeemable\n        )\n      )\n    );\n  }\n\n  function compoundRedeem(uint amountToRedeem, ML.SingleOrder calldata order)\n    internal\n    returns (uint)\n  {\n    IcERC20 outbound_cTkn = overlyings[IERC20(order.outbound_tkn)]; // this is 0x0 if outbound_tkn is not compound sourced.\n    if (address(outbound_cTkn) == address(0)) {\n      return amountToRedeem;\n    }\n    uint errorCode = outbound_cTkn.redeemUnderlying(amountToRedeem); // accrues interests\n    if (errorCode == 0) {\n      //compound redeem was a success\n      // if ETH was redeemed, one needs to convert them into wETH\n      if (isCeth(outbound_cTkn)) {\n        weth.deposit{value: amountToRedeem}();\n      }\n      return 0;\n    } else {\n      //compound redeem failed\n      emit ErrorOnRedeem(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amountToRedeem,\n        errorCode\n      );\n      return amountToRedeem;\n    }\n  }\n\n  function _mint(uint amount, IcERC20 ctoken) internal returns (uint errCode) {\n    if (isCeth(ctoken)) {\n      // turning `amount` of wETH into ETH\n      try weth.withdraw(amount) {\n        // minting amount of ETH into cETH\n        ctoken.mint{value: amount}();\n      } catch {\n        if (amount == weth.balanceOf(address(this))) {}\n        require(false);\n      }\n    } else {\n      // Approve transfer on the ERC20 contract (not needed if cERC20 is already approved for `this`)\n      // IERC20(ctoken.underlying()).approve(ctoken, amount);\n      errCode = ctoken.mint(amount); // accrues interest\n    }\n  }\n\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\n  // utility to supply erc20 to compound\n  function compoundMint(uint amount, ML.SingleOrder calldata order)\n    internal\n    returns (uint missing)\n  {\n    IcERC20 ctoken = overlyings[IERC20(order.inbound_tkn)];\n    uint errCode = _mint(amount, ctoken);\n    // Mint ctokens\n    if (errCode != 0) {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        errCode\n      );\n      missing = amount;\n    }\n  }\n}\n"
    },
    "contracts/strategies/interfaces/ICompound.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n// ICompound.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport {IERC20} from \"contracts/MgvLib.sol\";\n\ninterface ICompoundPriceOracle {\n  function getUnderlyingPrice(IcERC20 cToken) external view returns (uint);\n}\n\ninterface IComptroller {\n  // adding usefull public getters\n  function oracle() external returns (ICompoundPriceOracle priceFeed);\n\n  function markets(address cToken)\n    external\n    view\n    returns (\n      bool isListed,\n      uint collateralFactorMantissa,\n      bool isComped\n    );\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens)\n    external\n    returns (uint[] memory);\n\n  function exitMarket(address cToken) external returns (uint);\n\n  function getAccountLiquidity(address user)\n    external\n    view\n    returns (\n      uint errorCode,\n      uint liquidity,\n      uint shortfall\n    );\n\n  function claimComp(address holder) external;\n\n  function checkMembership(address account, IcERC20 cToken)\n    external\n    view\n    returns (bool);\n}\n\ninterface IcERC20 is IERC20 {\n  // from https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol\n  function redeem(uint withdrawTokens) external returns (uint);\n\n  function borrow(uint borrowAmount) external returns (uint);\n\n  // for non cETH only\n  function repayBorrow(uint repayAmount) external returns (uint);\n\n  // for cETH only\n  function repayBorrow() external payable;\n\n  // for non cETH only\n  function repayBorrowBehalf(address borrower, uint repayAmount)\n    external\n    returns (uint);\n\n  // for cETH only\n  function repayBorrowBehalf(address borrower) external payable;\n\n  function balanceOfUnderlying(address owner) external returns (uint);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    );\n\n  function borrowRatePerBlock() external view returns (uint);\n\n  function supplyRatePerBlock() external view returns (uint);\n\n  function totalBorrowsCurrent() external returns (uint);\n\n  function borrowBalanceCurrent(address account) external returns (uint);\n\n  function borrowBalanceStored(address account) external view returns (uint);\n\n  function exchangeRateCurrent() external returns (uint);\n\n  function exchangeRateStored() external view returns (uint);\n\n  function getCash() external view returns (uint);\n\n  function accrueInterest() external returns (uint);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) external returns (uint);\n\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n  function mint(uint mintAmount) external returns (uint);\n\n  // only in cETH\n  function mint() external payable;\n\n  // non cETH only\n  function underlying() external view returns (address); // access to public variable containing the address of the underlying ERC20\n\n  function isCToken() external view returns (bool); // public constant froim CTokenInterfaces.sol\n}\n"
    },
    "contracts/strategies/vendor/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n  /**\n   * @dev Creates an exponential from numerator and denominator values.\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n   *            or if `denom` is zero.\n   */\n  function getExp(uint num, uint denom)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: rational}));\n  }\n\n  /**\n   * @dev Adds two exponentials, returning a new exponential.\n   */\n  function addExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({mantissa: result}));\n  }\n\n  /**\n   * @dev Subtracts two exponentials, returning a new exponential.\n   */\n  function subExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({mantissa: result}));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\n   */\n  function mulScalar(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mulScalarTruncate(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (MathError, uint)\n  {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(product));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mulScalarTruncateAddUInt(\n    Exp memory a,\n    uint scalar,\n    uint addend\n  ) internal pure returns (MathError, uint) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return addUInt(truncate(product), addend);\n  }\n\n  /**\n   * @dev Divide an Exp by a scalar, returning a new Exp.\n   */\n  function divScalar(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, returning a new Exp.\n   */\n  function divScalarByExp(uint scalar, Exp memory divisor)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n    (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n    return getExp(numerator, divisor.mantissa);\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n   */\n  function divScalarByExpTruncate(uint scalar, Exp memory divisor)\n    internal\n    pure\n    returns (MathError, uint)\n  {\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(fraction));\n  }\n\n  /**\n   * @dev Multiplies two exponentials, returning a new exponential.\n   */\n  function mulExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    (MathError err0, uint doubleScaledProduct) = mulUInt(\n      a.mantissa,\n      b.mantissa\n    );\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    // We add half the scale before dividing so that we get rounding instead of truncation.\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n    (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(\n      halfExpScale,\n      doubleScaledProduct\n    );\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({mantissa: 0}));\n    }\n\n    (MathError err2, uint product) = divUInt(\n      doubleScaledProductWithHalfScale,\n      expScale\n    );\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n    assert(err2 == MathError.NO_ERROR);\n\n    return (MathError.NO_ERROR, Exp({mantissa: product}));\n  }\n\n  /**\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n   */\n  function mulExp(uint a, uint b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n  }\n\n  /**\n   * @dev Multiplies three exponentials, returning a new exponential.\n   */\n  function mulExp3(\n    Exp memory a,\n    Exp memory b,\n    Exp memory c\n  ) internal pure returns (MathError, Exp memory) {\n    (MathError err, Exp memory ab) = mulExp(a, b);\n    if (err != MathError.NO_ERROR) {\n      return (err, ab);\n    }\n    return mulExp(ab, c);\n  }\n\n  /**\n   * @dev Divides two exponentials, returning a new exponential.\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n   */\n  function divExp(Exp memory a, Exp memory b)\n    internal\n    pure\n    returns (MathError, Exp memory)\n  {\n    return getExp(a.mantissa, b.mantissa);\n  }\n}\n"
    },
    "contracts/strategies/vendor/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n  /**\n   * @dev Possible error codes that we can return\n   */\n  enum MathError {\n    NO_ERROR,\n    DIVISION_BY_ZERO,\n    INTEGER_OVERFLOW,\n    INTEGER_UNDERFLOW\n  }\n\n  /**\n   * @dev Multiplies two numbers, returns an error on overflow.\n   */\n  function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    if (a == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    uint c = a * b;\n\n    if (c / a != b) {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    } else {\n      return (MathError.NO_ERROR, c);\n    }\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    if (b == 0) {\n      return (MathError.DIVISION_BY_ZERO, 0);\n    }\n\n    return (MathError.NO_ERROR, a / b);\n  }\n\n  /**\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    if (b <= a) {\n      return (MathError.NO_ERROR, a - b);\n    } else {\n      return (MathError.INTEGER_UNDERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev Adds two numbers, returns an error on overflow.\n   */\n  function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n    uint c = a + b;\n\n    if (c >= a) {\n      return (MathError.NO_ERROR, c);\n    } else {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev add a and b and then subtract c\n   */\n  function addThenSubUInt(\n    uint a,\n    uint b,\n    uint c\n  ) internal pure returns (MathError, uint) {\n    (MathError err0, uint sum) = addUInt(a, b);\n\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, 0);\n    }\n\n    return subUInt(sum, c);\n  }\n\n  /**\n   * @dev min and max functions\n   */\n  function min(uint a, uint b) internal pure returns (uint) {\n    return (a < b ? a : b);\n  }\n\n  function max(uint a, uint b) internal pure returns (uint) {\n    return (a > b ? a : b);\n  }\n\n  uint constant MAXUINT = type(uint).max;\n  uint constant MAXUINT96 = type(uint96).max;\n  uint constant MAXUINT24 = type(uint24).max;\n}\n"
    },
    "contracts/strategies/vendor/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint constant expScale = 1e18;\n  uint constant doubleScale = 1e36;\n  uint constant halfExpScale = expScale / 2;\n  uint constant mantissaOne = expScale;\n\n  struct Exp {\n    uint mantissa;\n  }\n\n  struct Double {\n    uint mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint scalar)\n    internal\n    pure\n    returns (uint)\n  {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint scalar,\n    uint addend\n  ) internal pure returns (uint) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right)\n    internal\n    pure\n    returns (bool)\n  {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right)\n    internal\n    pure\n    returns (bool)\n  {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right)\n    internal\n    pure\n    returns (bool)\n  {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint n, string memory errorMessage)\n    internal\n    pure\n    returns (uint224)\n  {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint n, string memory errorMessage)\n    internal\n    pure\n    returns (uint32)\n  {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(uint a, uint b) internal pure returns (uint) {\n    return add_(a, b, \"addition overflow\");\n  }\n\n  function add_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(uint a, uint b) internal pure returns (uint) {\n    return sub_(a, b, \"subtraction underflow\");\n  }\n\n  function sub_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n  }\n\n  function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Exp memory b) internal pure returns (uint) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n  }\n\n  function mul_(Double memory a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Double memory b) internal pure returns (uint) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint a, uint b) internal pure returns (uint) {\n    return mul_(a, b, \"multiplication overflow\");\n  }\n\n  function mul_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n  }\n\n  function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Exp memory b) internal pure returns (uint) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b)\n    internal\n    pure\n    returns (Double memory)\n  {\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n  }\n\n  function div_(Double memory a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Double memory b) internal pure returns (uint) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint a, uint b) internal pure returns (uint) {\n    return div_(a, b, \"divide by zero\");\n  }\n\n  function div_(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\n  }\n}\n"
    },
    "contracts/strategies/integrations/AaveV2Module.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/vendor/aave/v2/ILendingPool.sol\";\nimport \"contracts/strategies/vendor/aave/v2/ILendingPoolAddressesProvider.sol\";\nimport \"contracts/strategies/vendor/aave/v2/IPriceOracleGetter.sol\";\nimport \"contracts/strategies/vendor/compound/Exponential.sol\";\nimport \"contracts/IMangrove.sol\";\nimport {IERC20} from \"contracts/MgvLib.sol\";\n\ncontract AaveModule is Exponential {\n  event ErrorOnRedeem(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n  event ErrorOnMint(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint indexed offerId,\n    uint amount,\n    string errorCode\n  );\n\n  // address of the lendingPool\n  ILendingPool public immutable lendingPool;\n  IPriceOracleGetter public immutable priceOracle;\n  uint16 referralCode;\n\n  constructor(address _addressesProvider, uint _referralCode) {\n    require(\n      uint16(_referralCode) == _referralCode,\n      \"Referral code should be uint16\"\n    );\n    referralCode = uint16(referralCode); // for aave reference, put 0 for tests\n    address _lendingPool = ILendingPoolAddressesProvider(_addressesProvider)\n      .getLendingPool();\n    address _priceOracle = ILendingPoolAddressesProvider(_addressesProvider)\n      .getPriceOracle();\n    require(_lendingPool != address(0), \"Invalid lendingPool address\");\n    require(_priceOracle != address(0), \"Invalid priceOracle address\");\n    lendingPool = ILendingPool(_lendingPool);\n    priceOracle = IPriceOracleGetter(_priceOracle);\n  }\n\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  ///@notice approval of overlying contract by the underlying is necessary for minting and repaying borrow\n  ///@notice user must use this function to do so.\n  function _approveLender(IERC20 token, uint amount) internal {\n    token.approve(address(lendingPool), amount);\n  }\n\n  ///@notice exits markets\n  function _exitMarket(IERC20 underlying) internal {\n    lendingPool.setUserUseReserveAsCollateral(address(underlying), false);\n  }\n\n  function _enterMarkets(IERC20[] calldata underlyings) internal {\n    for (uint i = 0; i < underlyings.length; i++) {\n      lendingPool.setUserUseReserveAsCollateral(address(underlyings[i]), true);\n    }\n  }\n\n  function overlying(IERC20 asset) public view returns (IERC20 aToken) {\n    aToken = IERC20(lendingPool.getReserveData(address(asset)).aTokenAddress);\n  }\n\n  // structs to avoir stack too deep in maxGettableUnderlying\n  struct Underlying {\n    uint ltv;\n    uint liquidationThreshold;\n    uint decimals;\n    uint price;\n  }\n\n  struct Account {\n    uint collateral;\n    uint debt;\n    uint borrowPower;\n    uint redeemPower;\n    uint ltv;\n    uint liquidationThreshold;\n    uint health;\n    uint balanceOfUnderlying;\n  }\n\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\n  /// returns (R, B|R)\n\n  function maxGettableUnderlying(\n    IERC20 asset,\n    bool tryBorrow,\n    address onBehalf\n  ) public view returns (uint, uint) {\n    Underlying memory underlying; // asset parameters\n    Account memory account; // accound parameters\n    (\n      account.collateral,\n      account.debt,\n      account.borrowPower, // avgLtv * sumCollateralEth - sumDebtEth\n      account.liquidationThreshold,\n      account.ltv,\n      account.health // avgLiquidityThreshold * sumCollateralEth / sumDebtEth  -- should be less than 10**18\n    ) = lendingPool.getUserAccountData(onBehalf);\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      address(asset)\n    );\n    (\n      underlying.ltv, // collateral factor for lending\n      underlying.liquidationThreshold, // collateral factor for borrowing\n      ,\n      /*liquidationBonus*/\n      underlying.decimals,\n      /*reserveFactor*/\n\n    ) = DataTypes.getParams(reserveData.configuration);\n    account.balanceOfUnderlying = IERC20(reserveData.aTokenAddress).balanceOf(\n      onBehalf\n    );\n\n    underlying.price = priceOracle.getAssetPrice(address(asset)); // divided by 10**underlying.decimals\n\n    // account.redeemPower = account.liquidationThreshold * account.collateral - account.debt\n    account.redeemPower = sub_(\n      div_(mul_(account.liquidationThreshold, account.collateral), 10**4),\n      account.debt\n    );\n    // max redeem capacity = account.redeemPower/ underlying.liquidationThreshold * underlying.price\n    // unless account doesn't have enough collateral in asset token (hence the min())\n\n    uint maxRedeemableUnderlying = div_( // in 10**underlying.decimals\n      account.redeemPower * 10**(underlying.decimals) * 10**4,\n      mul_(underlying.liquidationThreshold, underlying.price)\n    );\n\n    maxRedeemableUnderlying = min(\n      maxRedeemableUnderlying,\n      account.balanceOfUnderlying\n    );\n\n    if (!tryBorrow) {\n      //gas saver\n      return (maxRedeemableUnderlying, 0);\n    }\n    // computing max borrow capacity on the premisses that maxRedeemableUnderlying has been redeemed.\n    // max borrow capacity = (account.borrowPower - (ltv*redeemed)) / underlying.ltv * underlying.price\n\n    uint borrowPowerImpactOfRedeemInUnderlying = div_(\n      mul_(maxRedeemableUnderlying, underlying.ltv),\n      10**4\n    );\n    uint borrowPowerInUnderlying = div_(\n      mul_(account.borrowPower, 10**underlying.decimals),\n      underlying.price\n    );\n\n    if (borrowPowerImpactOfRedeemInUnderlying > borrowPowerInUnderlying) {\n      // no more borrowPower left after max redeem operation\n      return (maxRedeemableUnderlying, 0);\n    }\n\n    uint maxBorrowAfterRedeemInUnderlying = sub_( // max borrow power in underlying after max redeem has been withdrawn\n      borrowPowerInUnderlying,\n      borrowPowerImpactOfRedeemInUnderlying\n    );\n    return (maxRedeemableUnderlying, maxBorrowAfterRedeemInUnderlying);\n  }\n\n  function aaveRedeem(\n    uint amountToRedeem,\n    address onBehalf,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    try\n      lendingPool.withdraw(order.outbound_tkn, amountToRedeem, onBehalf)\n    returns (uint withdrawn) {\n      //aave redeem was a success\n      if (amountToRedeem == withdrawn) {\n        return 0;\n      } else {\n        return (amountToRedeem - withdrawn);\n      }\n    } catch Error(string memory message) {\n      emit ErrorOnRedeem(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amountToRedeem,\n        message\n      );\n      return amountToRedeem;\n    }\n  }\n\n  function _supply(\n    uint amount,\n    address token,\n    address onBehalf\n  ) internal {\n    lendingPool.deposit(token, amount, onBehalf, referralCode);\n  }\n\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\n  // utility to supply erc20 to compound\n  // NB `ctoken` contract MUST be approved to perform `transferFrom token` by `this` contract.\n  /// @notice user need to approve ctoken in order to mint\n  function aaveMint(\n    uint amount,\n    address onBehalf,\n    ML.SingleOrder calldata order\n  ) internal returns (uint) {\n    // contract must haveallowance()to spend funds on behalf ofmsg.sender for at-leastamount for the asset being deposited. This can be done via the standard ERC20 approve() method.\n    try lendingPool.deposit(order.inbound_tkn, amount, onBehalf, referralCode) {\n      return 0;\n    } catch Error(string memory message) {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        message\n      );\n    } catch {\n      emit ErrorOnMint(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        amount,\n        \"unexpected\"\n      );\n    }\n    return amount;\n  }\n}\n"
    },
    "contracts/strategies/vendor/aave/v2/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\npragma solidity >=0.6.12;\npragma abicoder v2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(\n    address indexed reserve,\n    address indexed user,\n    address indexed to,\n    uint amount\n  );\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint amount,\n    uint borrowRateMode,\n    uint borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(\n    address indexed reserve,\n    address indexed user\n  );\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint amount,\n    uint premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint debtToCover,\n    uint liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint liquidityRate,\n    uint stableBorrowRate,\n    uint variableBorrowRate,\n    uint liquidityIndex,\n    uint variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint amount,\n    address to\n  ) external returns (uint);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint amount,\n    uint interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint amount,\n    uint rateMode,\n    address onBehalfOf\n  ) external returns (uint);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n    external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint[] calldata amounts,\n    uint[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint totalCollateralETH,\n      uint totalDebtETH,\n      uint availableBorrowsETH,\n      uint currentLiquidationThreshold,\n      uint ltv,\n      uint healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(\n    address reserve,\n    address rateStrategyAddress\n  ) external;\n\n  function setConfiguration(address reserve, uint configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    view\n    returns (uint);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    view\n    returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint amount,\n    uint balanceFromAfter,\n    uint balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider()\n    external\n    view\n    returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "contracts/strategies/vendor/aave/v2/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\npragma solidity >=0.6.12;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/strategies/vendor/aave/v2/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\npragma solidity >=0.6.12;\n\n/**\n * @title IPriceOracleGetter interface\n * @notice Interface for the Aave price oracle.\n **/\n\ninterface IPriceOracleGetter {\n  /**\n   * @dev returns the asset price in ETH\n   * @param asset the address of the asset\n   * @return the ETH price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint);\n}\n"
    },
    "contracts/strategies/vendor/aave/v2/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\n//for more details\npragma solidity >=0.6.12;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint data;\n  }\n\n  struct UserConfigurationMap {\n    uint data;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n\n  function getParams(ReserveConfigurationMap memory configMap)\n    internal\n    pure\n    returns (\n      uint,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    uint dataLocal = configMap.data;\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\n        LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\n        LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n    );\n  }\n\n  function isUsingAsCollateral(\n    DataTypes.UserConfigurationMap memory configMap,\n    uint reserveIndex\n  ) internal pure returns (bool) {\n    require(reserveIndex < 128, \"Invalid index\");\n    return (configMap.data >> (reserveIndex * 2 + 1)) & 1 != 0;\n  }\n}\n"
    },
    "contracts/strategies/multi_user/MultiMaker.sol": {
      "content": "// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"contracts/strategies/multi_user/abstract/MultiUser.sol\";\nimport \"contracts/strategies/routers/SimpleRouter.sol\";\n\ncontract MultiMaker is MultiUser {\n  constructor(IMangrove _MGV, address deployer)\n    MultiUser(_MGV, new SimpleRouter(), 30_000)\n  {\n    if (deployer != msg.sender) {\n      setAdmin(deployer);\n      router().setAdmin(deployer);\n    }\n  }\n}\n"
    },
    "contracts/test/periphery/MgvReader.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\nimport {MgvReader} from \"contracts/periphery/MgvReader.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract MgvReaderTest is MangroveTest {\n  TestMaker mkr;\n  MgvReader reader;\n  address oracle;\n\n  function setUp() public override {\n    super.setUp();\n    oracle = freshAddress(\"oracle\");\n    vm.mockCall(oracle, bytes(\"\"), abi.encode(0, 0));\n\n    mkr = setupMaker($(base), $(quote), \"maker\");\n    reader = new MgvReader($(mgv));\n    mkr.provisionMgv(5 ether);\n\n    deal($(quote), address(mkr), 1 ether);\n  }\n\n  function test_read_packed() public {\n    (\n      uint currentId,\n      uint[] memory offerIds,\n      P.OfferStruct[] memory offers,\n      P.OfferDetailStruct[] memory details\n    ) = reader.offerList($(base), $(quote), 0, 50);\n\n    assertEq(offerIds.length, 0, \"ids: wrong length on 2elem\");\n    assertEq(offers.length, 0, \"offers: wrong length on 1elem\");\n    assertEq(details.length, 0, \"details: wrong length on 1elem\");\n    // test 1 elem\n    mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n\n    (currentId, offerIds, offers, details) = reader.offerList(\n      $(base),\n      $(quote),\n      0,\n      50\n    );\n\n    assertEq(offerIds.length, 1, \"ids: wrong length on 1elem\");\n    assertEq(offers.length, 1, \"offers: wrong length on 1elem\");\n    assertEq(details.length, 1, \"details: wrong length on 1elem\");\n\n    // test 2 elem\n    mkr.newOffer(0.9 ether, 1 ether, 10_000, 0);\n\n    (currentId, offerIds, offers, details) = reader.offerList(\n      $(base),\n      $(quote),\n      0,\n      50\n    );\n\n    assertEq(offerIds.length, 2, \"ids: wrong length on 2elem\");\n    assertEq(offers.length, 2, \"offers: wrong length on 1elem\");\n    assertEq(details.length, 2, \"details: wrong length on 1elem\");\n\n    // test 2 elem read from elem 1\n    (currentId, offerIds, offers, details) = reader.offerList(\n      $(base),\n      $(quote),\n      1,\n      50\n    );\n    assertEq(offerIds.length, 1, \"ids: wrong length 2elem start from id 1\");\n    assertEq(offers.length, 1, \"offers: wrong length on 1elem\");\n    assertEq(details.length, 1, \"details: wrong length on 1elem\");\n\n    // test 3 elem read in chunks of 2\n    mkr.newOffer(0.8 ether, 1 ether, 10_000, 0);\n    (currentId, offerIds, offers, details) = reader.offerList(\n      $(base),\n      $(quote),\n      0,\n      2\n    );\n    assertEq(offerIds.length, 2, \"ids: wrong length on 3elem chunk size 2\");\n    assertEq(offers.length, 2, \"offers: wrong length on 1elem\");\n    assertEq(details.length, 2, \"details: wrong length on 1elem\");\n\n    // test offer order\n    (currentId, offerIds, offers, details) = reader.offerList(\n      $(base),\n      $(quote),\n      0,\n      50\n    );\n    assertEq(offers[0].wants, 0.8 ether, \"wrong wants for offers[0]\");\n    assertEq(offers[1].wants, 0.9 ether, \"wrong wants for offers[0]\");\n    assertEq(offers[2].wants, 1 ether, \"wrong wants for offers[0]\");\n  }\n\n  function test_returns_zero_on_nonexisting_offer() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n    mkr.retractOffer(ofr);\n    (, uint[] memory offerIds, , ) = reader.offerList(\n      $(base),\n      $(quote),\n      ofr,\n      50\n    );\n    assertEq(\n      offerIds.length,\n      0,\n      \"should have 0 offers since starting point is out of the book\"\n    );\n  }\n\n  function test_no_wasted_time() public {\n    reader.offerList($(base), $(quote), 0, 50); // warming up caches\n\n    uint g = gasleft();\n    reader.offerList($(base), $(quote), 0, 50);\n    uint used1 = g - gasleft();\n\n    g = gasleft();\n    reader.offerList($(base), $(quote), 0, 50000000);\n    uint used2 = g - gasleft();\n\n    assertEq(\n      used1,\n      used2,\n      \"gas spent should not depend on maxOffers when offers length < maxOffers\"\n    );\n  }\n\n  function test_correct_endpoints_0() public {\n    uint startId;\n    uint length;\n    (startId, length) = reader.offerListEndPoints($(base), $(quote), 0, 100000);\n    assertEq(startId, 0, \"0.0 wrong startId\");\n    assertEq(length, 0, \"0.0 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(\n      $(base),\n      $(quote),\n      32,\n      100000\n    );\n    assertEq(startId, 0, \"0.1 wrong startId\");\n    assertEq(length, 0, \"0.1 wrong length\");\n  }\n\n  function test_correct_endpoints_1() public {\n    uint startId;\n    uint length;\n    uint ofr;\n    ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    (startId, length) = reader.offerListEndPoints($(base), $(quote), 0, 0);\n    assertEq(startId, 1, \"1.0 wrong startId\");\n    assertEq(length, 0, \"1.0 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints($(base), $(quote), 1, 1);\n    assertEq(startId, 1, \"1.1 wrong startId\");\n    assertEq(length, 1, \"1.1 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints($(base), $(quote), 1, 1321);\n    assertEq(startId, 1, \"1.2 wrong startId\");\n    assertEq(length, 1, \"1.2 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints($(base), $(quote), 2, 12);\n    assertEq(startId, 0, \"1.0 wrong startId\");\n    assertEq(length, 0, \"1.0 wrong length\");\n  }\n\n  function try_provision() internal {\n    uint prov = reader.getProvision($(base), $(quote), 0, 0);\n    uint bal1 = mgv.balanceOf(address(mkr));\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n    uint bal2 = mgv.balanceOf(address(mkr));\n    assertEq(bal1 - bal2, prov, \"provision computation is wrong\");\n  }\n\n  function test_provision_0() public {\n    try_provision();\n  }\n\n  function test_provision_1() public {\n    mgv.setGasbase($(base), $(quote), 17_000);\n    try_provision();\n  }\n\n  function test_provision_oracle() public {\n    mgv.setMonitor(oracle);\n    mgv.setUseOracle(true);\n    try_provision();\n  }\n}\n"
    },
    "contracts/test/periphery/MgvCleaner.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\nimport \"contracts/test/lib/MangroveTest.sol\";\n// pragma experimental ABIEncoderV2;\n\nimport {MgvCleaner} from \"contracts/periphery/MgvCleaner.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract MgvCleanerTest is MangroveTest {\n  receive() external payable {}\n\n  TestTaker tkr;\n  TestMaker mkr;\n  MgvCleaner cleaner;\n\n  function setUp() public override {\n    super.setUp();\n    deal($(quote), $(this), 10 ether);\n    mkr = setupMaker($(base), $(quote), \"maker\");\n    cleaner = new MgvCleaner($(mgv));\n    vm.label(address(cleaner), \"cleaner\");\n\n    mkr.provisionMgv(5 ether);\n\n    deal($(base), address(mkr), 1 ether);\n\n    mkr.approveMgv(base, 1 ether);\n  }\n\n  /* # Test Config */\n\n  function test_single_failing_offer() public {\n    mgv.approve($(base), $(quote), address(cleaner), type(uint).max);\n\n    mkr.shouldFail(true);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = $(this).balance;\n\n    cleaner.collect(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, type(uint).max]),\n      true\n    );\n\n    uint newBal = $(this).balance;\n\n    assertGt(newBal, oldBal, \"balance should have increased\");\n  }\n\n  function test_mult_failing_offer() public {\n    mgv.approve($(base), $(quote), address(cleaner), type(uint).max);\n\n    mkr.shouldFail(true);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint ofr2 = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = $(this).balance;\n\n    uint[4][] memory targets = new uint[4][](2);\n    targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n    targets[1] = [ofr2, 1 ether, 1 ether, type(uint).max];\n    cleaner.collect($(base), $(quote), targets, true);\n\n    uint newBal = $(this).balance;\n\n    assertGt(newBal, oldBal, \"balance should have increased\");\n  }\n\n  function test_no_fail_no_cleaning() public {\n    mgv.approve($(base), $(quote), address(cleaner), type(uint).max);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = $(this).balance;\n\n    uint[4][] memory targets = wrap_dynamic(\n      [ofr, 1 ether, 1 ether, type(uint).max]\n    );\n\n    vm.expectRevert(\"mgvCleaner/anOfferDidNotFail\");\n    cleaner.collect($(base), $(quote), targets, true);\n\n    uint newBal = $(this).balance;\n\n    assertEq(newBal, oldBal, \"balance should be the same\");\n  }\n\n  // For now there is no need to approve\n  // function test_no_approve_no_cleaning() public {\n  //   uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000,0);\n\n  //   uint[4][] memory targets = new uint[4][](1);\n  //   targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n\n  //   try cleaner.collect($(base), $(quote),targets,true) {\n  //     fail(\"collect should fail since cleaner was not approved\");\n  //   } catch Error(string memory reason) {\n  //     assertEq(\"mgv/lowAllowance\",reason,\"Fail should be due to no allowance\");\n  //   }\n  // }\n}\n"
    },
    "contracts/periphery/MgvCleaner.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvCleaner.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport {MgvLib as ML, P} from \"../MgvLib.sol\";\n\ninterface MangroveLike {\n  function snipesFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave,\n      uint bounty\n    );\n\n  function offerInfo(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  ) external view returns (P.OfferStruct memory, P.OfferStruct memory);\n}\n\n/* The purpose of the Cleaner contract is to execute failing offers and collect\n * their associated bounty. It takes an array of offers with same definition as\n * `Mangrove.snipes` and expects them all to fail or not execute. */\n\n/* How to use:\n   1) Ensure *your* address approved Mangrove for the token you will provide to the offer (`inbound_tkn`).\n   2) Run `collect` on the offers that you detected were failing.\n\n   You can adjust takerWants/takerGives and gasreq as needed.\n\n   Note: in the current version you do not need to set MgvCleaner's allowance in Mangrove.\n   TODO: add `collectWith` with an additional `taker` argument.\n*/\ncontract MgvCleaner {\n  MangroveLike immutable MGV;\n\n  constructor(address _MGV) {\n    MGV = MangroveLike(_MGV);\n  }\n\n  receive() external payable {}\n\n  /* Returns the entire balance, not just the bounty collected */\n  function collect(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants\n  ) external returns (uint bal) {\n    unchecked {\n      (uint successes, , , ) = MGV.snipesFor(\n        outbound_tkn,\n        inbound_tkn,\n        targets,\n        fillWants,\n        msg.sender\n      );\n      require(successes == 0, \"mgvCleaner/anOfferDidNotFail\");\n      bal = address(this).balance;\n      bool noRevert;\n      (noRevert, ) = msg.sender.call{value: bal}(\"\");\n    }\n  }\n}\n"
    },
    "contracts/test/core/Vault.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\nimport \"contracts/test/lib/MangroveTest.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract VaultTest is MangroveTest {\n  function setUp() public override {\n    super.setUp();\n  }\n\n  function test_initial_vault_value() public {\n    assertEq(mgv.vault(), $(this), \"initial vault value should be mgv creator\");\n  }\n\n  function test_gov_can_set_vault() public {\n    mgv.setVault(address(0));\n    assertEq(mgv.vault(), address(0), \"gov should be able to set vault\");\n  }\n}\n"
    },
    "contracts/test/core/TakerOperations.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\n/* The following constructs an ERC20 with a transferFrom callback method,\n   and a TestTaker which throws away any funds received upon getting\n   a callback.\n*/\ncontract TakerOperationsTest is MangroveTest {\n  TestMaker mkr;\n  TestMaker refusemkr;\n  TestMaker failmkr;\n\n  bool refuseReceive = false;\n\n  receive() external payable {\n    if (refuseReceive) {\n      revert(\"no\");\n    }\n  }\n\n  function setUp() public override {\n    super.setUp();\n\n    // reset approvals\n    base.approve($(mgv), 0);\n    quote.approve($(mgv), 0);\n\n    mkr = setupMaker($(base), $(quote), \"maker\");\n    refusemkr = setupMaker($(base), $(quote), \"refusing mkr\");\n    refusemkr.shouldFail(true);\n    failmkr = setupMaker($(base), $(quote), \"reverting mkr\");\n    failmkr.shouldRevert(true);\n\n    mkr.provisionMgv(10 ether);\n    mkr.approveMgv(base, 10 ether);\n\n    refusemkr.provisionMgv(1 ether);\n    refusemkr.approveMgv(base, 10 ether);\n    failmkr.provisionMgv(1 ether);\n    failmkr.approveMgv(base, 10 ether);\n\n    base.mint(address(mkr), 5 ether);\n    base.mint(address(failmkr), 5 ether);\n    base.mint(address(refusemkr), 5 ether);\n\n    quote.mint($(this), 5 ether);\n    quote.mint($(this), 5 ether);\n  }\n\n  function test_snipe_reverts_if_taker_is_blacklisted_for_quote() public {\n    uint weiBalanceBefore = mgv.balanceOf($(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n    quote.blacklists($(this));\n\n    vm.expectRevert(\"mgv/takerTransferFail\");\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n    assertEq(\n      weiBalanceBefore,\n      mgv.balanceOf($(this)),\n      \"Taker should not take bounty\"\n    );\n  }\n\n  function test_snipe_reverts_if_taker_is_blacklisted_for_base() public {\n    uint weiBalanceBefore = mgv.balanceOf($(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n    base.blacklists($(this));\n\n    vm.expectRevert(\"mgv/MgvFailToPayTaker\");\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n    assertEq(\n      weiBalanceBefore,\n      mgv.balanceOf($(this)),\n      \"Taker should not take bounty\"\n    );\n  }\n\n  function test_snipe_fails_if_price_has_changed() public {\n    uint weiBalanceBefore = mgv.balanceOf($(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 0.5 ether, 100_000]),\n      false\n    );\n    assertTrue(successes == 0, \"Snipe should fail\");\n    assertEq(\n      weiBalanceBefore,\n      mgv.balanceOf($(this)),\n      \"Taker should not take bounty\"\n    );\n    assertTrue(\n      (got == gave && gave == 0),\n      \"Taker should not give or take anything\"\n    );\n  }\n\n  function test_taker_cannot_drain_maker() public {\n    mgv.setDensity($(base), $(quote), 0);\n    quote.approve($(mgv), 1 ether);\n    uint ofr = mkr.newOffer(9, 10, 100_000, 0);\n    uint oldBal = quote.balanceOf($(this));\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1, 15 ether, 100_000]),\n      true\n    );\n    uint newBal = quote.balanceOf($(this));\n    assertGt(oldBal, newBal, \"oldBal should be strictly higher\");\n  }\n\n  function test_snipe_fillWants() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0.5 ether, 1 ether, 100_000]),\n      true\n    );\n    assertTrue(successes == 1, \"Snipe should not fail\");\n    assertEq(got, 0.5 ether, \"Taker did not get enough\");\n    assertEq(gave, 0.5 ether, \"Taker did not give enough\");\n  }\n\n  function test_multiple_snipes_fillWants() public {\n    uint i;\n    uint[] memory ofrs = new uint[](3);\n    ofrs[i++] = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    ofrs[i++] = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    ofrs[i++] = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 3 ether);\n    uint[4][] memory targets = new uint[4][](3);\n    uint j;\n    targets[j] = [ofrs[j], 0.5 ether, 1 ether, 100_000];\n    j++;\n    targets[j] = [ofrs[j], 1 ether, 1 ether, 100_000];\n    j++;\n    targets[j] = [ofrs[j], 0.8 ether, 1 ether, 100_000];\n\n    expectFrom($(mgv));\n    emit OrderStart();\n    expectFrom($(mgv));\n    emit OrderComplete($(base), $(quote), $(this), 2.3 ether, 2.3 ether, 0, 0);\n\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      targets,\n      true\n    );\n    assertTrue(successes == 3, \"Snipes should not fail\");\n    assertEq(got, 2.3 ether, \"Taker did not get enough\");\n    assertEq(gave, 2.3 ether, \"Taker did not give enough\");\n  }\n\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  function test_snipe_fillWants_zero() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n\n    expectFrom($(quote));\n    emit Transfer($(this), address(mgv), 0);\n    expectFrom($(quote));\n    emit Transfer($(mgv), address(mkr), 0);\n\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0, 0, 100_000]),\n      true\n    );\n    assertTrue(successes == 1, \"Snipe should not fail\");\n    assertEq(got, 0 ether, \"Taker had too much\");\n    assertEq(gave, 0 ether, \"Taker gave too much\");\n    assertTrue(\n      !mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should not be in the book\"\n    );\n  }\n\n  function test_snipe_free_offer_fillWants_respects_spec() public {\n    uint ofr = mkr.newOffer(0, 1 ether, 100_000, 0);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n\n    /* Setting fillWants = true means we should not receive more than `wants`.\n       Here we are asking for 0.1 eth to an offer that gives 1eth for nothing.\n       We should still only receive 0.1 eth */\n\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0.1 ether, 0, 100_000]),\n      true\n    );\n    assertTrue(successes == 1, \"Snipe should not fail\");\n    assertEq(got, 0.1 ether, \"Wrong got value\");\n    assertEq(gave, 0 ether, \"Wrong gave value\");\n    assertTrue(\n      !mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should not be in the book\"\n    );\n  }\n\n  function test_snipe_free_offer_fillGives_respects_spec() public {\n    uint ofr = mkr.newOffer(0, 1 ether, 100_000, 0);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n\n    /* Setting fillWants = false means we should spend as little as possible to receive\n       as much as possible.\n       Here despite asking for .1eth the offer gives 1eth for 0 so we should receive 1eth. */\n\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0.1 ether, 0, 100_000]),\n      false\n    );\n    assertTrue(successes == 1, \"Snipe should not fail\");\n    assertEq(got, 1 ether, \"Wrong got value\");\n    assertEq(gave, 0 ether, \"Wrong gave value\");\n    assertTrue(\n      !mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should not be in the book\"\n    );\n  }\n\n  function test_snipe_fillGives_zero() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0, 0, 100_000]),\n      false\n    );\n    assertTrue(successes == 1, \"Snipe should not fail\");\n    assertEq(got, 0 ether, \"Taker had too much\");\n    assertEq(gave, 0 ether, \"Taker gave too much\");\n    assertTrue(\n      !mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should not be in the book\"\n    );\n  }\n\n  function test_snipe_fillGives() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 1 ether);\n\n    (uint successes, uint got, uint gave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0.5 ether, 1 ether, 100_000]),\n      false\n    );\n    assertTrue(successes == 1, \"Snipe should not fail\");\n    assertEq(got, 1 ether, \"Taker did not get enough\");\n    assertEq(gave, 1 ether, \"Taker did not get enough\");\n  }\n\n  function test_mo_fillWants() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 2 ether);\n    (uint got, uint gave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      1.1 ether,\n      2 ether,\n      true\n    );\n    assertEq(got, 1.1 ether, \"Taker did not get enough\");\n    assertEq(gave, 1.1 ether, \"Taker did not get enough\");\n  }\n\n  function test_mo_fillGives() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 2 ether);\n    (uint got, uint gave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      1.1 ether,\n      2 ether,\n      false\n    );\n    assertEq(got, 2 ether, \"Taker did not get enough\");\n    assertEq(gave, 2 ether, \"Taker did not get enough\");\n  }\n\n  function test_mo_fillGivesAll_no_approved_fails() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 2 ether);\n    vm.expectRevert(\"mgv/takerTransferFail\");\n    mgv.marketOrder($(base), $(quote), 0 ether, 3 ether, false);\n  }\n\n  function test_mo_fillGivesAll_succeeds() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quote.approve($(mgv), 3 ether);\n    (uint got, uint gave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      0 ether,\n      3 ether,\n      false\n    );\n    assertEq(got, 3 ether, \"Taker did not get enough\");\n    assertEq(gave, 3 ether, \"Taker did not get enough\");\n  }\n\n  function test_taker_reimbursed_if_maker_doesnt_pay() public {\n    uint mkr_provision = getProvision($(base), $(quote), 100_000);\n    quote.approve($(mgv), 1 ether);\n    uint ofr = refusemkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\"); // status visible in the posthook\n    uint beforeQuote = quote.balanceOf($(this));\n    uint beforeWei = $(this).balance;\n\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      $(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerTransferFail\"\n    );\n    (uint successes, uint takerGot, uint takerGave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n    uint penalty = $(this).balance - beforeWei;\n    assertTrue(penalty > 0, \"Taker should have been compensated\");\n    assertTrue(successes == 0, \"Snipe should fail\");\n    assertTrue(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    assertTrue(\n      beforeQuote == quote.balanceOf($(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    emit Credit(address(refusemkr), mkr_provision - penalty);\n  }\n\n  function test_taker_reverts_on_penalty_triggers_revert() public {\n    uint ofr = refusemkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    refuseReceive = true;\n    quote.approve($(mgv), 1 ether);\n\n    vm.expectRevert(\"mgv/sendPenaltyReverted\");\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n  }\n\n  function test_taker_reimbursed_if_maker_is_blacklisted_for_base() public {\n    uint mkr_provision = getProvision($(base), $(quote), 100_000);\n    quote.approve($(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\"); // status visible in the posthook\n\n    base.blacklists(address(mkr));\n    uint beforeQuote = quote.balanceOf($(this));\n    uint beforeWei = $(this).balance;\n\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      $(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerTransferFail\"\n    );\n    (uint successes, uint takerGot, uint takerGave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n    uint penalty = $(this).balance - beforeWei;\n    assertTrue(penalty > 0, \"Taker should have been compensated\");\n    assertTrue(successes == 0, \"Snipe should fail\");\n    assertTrue(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    assertTrue(\n      beforeQuote == quote.balanceOf($(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    emit Credit(address(mkr), mkr_provision - penalty);\n  }\n\n  function test_taker_reimbursed_if_maker_is_blacklisted_for_quote() public {\n    uint mkr_provision = getProvision($(base), $(quote), 100_000);\n    quote.approve($(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerReceiveFail\"); // status visible in the posthook\n\n    quote.blacklists(address(mkr));\n    uint beforeQuote = quote.balanceOf($(this));\n    uint beforeWei = $(this).balance;\n\n    expectFrom($(mgv));\n\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      $(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerReceiveFail\"\n    );\n    (uint successes, uint takerGot, uint takerGave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n    uint penalty = $(this).balance - beforeWei;\n    assertTrue(penalty > 0, \"Taker should have been compensated\");\n    assertTrue(successes == 0, \"Snipe should fail\");\n    assertTrue(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    assertTrue(\n      beforeQuote == quote.balanceOf($(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    emit Credit(address(mkr), mkr_provision - penalty);\n  }\n\n  function test_taker_collects_failing_offer() public {\n    quote.approve($(mgv), 1 ether);\n    uint ofr = failmkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint beforeWei = $(this).balance;\n\n    (uint successes, uint takerGot, uint takerGave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0, 0, 100_000]),\n      true\n    );\n    assertTrue(successes == 0, \"Snipe should fail\");\n    assertTrue(\n      takerGot == takerGave && takerGave == 0,\n      \"Transaction data should be 0\"\n    );\n    assertTrue($(this).balance > beforeWei, \"Taker was not compensated\");\n  }\n\n  function test_taker_reimbursed_if_maker_reverts() public {\n    uint mkr_provision = getProvision($(base), $(quote), 50_000);\n    quote.approve($(mgv), 1 ether);\n    uint ofr = failmkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint beforeQuote = quote.balanceOf($(this));\n    uint beforeWei = $(this).balance;\n\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      $(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    (uint successes, uint takerGot, uint takerGave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n    uint penalty = $(this).balance - beforeWei;\n    assertTrue(penalty > 0, \"Taker should have been compensated\");\n    assertTrue(successes == 0, \"Snipe should fail\");\n    assertTrue(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    assertTrue(\n      beforeQuote == quote.balanceOf($(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    emit Credit(address(failmkr), mkr_provision - penalty);\n  }\n\n  function test_taker_hasnt_approved_base_succeeds_order_with_fee() public {\n    mgv.setFee($(base), $(quote), 3);\n    uint balTaker = base.balanceOf($(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    quote.approve($(mgv), 1 ether);\n\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 50_000]),\n      true\n    );\n    assertEq(\n      base.balanceOf($(this)) - balTaker,\n      1 ether,\n      \"Incorrect delivered amount\"\n    );\n  }\n\n  function test_taker_hasnt_approved_base_succeeds_order_wo_fee() public {\n    uint balTaker = base.balanceOf($(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    quote.approve($(mgv), 1 ether);\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 50_000]),\n      true\n    );\n    assertEq(\n      base.balanceOf($(this)) - balTaker,\n      1 ether,\n      \"Incorrect delivered amount\"\n    );\n  }\n\n  function test_taker_hasnt_approved_quote_fails_order() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    base.approve($(mgv), 1 ether);\n\n    vm.expectRevert(\"mgv/takerTransferFail\");\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 50_000]),\n      true\n    );\n  }\n\n  function test_simple_snipe() public {\n    uint ofr = mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    base.approve($(mgv), 10 ether);\n    quote.approve($(mgv), 10 ether);\n    uint balTaker = base.balanceOf($(this));\n    uint balMaker = quote.balanceOf(address(mkr));\n\n    expectFrom($(mgv));\n    emit OfferSuccess($(base), $(quote), ofr, $(this), 1 ether, 1.1 ether);\n    (uint successes, uint takerGot, uint takerGave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1.1 ether, 50_000]),\n      true\n    );\n    assertTrue(successes == 1, \"Snipe should succeed\");\n    assertEq(\n      base.balanceOf($(this)) - balTaker,\n      1 ether,\n      \"Incorrect delivered amount (taker)\"\n    );\n    assertEq(\n      quote.balanceOf(address(mkr)) - balMaker,\n      1.1 ether,\n      \"Incorrect delivered amount (maker)\"\n    );\n    assertEq(takerGot, 1 ether, \"Incorrect transaction information\");\n    assertEq(takerGave, 1.1 ether, \"Incorrect transaction information\");\n  }\n\n  function test_simple_marketOrder() public {\n    mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    mkr.newOffer(1.2 ether, 1 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n\n    base.approve($(mgv), 10 ether);\n    quote.approve($(mgv), 10 ether);\n    uint balTaker = base.balanceOf($(this));\n    uint balMaker = quote.balanceOf(address(mkr));\n\n    (uint takerGot, uint takerGave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      2 ether,\n      4 ether,\n      true\n    );\n    assertEq(takerGot, 2 ether, \"Incorrect declared delivered amount (taker)\");\n    assertEq(\n      takerGave,\n      2.3 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    assertEq(\n      base.balanceOf($(this)) - balTaker,\n      2 ether,\n      \"Incorrect delivered amount (taker)\"\n    );\n    assertEq(\n      quote.balanceOf(address(mkr)) - balMaker,\n      2.3 ether,\n      \"Incorrect delivered amount (maker)\"\n    );\n  }\n\n  function test_simple_fillWants() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quote.approve($(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      1 ether,\n      2 ether,\n      true\n    );\n    assertEq(takerGot, 1 ether, \"Incorrect declared delivered amount (taker)\");\n    assertEq(takerGave, 1 ether, \"Incorrect declared delivered amount (maker)\");\n  }\n\n  function test_simple_fillGives() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quote.approve($(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      1 ether,\n      2 ether,\n      false\n    );\n    assertEq(takerGave, 2 ether, \"Incorrect declared delivered amount (maker)\");\n    assertEq(takerGot, 2 ether, \"Incorrect declared delivered amount (taker)\");\n  }\n\n  function test_fillGives_at_0_wants_works() public {\n    uint ofr = mkr.newOffer(0 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quote.approve($(mgv), 10 ether);\n\n    (, uint takerGot, uint takerGave, , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 2 ether, 0 ether, 300_000]),\n      false\n    );\n    assertEq(takerGave, 0 ether, \"Incorrect declared delivered amount (maker)\");\n    assertEq(takerGot, 2 ether, \"Incorrect declared delivered amount (taker)\");\n  }\n\n  function test_empty_wants_fillGives() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quote.approve($(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      0 ether,\n      2 ether,\n      false\n    );\n    assertEq(takerGave, 2 ether, \"Incorrect declared delivered amount (maker)\");\n    assertEq(takerGot, 2 ether, \"Incorrect declared delivered amount (taker)\");\n  }\n\n  function test_empty_wants_fillWants() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quote.approve($(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      0 ether,\n      2 ether,\n      true\n    );\n    assertEq(takerGave, 0 ether, \"Incorrect declared delivered amount (maker)\");\n    assertEq(takerGot, 0 ether, \"Incorrect declared delivered amount (taker)\");\n  }\n\n  function test_taker_has_no_quote_fails_order() public {\n    uint ofr = mkr.newOffer(100 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n\n    quote.approve($(mgv), 100 ether);\n    base.approve($(mgv), 1 ether); // not necessary since no fee\n\n    vm.expectRevert(\"mgv/takerTransferFail\");\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 2 ether, 100 ether, 100_000]),\n      true\n    );\n  }\n\n  function test_maker_has_not_enough_base_fails_order() public {\n    uint ofr = mkr.newOffer(1 ether, 100 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\");\n    // getting rid of base tokens\n    //mkr.transferToken(base,$(this),5 ether);\n    quote.approve($(mgv), 0.5 ether);\n\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      $(this),\n      50 ether,\n      0.5 ether,\n      \"mgv/makerTransferFail\"\n    );\n    (uint successes, , , , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 50 ether, 0.5 ether, 100_000]),\n      true\n    );\n    assertTrue(successes == 0, \"order should fail\");\n  }\n\n  function test_maker_revert_is_logged() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    mkr.expect(\"mgv/makerRevert\");\n    mkr.shouldRevert(true);\n    quote.approve($(mgv), 1 ether);\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      $(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 50_000]),\n      true\n    );\n  }\n\n  function test_snipe_on_higher_price_fails() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quote.approve($(mgv), 0.5 ether);\n\n    (uint successes, , , , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 0.5 ether, 100_000]),\n      true\n    );\n    assertTrue(\n      successes == 0,\n      \"Order should fail when order price is higher than offer\"\n    );\n  }\n\n  function test_snipe_on_higher_gas_fails() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quote.approve($(mgv), 1 ether);\n\n    (uint successes, , , , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 50_000]),\n      true\n    );\n    assertTrue(\n      successes == 0,\n      \"Order should fail when order gas is higher than offer\"\n    );\n  }\n\n  function test_detect_lowgas() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quote.approve($(mgv), 100 ether);\n\n    bytes memory cd = abi.encodeWithSelector(\n      mgv.snipes.selector,\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 100_000]),\n      true\n    );\n\n    (bool noRevert, bytes memory data) = $(mgv).call{gas: 130000}(cd);\n    if (noRevert) {\n      fail(\"take should fail due to low gas\");\n    } else {\n      revertEq(getReason(data), \"mgv/notEnoughGasForMakerTrade\");\n    }\n  }\n\n  function test_snipe_on_lower_price_succeeds() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quote.approve($(mgv), 2 ether);\n    uint balTaker = base.balanceOf($(this));\n    uint balMaker = quote.balanceOf(address(mkr));\n\n    (uint successes, , , , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 2 ether, 100_000]),\n      true\n    );\n    assertTrue(\n      successes == 1,\n      \"Order should succeed when order price is lower than offer\"\n    );\n    // checking order was executed at Maker's price\n    assertEq(\n      base.balanceOf($(this)) - balTaker,\n      1 ether,\n      \"Incorrect delivered amount (taker)\"\n    );\n    assertEq(\n      quote.balanceOf(address(mkr)) - balMaker,\n      1 ether,\n      \"Incorrect delivered amount (maker)\"\n    );\n  }\n\n  /* Note as for jan 5 2020: by locally pushing the block gas limit to 38M, you can go up to 162 levels of recursion before hitting \"revert for an unknown reason\" -- I'm assuming that's the stack limit. */\n  function test_recursion_depth_is_acceptable() public {\n    for (uint i = 0; i < 50; i++) {\n      mkr.newOffer(0.001 ether, 0.001 ether, 50_000, i);\n    }\n    quote.approve($(mgv), 10 ether);\n    // 6/1/20 : ~50k/offer with optims\n    //uint g = gasleft();\n    //console.log(\"gas used per offer: \",(g-gasleft())/50);\n  }\n\n  function test_partial_fill() public {\n    quote.approve($(mgv), 1 ether);\n    mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 1);\n    mkr.expect(\"mgv/tradeSuccess\");\n    (uint takerGot, , , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      0.15 ether,\n      0.15 ether,\n      true\n    );\n    assertEq(takerGot, 0.15 ether, \"Incorrect declared partial fill amount\");\n    assertEq(base.balanceOf($(this)), 0.15 ether, \"incorrect partial fill\");\n  }\n\n  // ! unreliable test, depends on gas use\n  function test_market_order_stops_for_high_price() public {\n    quote.approve($(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer((i + 1) * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 2 * (0.1 ether + 0.1 ether);\n    uint takerGives = 2 * (0.1 ether + 0.2 ether);\n    mgv.marketOrder{gas: 350_000}(\n      $(base),\n      $(quote),\n      takerWants,\n      takerGives,\n      true\n    );\n  }\n\n  // ! unreliable test, depends on gas use\n  function test_market_order_stops_for_filled_mid_offer() public {\n    quote.approve($(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer(i * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 0.1 ether + 0.05 ether;\n    uint takerGives = 0.1 ether + 0.1 ether;\n    mgv.marketOrder{gas: 350_000}(\n      $(base),\n      $(quote),\n      takerWants,\n      takerGives,\n      true\n    );\n  }\n\n  function test_market_order_stops_for_filled_after_offer() public {\n    quote.approve($(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer(i * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 0.1 ether + 0.1 ether;\n    uint takerGives = 0.1 ether + 0.2 ether;\n    mgv.marketOrder{gas: 350_000}(\n      $(base),\n      $(quote),\n      takerWants,\n      takerGives,\n      true\n    );\n  }\n\n  function test_takerWants_wider_than_160_bits_fails_marketOrder() public {\n    vm.expectRevert(\"mgv/mOrder/takerWants/160bits\");\n    mgv.marketOrder($(base), $(quote), 2**160, 1, true);\n  }\n\n  function test_snipe_with_0_wants_ejects_offer() public {\n    quote.approve($(mgv), 1 ether);\n    uint mkrBal = base.balanceOf(address(mkr));\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 0);\n\n    (uint successes, , , , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0, 1 ether, 50_000]),\n      true\n    );\n    assertTrue(successes == 1, \"snipe should succeed\");\n    assertEq(mgv.best($(base), $(quote)), 0, \"offer should be gone\");\n    assertEq(\n      base.balanceOf(address(mkr)),\n      mkrBal,\n      \"mkr balance should not change\"\n    );\n  }\n\n  function test_unsafe_gas_left_fails_order() public {\n    mgv.setGasbase($(base), $(quote), 1);\n    quote.approve($(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 120_000, 0);\n    vm.expectRevert(\"mgv/notEnoughGasForMakerTrade\");\n    mgv.snipes{gas: 120_000}(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 120_000]),\n      true\n    );\n  }\n\n  function test_marketOrder_on_empty_book_does_not_revert() public {\n    mgv.marketOrder($(base), $(quote), 1 ether, 1 ether, true);\n  }\n\n  function test_marketOrder_on_empty_book_does_not_leave_lock_on() public {\n    mgv.marketOrder($(base), $(quote), 1 ether, 1 ether, true);\n    assertTrue(\n      !mgv.locked($(base), $(quote)),\n      \"mgv should not be locked after marketOrder on empty OB\"\n    );\n  }\n\n  function test_takerWants_is_zero_succeeds() public {\n    (uint got, uint gave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      0,\n      1 ether,\n      true\n    );\n    assertEq(got, 0, \"Taker got too much\");\n    assertEq(gave, 0 ether, \"Taker gave too much\");\n  }\n\n  function test_takerGives_is_zero_succeeds() public {\n    (uint got, uint gave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      1 ether,\n      0,\n      true\n    );\n    assertEq(got, 0, \"Taker got too much\");\n    assertEq(gave, 0 ether, \"Taker gave too much\");\n  }\n}\n"
    },
    "contracts/test/core/Scenarii.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\ncontract ScenariiTest is MangroveTest {\n  TestTaker taker;\n  MakerDeployer makers;\n  Balances balances;\n  uint constant testFee = 300;\n  uint[] offerOf;\n\n  mapping(uint => mapping(Info => uint)) offers;\n\n  //receive() external payable {}\n\n  function saveOffers() internal {\n    uint offerId = mgv.best($(base), $(quote));\n    while (offerId != 0) {\n      (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) = mgv\n        .offerInfo($(base), $(quote), offerId);\n      offers[offerId][Info.makerWants] = offer.wants;\n      offers[offerId][Info.makerGives] = offer.gives;\n      offers[offerId][Info.gasreq] = offerDetail.gasreq;\n      offerId = offer.next;\n    }\n  }\n\n  function saveBalances() internal {\n    uint[] memory balA = new uint[](makers.length());\n    uint[] memory balB = new uint[](makers.length());\n    uint[] memory balWei = new uint[](makers.length());\n    for (uint i = 0; i < makers.length(); i++) {\n      balA[i] = base.balanceOf(address(makers.getMaker(i)));\n      balB[i] = quote.balanceOf(address(makers.getMaker(i)));\n      balWei[i] = mgv.balanceOf(address(makers.getMaker(i)));\n    }\n    balances = Balances({\n      mgvBalanceWei: $(mgv).balance,\n      mgvBalanceFees: base.balanceOf(mgv.governance()),\n      takerBalanceA: base.balanceOf(address(taker)),\n      takerBalanceB: quote.balanceOf(address(taker)),\n      takerBalanceWei: mgv.balanceOf(address(taker)),\n      makersBalanceA: balA,\n      makersBalanceB: balB,\n      makersBalanceWei: balWei\n    });\n  }\n\n  function setUp() public override {\n    super.setUp();\n\n    mgv.setFee($(base), $(quote), testFee);\n\n    makers = setupMakerDeployer($(base), $(quote));\n    makers.deploy(4);\n    for (uint i = 1; i < makers.length(); i++) {\n      vm.label(\n        address(makers.getMaker(i)),\n        string.concat(\"maker-\", uint2str(i))\n      );\n    }\n    vm.label(address(makers.getMaker(0)), \"failer\");\n    taker = setupTaker($(base), $(quote), \"taker\");\n\n    deal(address(makers), 80 ether);\n    makers.dispatch();\n\n    for (uint i = 0; i < makers.length(); i++) {\n      TestMaker maker = makers.getMaker(i);\n      maker.provisionMgv(10 ether);\n      deal($(base), address(maker), 5 ether);\n    }\n\n    quote.mint(address(taker), 5 ether);\n    taker.approveMgv(quote, 5 ether);\n    taker.approveMgv(base, 50 ether);\n    saveBalances();\n  }\n\n  function test_snipe_insert_and_fail() public {\n    offerOf = insert();\n\n    saveBalances();\n    saveOffers();\n    expectFrom($(mgv));\n    emit OrderStart();\n    expectFrom($(mgv));\n    emit OrderComplete(\n      $(base),\n      $(quote),\n      address(taker),\n      0.291 ether, // should not be hardcoded\n      0.375 ether, // should not be hardcoded\n      0,\n      0.009 ether // should not be hardcoded\n    );\n\n    snipe();\n    logOfferBook($(base), $(quote), 4);\n\n    // restore offer that was deleted after partial fill, minus taken amount\n    makers.getMaker(2).updateOffer(\n      1 ether - 0.375 ether,\n      0.8 ether - 0.3 ether,\n      80_000,\n      0,\n      2\n    );\n\n    logOfferBook($(base), $(quote), 4);\n\n    saveBalances();\n    saveOffers();\n    mo();\n    logOfferBook($(base), $(quote), 4);\n\n    saveBalances();\n    saveOffers();\n    collectFailingOffer(offerOf[0]);\n    logOfferBook($(base), $(quote), 4);\n    saveBalances();\n    saveOffers();\n  }\n\n  /* **************** TEST ROUTINES ************* */\n\n  function collectFailingOffer(uint failingOfferId) internal {\n    // executing failing offer\n    try taker.takeWithInfo(failingOfferId, 0.5 ether) returns (\n      bool success,\n      uint takerGot,\n      uint takerGave,\n      uint,\n      uint\n    ) {\n      // take should return false not throw\n      assertTrue(!success, \"Failer should fail\");\n      assertEq(takerGot, 0, \"Failed offer should declare 0 takerGot\");\n      assertEq(takerGave, 0, \"Failed offer should declare 0 takerGave\");\n      // failingOffer should have been removed from Mgv\n      {\n        assertTrue(\n          !mgv.isLive(mgv.offers($(base), $(quote), failingOfferId)),\n          \"Failing offer should have been removed from Mgv\"\n        );\n      }\n      uint provision = getProvision(\n        $(base),\n        $(quote),\n        offers[failingOfferId][Info.gasreq]\n      );\n      uint returned = mgv.balanceOf(address(makers.getMaker(0))) -\n        balances.makersBalanceWei[0];\n      assertEq(\n        $(mgv).balance,\n        balances.mgvBalanceWei - (provision - returned),\n        \"Mangrove has not send the correct amount to taker\"\n      );\n    } catch (bytes memory errorMsg) {\n      string memory err = abi.decode(errorMsg, (string));\n      fail(err);\n    }\n  }\n\n  function insert() public returns (uint[] memory) {\n    // each maker publishes an offer\n    uint[] memory _offerOf = new uint[](makers.length());\n    _offerOf[1] = makers.getMaker(1).newOffer({ // offer 1\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 50_000,\n      pivotId: 0\n    });\n    _offerOf[2] = makers.getMaker(2).newOffer({ // offer 2\n      wants: 1 ether,\n      gives: 0.8 ether,\n      gasreq: 80_000,\n      pivotId: 1\n    });\n    _offerOf[3] = makers.getMaker(3).newOffer({ // offer 3\n      wants: 0.5 ether,\n      gives: 1 ether,\n      gasreq: 90_000,\n      pivotId: 72\n    });\n    (P.Global.t cfg, ) = mgv.config($(base), $(quote));\n    _offerOf[0] = makers.getMaker(0).newOffer({ //failer offer 4\n      wants: 20 ether,\n      gives: 10 ether,\n      gasreq: cfg.gasmax(),\n      pivotId: 0\n    });\n    //Checking makers have correctly provisoned their offers\n    for (uint i = 0; i < makers.length(); i++) {\n      uint gasreq_i = mgv.offerDetails($(base), $(quote), _offerOf[i]).gasreq();\n      uint provision_i = getProvision($(base), $(quote), gasreq_i);\n      assertEq(\n        mgv.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceWei[i] - provision_i,\n        string.concat(\"Incorrect wei balance for maker \", uint2str(i))\n      );\n    }\n    //Checking offers are correctly positioned (3 > 2 > 1 > 0)\n    uint offerId = mgv.best($(base), $(quote));\n    uint expected_maker = 3;\n    while (offerId != 0) {\n      (P.OfferStruct memory offer, P.OfferDetailStruct memory od) = mgv\n        .offerInfo($(base), $(quote), offerId);\n      assertEq(\n        od.maker,\n        address(makers.getMaker(expected_maker)),\n        string.concat(\"Incorrect maker address at offer \", uint2str(offerId))\n      );\n\n      unchecked {\n        expected_maker -= 1;\n      }\n      offerId = offer.next;\n    }\n    return _offerOf;\n  }\n\n  function mo() internal {\n    uint takerWants = 1.6 ether; // of B token\n    uint takerGives = 2 ether; // of A token\n\n    (uint takerGot, uint takerGave) = taker.marketOrder(takerWants, takerGives);\n\n    // Checking Makers balances\n    for (uint i = 2; i < 4; i++) {\n      // offers 2 and 3 were consumed entirely\n      assertEq(\n        base.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceA[i] - offers[i][Info.makerGives],\n        string.concat(\"Incorrect A balance for maker \", uint2str(i))\n      );\n      assertEq(\n        quote.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceB[i] + offers[i][Info.makerWants],\n        string.concat(\"Incorrect B balance for maker \", uint2str(i))\n      );\n    }\n    uint leftMkrWants;\n    {\n      uint leftTkrWants = takerWants -\n        (offers[2][Info.makerGives] + offers[3][Info.makerGives]);\n\n      leftMkrWants =\n        (offers[1][Info.makerWants] * leftTkrWants) /\n        offers[1][Info.makerGives];\n\n      assertEq(\n        base.balanceOf(address(makers.getMaker(1))),\n        balances.makersBalanceA[1] - leftTkrWants,\n        \"Incorrect A balance for maker 1\"\n      );\n    }\n\n    assertEq(\n      quote.balanceOf(address(makers.getMaker(1))),\n      balances.makersBalanceB[1] + leftMkrWants,\n      \"Incorrect B balance for maker 1\"\n    );\n\n    // Checking taker balance\n    assertEq(\n      base.balanceOf(address(taker)), // actual\n      balances.takerBalanceA + minusFee($(base), $(quote), takerWants), // expected\n      \"incorrect taker A balance\"\n    );\n\n    assertEq(\n      takerGot,\n      minusFee($(base), $(quote), takerWants),\n      \"Incorrect declared takerGot\"\n    );\n\n    uint shouldGive = (offers[3][Info.makerWants] +\n      offers[2][Info.makerWants] +\n      leftMkrWants);\n    assertEq(\n      quote.balanceOf(address(taker)), // actual\n      balances.takerBalanceB - shouldGive, // expected\n      \"incorrect taker B balance\"\n    );\n\n    assertEq(takerGave, shouldGive, \"Incorrect declared takerGave\");\n\n    // Checking DEX Fee Balance\n    assertEq(\n      base.balanceOf(mgv.governance()), //actual\n      balances.mgvBalanceFees + getFee($(base), $(quote), takerWants), //expected\n      \"incorrect Mangrove balances\"\n    );\n  }\n\n  struct Bag {\n    uint orderAmount;\n    uint snipedId;\n    uint expectedFee;\n  }\n\n  function snipe()\n    internal\n    returns (\n      uint takerGot,\n      uint takerGave,\n      uint expectedFee\n    )\n  {\n    Bag memory bag;\n    bag.orderAmount = 0.3 ether;\n    bag.snipedId = 2;\n    // uint orderAmount = 0.3 ether;\n    // uint snipedId = 2;\n    expectedFee = getFee($(base), $(quote), bag.orderAmount);\n    TestMaker maker = makers.getMaker(bag.snipedId); // maker whose offer will be sniped\n\n    //(uint init_mkr_wants, uint init_mkr_gives,,,,,)=mgv.getOfferInfo(2);\n    //---------------SNIPE------------------//\n    {\n      bool takeSuccess;\n      (takeSuccess, takerGot, takerGave, , ) = taker.takeWithInfo(\n        bag.snipedId,\n        bag.orderAmount\n      );\n\n      assertTrue(takeSuccess, \"snipe should be a success\");\n    }\n    assertEq(\n      base.balanceOf(mgv.governance()), //actual\n      balances.mgvBalanceFees + expectedFee, // expected\n      \"incorrect Mangrove A balance\"\n    );\n    assertEq(\n      base.balanceOf(address(taker)), // actual\n      balances.takerBalanceA + bag.orderAmount - expectedFee, // expected\n      \"incorrect taker A balance\"\n    );\n    assertEq(\n      takerGot,\n      bag.orderAmount - expectedFee, // expected\n      \"Incorrect takerGot\"\n    );\n    {\n      uint shouldGive = (bag.orderAmount *\n        offers[bag.snipedId][Info.makerWants]) /\n        offers[bag.snipedId][Info.makerGives];\n      assertEq(\n        quote.balanceOf(address(taker)),\n        balances.takerBalanceB - shouldGive,\n        \"incorrect taker B balance\"\n      );\n      assertEq(takerGave, shouldGive, \"Incorrect takerGave\");\n    }\n    assertEq(\n      base.balanceOf(address(maker)),\n      balances.makersBalanceA[bag.snipedId] - bag.orderAmount,\n      \"incorrect maker A balance\"\n    );\n    assertEq(\n      quote.balanceOf(address(maker)),\n      balances.makersBalanceB[bag.snipedId] +\n        (bag.orderAmount * offers[bag.snipedId][Info.makerWants]) /\n        offers[bag.snipedId][Info.makerGives],\n      \"incorrect maker B balance\"\n    );\n    // Testing residual offer\n    (P.OfferStruct memory ofr, ) = mgv.offerInfo(\n      $(base),\n      $(quote),\n      bag.snipedId\n    );\n    assertTrue(ofr.gives == 0, \"Offer should not have a residual\");\n  }\n}\n\ncontract DeepCollectTest is MangroveTest {\n  TestTaker tkr;\n  TestMoriartyMaker evil;\n\n  //receive() external payable {}\n\n  function setUp() public override {\n    super.setUp();\n    tkr = setupTaker($(base), $(quote), \"taker\");\n\n    deal($(quote), address(tkr), 5 ether);\n    tkr.approveMgv(quote, 20 ether);\n    tkr.approveMgv(base, 20 ether);\n\n    evil = new TestMoriartyMaker(mgv, $(base), $(quote));\n    vm.label(address(evil), \"Moriarty\");\n    deal(address(evil), 20 ether);\n    evil.provisionMgv(10 ether);\n    deal($(base), address(evil), 5 ether);\n    evil.approveMgv(base, 5 ether);\n\n    evil.newOffer({\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 100000,\n      pivotId: 0\n    });\n  }\n\n  function test_market_with_failures() public {\n    moWithFailures();\n  }\n\n  function moWithFailures() internal {\n    tkr.marketOrderWithFail({wants: 10 ether, gives: 30 ether});\n    assertTrue(isEmptyOB($(base), $(quote)), \"Offer book should be empty\");\n  }\n}\n"
    },
    "contracts/test/core/Monitor.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\ncontract MonitorTest is MangroveTest {\n  TestMaker mkr;\n\n  bytes monitor_read_cd;\n  address monitor;\n\n  receive() external payable {}\n\n  function setUp() public override {\n    super.setUp();\n\n    mkr = setupMaker($(base), $(quote), \"Maker[$(A),$(B)]\");\n\n    monitor = freshAddress();\n    monitor_read_cd = abi.encodeCall(IMgvMonitor.read, ($(base), $(quote)));\n\n    mkr.provisionMgv(5 ether);\n\n    deal($(base), address(mkr), 2 ether);\n  }\n\n  function test_initial_monitor_values() public {\n    (P.Global.t config, ) = mgv.config($(base), $(quote));\n    assertTrue(!config.useOracle(), \"initial useOracle should be false\");\n    assertTrue(!config.notify(), \"initial notify should be false\");\n  }\n\n  function test_set_monitor_values() public {\n    mgv.setMonitor(monitor);\n    mgv.setUseOracle(true);\n    mgv.setNotify(true);\n    expectToMockCall(monitor, monitor_read_cd, abi.encode(0, 0));\n    (P.Global.t config, ) = mgv.config($(base), $(quote));\n    assertEq(config.monitor(), monitor, \"monitor should be set\");\n    assertTrue(config.useOracle(), \"useOracle should be set\");\n    assertTrue(config.notify(), \"notify should be set\");\n  }\n\n  function test_set_oracle_density_with_useOracle_works() public {\n    mgv.setMonitor(monitor);\n    mgv.setUseOracle(true);\n    mgv.setDensity($(base), $(quote), 898);\n    expectToMockCall(monitor, monitor_read_cd, abi.encode(0, 1));\n    (, P.Local.t config) = mgv.config($(base), $(quote));\n    assertEq(config.density(), 1, \"density should be set oracle\");\n  }\n\n  function test_set_oracle_density_without_useOracle_fails() public {\n    mgv.setMonitor(monitor);\n    mgv.setDensity($(base), $(quote), 898);\n    (, P.Local.t config) = mgv.config($(base), $(quote));\n    assertEq(config.density(), 898, \"density should be set by mgv\");\n  }\n\n  function test_set_oracle_gasprice_with_useOracle_works() public {\n    mgv.setMonitor(monitor);\n    mgv.setDensity($(base), $(quote), 898);\n    mgv.setUseOracle(true);\n    mgv.setGasprice(900);\n    expectToMockCall(monitor, monitor_read_cd, abi.encode(1, 0));\n    (P.Global.t config, ) = mgv.config($(base), $(quote));\n    assertEq(config.gasprice(), 1, \"gasprice should be set by oracle\");\n  }\n\n  function test_set_oracle_gasprice_without_useOracle_fails() public {\n    mgv.setMonitor(monitor);\n    mgv.setGasprice(900);\n    (P.Global.t config, ) = mgv.config($(base), $(quote));\n    assertEq(config.gasprice(), 900, \"gasprice should be set by mgv\");\n  }\n\n  function test_invalid_oracle_address_throws() public {\n    mgv.setMonitor(monitor);\n    mgv.setUseOracle(true);\n    vm.expectCall(monitor, monitor_read_cd);\n    vm.expectRevert(bytes(\"\"));\n    mgv.config($(base), $(quote));\n  }\n\n  function test_notify_works_on_success_when_set() public {\n    deal($(quote), $(this), 10 ether);\n    mkr.approveMgv(base, 1 ether);\n    mgv.setMonitor(monitor);\n    mgv.setNotify(true);\n    uint ofrId = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofrId);\n\n    uint[4][] memory targets = wrap_dynamic(\n      [ofrId, 0.04 ether, 0.05 ether, 100_000]\n    );\n\n    (P.Global.t _global, P.Local.t _local) = mgv.config($(base), $(quote));\n    _local = _local.best(1).lock(true);\n\n    MgvLib.SingleOrder memory order = MgvLib.SingleOrder({\n      outbound_tkn: $(base),\n      inbound_tkn: $(quote),\n      offerId: ofrId,\n      offer: offer,\n      wants: 0.04 ether,\n      gives: 0.04 ether, // wants has been updated to offer price\n      offerDetail: mgv.offerDetails($(base), $(quote), ofrId),\n      global: _global,\n      local: _local\n    });\n\n    expectToMockCall(\n      monitor,\n      abi.encodeCall(IMgvMonitor.notifySuccess, (order, $(this))),\n      bytes(\"\")\n    );\n\n    (uint successes, , , , ) = mgv.snipes($(base), $(quote), targets, true);\n    assertTrue(successes == 1, \"snipe should succeed\");\n  }\n\n  function test_notify_works_on_fail_when_set() public {\n    deal($(quote), $(this), 10 ether);\n    mgv.setMonitor(address(monitor));\n    mgv.setNotify(true);\n    uint ofrId = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofrId);\n    P.OfferDetail.t offerDetail = mgv.offerDetails($(base), $(quote), ofrId);\n\n    uint[4][] memory targets = wrap_dynamic(\n      [ofrId, 0.04 ether, 0.05 ether, 100_000]\n    );\n\n    (P.Global.t _global, P.Local.t _local) = mgv.config($(base), $(quote));\n    // config sent during maker callback has stale best and, is locked\n    _local = _local.best(1).lock(true);\n\n    MgvLib.SingleOrder memory order = MgvLib.SingleOrder({\n      outbound_tkn: $(base),\n      inbound_tkn: $(quote),\n      offerId: ofrId,\n      offer: offer,\n      wants: 0.04 ether,\n      gives: 0.04 ether, // gives has been updated to offer price\n      offerDetail: offerDetail, // gasprice logged will still be as before failure\n      global: _global,\n      local: _local\n    });\n\n    expectToMockCall(\n      monitor,\n      abi.encodeCall(IMgvMonitor.notifyFail, (order, $(this))),\n      bytes(\"\")\n    );\n\n    (uint successes, , , , ) = mgv.snipes($(base), $(quote), targets, true);\n    assertTrue(successes == 0, \"snipe should fail\");\n  }\n}\n"
    },
    "contracts/test/core/MakerPosthook.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\ncontract MakerPosthookTest is MangroveTest, IMaker {\n  TestTaker tkr;\n  uint gasreq = 200_000;\n  uint ofr;\n  uint _gasprice = 50; // will cover for a gasprice of 50 gwei/gas uint\n  uint weiBalMaker;\n  bool willFail = false;\n  bool makerRevert = false;\n  bool called;\n  string sExecuteRevertData = \"NOK\";\n  bytes32 bExecuteRevertData = \"NOK\";\n  bytes32 executeReturnData = \"NOK\";\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function makerExecute(MgvLib.SingleOrder calldata trade)\n    external\n    override\n    returns (bytes32)\n  {\n    require(msg.sender == $(mgv));\n    if (makerRevert) {\n      revert(sExecuteRevertData);\n    }\n    emit Execute(\n      msg.sender,\n      trade.outbound_tkn,\n      trade.inbound_tkn,\n      trade.offerId,\n      trade.wants,\n      trade.gives\n    );\n    return executeReturnData;\n  }\n\n  function renew_offer_at_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) internal {\n    called = true;\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      order.offerId,\n      order.offerId\n    );\n  }\n\n  function update_gas_offer_at_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) internal {\n    called = true;\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      order.offerId,\n      order.offerId\n    );\n  }\n\n  function failer_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) internal {\n    called = true;\n    fail(\"Posthook should not be called\");\n  }\n\n  function retractOffer_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) internal {\n    called = true;\n    uint bal = mgv.balanceOf($(this));\n    mgv.retractOffer($(base), $(quote), ofr, true);\n    if (makerRevert) {\n      assertEq(\n        bal,\n        mgv.balanceOf($(this)),\n        \"Cancel offer of a failed offer should not give provision to maker\"\n      );\n    }\n  }\n\n  function(MgvLib.SingleOrder calldata, MgvLib.OrderResult calldata) _posthook;\n\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external override {\n    require(msg.sender == $(mgv));\n    bool success = (result.mgvData == \"mgv/tradeSuccess\");\n    assertEq(success, !(makerRevert || willFail), \"incorrect success flag\");\n    if (makerRevert) {\n      assertEq(\n        result.mgvData,\n        \"mgv/makerRevert\",\n        \"mgvData should be makerRevert\"\n      );\n    } else {\n      assertEq(\n        result.mgvData,\n        bytes32(\"mgv/tradeSuccess\"),\n        \"mgvData should be tradeSuccess\"\n      );\n    }\n    assertTrue(\n      !mgv.isLive(\n        mgv.offers(order.outbound_tkn, order.inbound_tkn, order.offerId)\n      ),\n      \"Offer was not removed after take\"\n    );\n    _posthook(order, result);\n  }\n\n  function setUp() public override {\n    super.setUp();\n\n    tkr = setupTaker($(base), $(quote), \"Taker\");\n    deal($(base), $(this), 5 ether);\n    deal($(quote), address(tkr), 1 ether);\n\n    tkr.approveMgv(base, 1 ether); // takerFee\n    tkr.approveMgv(quote, 1 ether);\n\n    weiBalMaker = mgv.balanceOf($(this));\n  }\n\n  function test_renew_offer_after_partial_fill() public {\n    uint mkr_provision = getProvision($(base), $(quote), gasreq, _gasprice);\n    _posthook = renew_offer_at_posthook;\n\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      $(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n    bool success = tkr.take(ofr, 0.5 ether);\n    assertTrue(success, \"Snipe should succeed\");\n    assertTrue(called, \"PostHook not called\");\n\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    assertEq(\n      mgv.offers($(base), $(quote), ofr).gives(),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n  }\n\n  function test_renew_offer_after_complete_fill() public {\n    uint mkr_provision = getProvision($(base), $(quote), gasreq, _gasprice);\n    _posthook = renew_offer_at_posthook;\n\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      $(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(called, \"PostHook not called\");\n    assertTrue(success, \"Snipe should succeed\");\n\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    assertEq(\n      mgv.offers($(base), $(quote), ofr).gives(),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n  }\n\n  function test_renew_offer_after_failed_execution() public {\n    _posthook = renew_offer_at_posthook;\n\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    makerRevert = true;\n\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      $(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(!success, \"Snipe should fail\");\n    assertTrue(called, \"PostHook not called\");\n\n    assertEq(\n      mgv.offers($(base), $(quote), ofr).gives(),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n  }\n\n  function treat_fail_at_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata res\n  ) internal {\n    bool success = (res.mgvData == \"mgv/tradeSuccess\");\n    assertTrue(!success, \"Offer should be marked as failed\");\n    assertTrue(res.makerData == bExecuteRevertData, \"Incorrect maker data\");\n  }\n\n  function test_failed_offer_truncates() public {\n    sExecuteRevertData = \"abcdefghijklmnopqrstuvwxyz1234567\";\n    bExecuteRevertData = \"abcdefghijklmnopqrstuvwxyz123456\";\n    uint balMaker = base.balanceOf($(this));\n    uint balTaker = quote.balanceOf(address(tkr));\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    makerRevert = true;\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    bool success = tkr.take(ofr, 1 ether);\n    assertTrue(!success, \"Snipe should fail\");\n    assertEq(\n      base.balanceOf($(this)),\n      balMaker,\n      \"Maker should not have been debited of her base tokens\"\n    );\n    assertEq(\n      quote.balanceOf(address(tkr)),\n      balTaker,\n      \"Taker should not have been debited of her quote tokens\"\n    );\n  }\n\n  function test_failed_offer_is_not_executed() public {\n    _posthook = treat_fail_at_posthook;\n    uint balMaker = base.balanceOf($(this));\n    uint balTaker = quote.balanceOf(address(tkr));\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    makerRevert = true;\n\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    bool success = tkr.take(ofr, 1 ether);\n    assertTrue(!success, \"Snipe should fail\");\n    assertEq(\n      base.balanceOf($(this)),\n      balMaker,\n      \"Maker should not have been debited of her base tokens\"\n    );\n    assertEq(\n      quote.balanceOf(address(tkr)),\n      balTaker,\n      \"Taker should not have been debited of her quote tokens\"\n    );\n  }\n\n  function test_update_offer_with_more_gasprice() public {\n    uint mkr_provision = getProvision($(base), $(quote), gasreq, _gasprice);\n    uint standard_provision = getProvision($(base), $(quote), gasreq);\n    _posthook = update_gas_offer_at_posthook;\n    // provision for mgv.global.gasprice\n    ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, gasreq, 0, 0);\n\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - standard_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      $(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(success, \"Snipe should succeed\");\n    assertTrue(called, \"PostHook not called\");\n\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    assertEq(\n      mgv.offers($(base), $(quote), ofr).gives(),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n  }\n\n  function test_posthook_of_skipped_offer_wrong_gas_should_not_be_called()\n    public\n  {\n    _posthook = failer_posthook;\n\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n\n    bool success = tkr.snipe(\n      mgv,\n      $(base),\n      $(quote),\n      ofr,\n      1 ether,\n      1 ether,\n      gasreq - 1\n    );\n    assertTrue(!called, \"PostHook was called\");\n    assertTrue(!success, \"Snipe should fail\");\n  }\n\n  function test_posthook_of_skipped_offer_wrong_price_should_not_be_called()\n    public\n  {\n    _posthook = failer_posthook;\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    bool success = tkr.snipe(\n      mgv,\n      $(base),\n      $(quote),\n      ofr,\n      1.1 ether,\n      1 ether,\n      gasreq\n    );\n    assertTrue(!success, \"Snipe should fail\");\n    assertTrue(!called, \"PostHook was called\");\n  }\n\n  function test_retract_offer_in_posthook() public {\n    uint mkr_provision = getProvision($(base), $(quote), gasreq, _gasprice);\n    _posthook = retractOffer_posthook;\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    expectFrom($(mgv));\n    emit OfferSuccess($(base), $(quote), ofr, address(tkr), 1 ether, 1 ether);\n    expectFrom($(mgv));\n    emit Credit($(this), mkr_provision);\n    expectFrom($(mgv));\n    emit OfferRetract($(base), $(quote), ofr);\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(success, \"Snipe should succeed\");\n    assertTrue(called, \"PostHook not called\");\n\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker, // provision returned to taker\n      \"Incorrect maker balance after take\"\n    );\n  }\n\n  function test_balance_after_fail_and_retract() public {\n    uint mkr_provision = getProvision($(base), $(quote), gasreq, _gasprice);\n    uint tkr_weis = address(tkr).balance;\n    _posthook = retractOffer_posthook;\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    makerRevert = true;\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    expectFrom($(mgv));\n    emit OfferRetract($(base), $(quote), ofr);\n    //TODO: when events can be checked instead of expected, take given penalty instead of ignoring it\n    vm.expectEmit(true, true, true, false, $(mgv));\n    emit Credit(\n      $(this),\n      0 /*penalty*/\n    );\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(!success, \"Snipe should fail\");\n    uint penalty = weiBalMaker - mgv.balanceOf($(this));\n    assertEq(\n      penalty,\n      address(tkr).balance - tkr_weis,\n      \"Incorrect overall balance after penalty for taker\"\n    );\n  }\n\n  function test_update_offer_after_deprovision_in_posthook_succeeds() public {\n    _posthook = retractOffer_posthook;\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    expectFrom($(mgv));\n    emit OfferSuccess($(base), $(quote), ofr, address(tkr), 1 ether, 1 ether);\n    expectFrom($(mgv));\n    emit OfferRetract($(base), $(quote), ofr);\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(called, \"PostHook not called\");\n\n    assertTrue(success, \"Snipe should succeed\");\n    mgv.updateOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0,\n      ofr\n    );\n  }\n\n  function check_best_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) internal {\n    called = true;\n    (, P.Local.t cfg) = mgv.config(order.outbound_tkn, order.inbound_tkn);\n    assertEq(cfg.best(), ofr, \"Incorrect best offer id in posthook\");\n  }\n\n  function test_best_in_posthook_is_correct() public {\n    mgv.newOffer($(base), $(quote), 2 ether, 1 ether, gasreq, _gasprice, 0);\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    uint best = mgv.newOffer(\n      $(base),\n      $(quote),\n      0.5 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    _posthook = check_best_in_posthook;\n    bool success = tkr.take(best, 1 ether);\n    assertTrue(called, \"PostHook not called\");\n    assertTrue(success, \"Snipe should succeed\");\n  }\n\n  function check_offer_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) internal {\n    called = true;\n    uint __wants = order.offer.wants();\n    uint __gives = order.offer.gives();\n    address __maker = order.offerDetail.maker();\n    uint __gasreq = order.offerDetail.gasreq();\n    uint __gasprice = order.offerDetail.gasprice();\n    assertEq(__wants, 1 ether, \"Incorrect wants for offer in posthook\");\n    assertEq(__gives, 2 ether, \"Incorrect gives for offer in posthook\");\n    assertEq(__gasprice, 500, \"Incorrect gasprice for offer in posthook\");\n    assertEq(__maker, $(this), \"Incorrect maker address\");\n    assertEq(__gasreq, gasreq, \"Incorrect gasreq\");\n  }\n\n  function test_check_offer_in_posthook() public {\n    ofr = mgv.newOffer($(base), $(quote), 1 ether, 2 ether, gasreq, 500, 0);\n    _posthook = check_offer_in_posthook;\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(called, \"PostHook not called\");\n    assertTrue(success, \"Snipe should succeed\");\n  }\n\n  function check_lastId_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) internal {\n    called = true;\n    (, P.Local.t cfg) = mgv.config(order.outbound_tkn, order.inbound_tkn);\n    assertEq(cfg.last(), ofr, \"Incorrect last offer id in posthook\");\n  }\n\n  function test_lastId_in_posthook_is_correct() public {\n    mgv.newOffer($(base), $(quote), 1 ether, 1 ether, gasreq, _gasprice, 0);\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      0.5 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    _posthook = check_lastId_in_posthook;\n    bool success = tkr.take(ofr, 1 ether);\n    assertTrue(called, \"PostHook not called\");\n    assertTrue(success, \"Snipe should succeed\");\n  }\n\n  function test_retract_offer_after_fail_in_posthook() public {\n    uint mkr_provision = getProvision($(base), $(quote), gasreq, _gasprice);\n    _posthook = retractOffer_posthook;\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    assertEq(\n      mgv.balanceOf($(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    makerRevert = true; // maker should fail\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    expectFrom($(mgv));\n    emit OfferRetract($(base), $(quote), ofr);\n    //TODO: when events can be checked instead of expected, take given penalty instead of ignoring it\n    vm.expectEmit(true, true, true, false, $(mgv));\n    emit Credit(\n      $(this),\n      0 /*refund*/\n    );\n    bool success = tkr.take(ofr, 2 ether);\n    assertTrue(called, \"PostHook not called\");\n\n    assertTrue(!success, \"Snipe should fail\");\n\n    assertLt(\n      mgv.balanceOf($(this)),\n      weiBalMaker,\n      \"Maker balance after take should be less than original balance\"\n    );\n  }\n\n  function test_makerRevert_is_logged() public {\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    makerRevert = true; // maker should fail\n    bool success;\n    expectFrom($(mgv));\n    emit OfferFail(\n      $(base),\n      $(quote),\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    success = tkr.take(ofr, 2 ether);\n  }\n\n  function reverting_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) internal pure {\n    assert(false);\n  }\n\n  function test_reverting_posthook_does_not_revert_offer() public {\n    getProvision($(base), $(quote), gasreq, _gasprice);\n    uint balMaker = base.balanceOf($(this));\n    uint balTaker = quote.balanceOf(address(tkr));\n    _posthook = reverting_posthook;\n\n    ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    bool success = tkr.take(ofr, 1 ether);\n    assertTrue(success, \"snipe should succeed\");\n    assertEq(\n      balMaker - 1 ether,\n      base.balanceOf($(this)),\n      \"Incorrect maker balance\"\n    );\n    assertEq(\n      balTaker - 1 ether,\n      quote.balanceOf(address(tkr)),\n      \"Incorrect taker balance\"\n    );\n  }\n}\n"
    },
    "contracts/test/core/MakerOperations.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\ncontract MakerOperationsTest is MangroveTest, IMaker {\n  TestMaker mkr;\n  TestMaker mkr2;\n  TestTaker tkr;\n\n  function setUp() public override {\n    super.setUp();\n\n    mkr = setupMaker($(base), $(quote), \"maker\");\n    mkr2 = setupMaker($(base), $(quote), \"maker2\");\n    tkr = setupTaker($(base), $(quote), \"taker\");\n\n    mkr.approveMgv(base, 10 ether);\n    mkr2.approveMgv(base, 10 ether);\n\n    deal($(quote), address(tkr), 1 ether);\n    tkr.approveMgv(quote, 1 ether);\n  }\n\n  function test_provision_adds_mgv_balance_and_ethers() public {\n    uint mgv_bal = $(mgv).balance;\n    uint amt1 = 235;\n    uint amt2 = 1.3 ether;\n\n    mkr.provisionMgv(amt1);\n\n    assertEq(mkr.mgvBalance(), amt1, \"incorrect mkr mgvBalance amount (1)\");\n    assertEq($(mgv).balance, mgv_bal + amt1, \"incorrect mgv ETH balance (1)\");\n\n    mkr.provisionMgv(amt2);\n\n    assertEq(\n      mkr.mgvBalance(),\n      amt1 + amt2,\n      \"incorrect mkr mgvBalance amount (2)\"\n    );\n    assertEq(\n      $(mgv).balance,\n      mgv_bal + amt1 + amt2,\n      \"incorrect mgv ETH balance (2)\"\n    );\n  }\n\n  // since we check calldata, execute must be internal\n  function makerExecute(MgvLib.SingleOrder calldata order)\n    external\n    returns (bytes32 ret)\n  {\n    ret; // silence unused function parameter warning\n    uint num_args = 9;\n    uint selector_bytes = 4;\n    uint length = selector_bytes + num_args * 32;\n    assertEq(\n      msg.data.length,\n      length,\n      \"calldata length in execute is incorrect\"\n    );\n\n    assertEq(order.outbound_tkn, $(base), \"wrong base\");\n    assertEq(order.inbound_tkn, $(quote), \"wrong quote\");\n    assertEq(order.wants, 0.05 ether, \"wrong takerWants\");\n    assertEq(order.gives, 0.05 ether, \"wrong takerGives\");\n    assertEq(order.offerDetail.gasreq(), 200_000, \"wrong gasreq\");\n    assertEq(order.offerId, 1, \"wrong offerId\");\n    assertEq(order.offer.wants(), 0.05 ether, \"wrong offerWants\");\n    assertEq(order.offer.gives(), 0.05 ether, \"wrong offerGives\");\n    // test flashloan\n    assertEq(quote.balanceOf($(this)), 0.05 ether, \"wrong quote balance\");\n    return \"\";\n  }\n\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external {}\n\n  function test_calldata_and_balance_in_makerExecute_are_correct() public {\n    bool funded;\n    (funded, ) = $(mgv).call{value: 1 ether}(\"\");\n    deal($(base), $(this), 1 ether);\n    uint ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      0.05 ether,\n      0.05 ether,\n      200_000,\n      0,\n      0\n    );\n    require(tkr.take(ofr, 0.05 ether), \"take must work or test is void\");\n  }\n\n  function test_withdraw_removes_mgv_balance_and_ethers() public {\n    uint mgv_bal = $(mgv).balance;\n    uint amt1 = 0.86 ether;\n    uint amt2 = 0.12 ether;\n\n    mkr.provisionMgv(amt1);\n    bool success = mkr.withdrawMgv(amt2);\n    assertTrue(success, \"mkr was not able to withdraw from mgv\");\n    assertEq(mkr.mgvBalance(), amt1 - amt2, \"incorrect mkr mgvBalance amount\");\n    assertEq(\n      $(mgv).balance,\n      mgv_bal + amt1 - amt2,\n      \"incorrect mgv ETH balance\"\n    );\n  }\n\n  function test_withdraw_too_much_fails() public {\n    uint amt1 = 6.003 ether;\n    mkr.provisionMgv(amt1);\n    vm.expectRevert(\"mgv/insufficientProvision\");\n    mkr.withdrawMgv(amt1 + 1);\n  }\n\n  function test_newOffer_without_mgv_balance_fails() public {\n    vm.expectRevert(\"mgv/insufficientProvision\");\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n  }\n\n  function test_fund_newOffer() public {\n    uint oldBal = mgv.balanceOf(address(mkr));\n    expectFrom($(mgv));\n    emit Credit(address(mkr), 1 ether);\n    mkr.newOfferWithFunding(1 ether, 1 ether, 50000, 0, 1 ether);\n    assertGt(\n      mgv.balanceOf(address(mkr)),\n      oldBal,\n      \"balance should have increased\"\n    );\n  }\n\n  function test_fund_updateOffer() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n    expectFrom($(mgv));\n    emit Credit(address(mkr), 0.9 ether);\n    mkr.updateOfferWithFunding(1 ether, 1 ether, 50000, 0, ofr, 0.9 ether);\n  }\n\n  function test_posthook_fail_message() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n\n    mkr.setShouldFailHook(true);\n    expectFrom($(mgv));\n    emit PosthookFail($(base), $(quote), ofr, \"posthookFail\");\n    tkr.take(ofr, 0.1 ether); // fails but we don't care\n  }\n\n  function test_badReturn_succeeds() public {\n    mkr.provisionMgv(1 ether);\n    deal($(base), address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n\n    mkr.shouldAbort(true);\n    bool success = tkr.take(ofr, 0.1 ether);\n    assertTrue(success, \"take should fail\");\n  }\n\n  function test_delete_restores_balance() public {\n    mkr.provisionMgv(1 ether);\n    uint bal = mkr.mgvBalance(); // should be 1 ether\n    uint offerId = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    uint bal_ = mkr.mgvBalance(); // 1 ether minus provision\n    uint collected = mkr.retractOfferWithDeprovision(offerId); // provision\n    assertEq(bal - bal_, collected, \"retract does not return a correct amount\");\n    assertEq(mkr.mgvBalance(), bal, \"delete has not restored balance\");\n  }\n\n  function test_delete_offer_log() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    expectFrom($(mgv));\n    emit OfferRetract($(base), $(quote), ofr);\n    mkr.retractOfferWithDeprovision(ofr);\n  }\n\n  function test_retract_retracted_does_not_drain() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n\n    mkr.retractOffer(ofr);\n\n    uint bal1 = mgv.balanceOf(address(mkr));\n    uint collected = mkr.retractOfferWithDeprovision(ofr);\n    assertTrue(collected > 0, \"deprovision should give credit\");\n    uint bal2 = mgv.balanceOf(address(mkr));\n    assertLt(bal1, bal2, \"Balance should have increased\");\n\n    uint collected2 = mkr.retractOfferWithDeprovision(ofr);\n    assertTrue(collected2 == 0, \"second deprovision should not give credit\");\n    uint bal3 = mgv.balanceOf(address(mkr));\n    assertEq(bal3, bal2, \"Balance should not have increased\");\n  }\n\n  function test_retract_taken_does_not_drain() public {\n    mkr.provisionMgv(1 ether);\n    deal($(base), address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    bool success = tkr.take(ofr, 0.1 ether);\n    assertEq(success, true, \"Snipe should succeed\");\n\n    uint bal1 = mgv.balanceOf(address(mkr));\n    mkr.retractOfferWithDeprovision(ofr);\n    uint bal2 = mgv.balanceOf(address(mkr));\n    assertLt(bal1, bal2, \"Balance should have increased\");\n\n    uint collected = mkr.retractOfferWithDeprovision(ofr);\n    assertTrue(collected == 0, \"second deprovision should not give credit\");\n    uint bal3 = mgv.balanceOf(address(mkr));\n    assertEq(bal3, bal2, \"Balance should not have increased\");\n  }\n\n  function test_retract_offer_log() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    expectFrom($(mgv));\n    emit OfferRetract($(base), $(quote), ofr);\n    mkr.retractOffer(ofr);\n  }\n\n  function test_retract_offer_maintains_balance() public {\n    mkr.provisionMgv(1 ether);\n    uint bal = mkr.mgvBalance();\n    uint prov = getProvision($(base), $(quote), 2300);\n    mkr.retractOffer(mkr.newOffer(1 ether, 1 ether, 2300, 0));\n    assertEq(mkr.mgvBalance(), bal - prov, \"unexpected maker balance\");\n  }\n\n  function test_retract_middle_offer_leaves_a_valid_book() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 2300, 100);\n\n    mkr.retractOffer(ofr);\n    assertTrue(\n      !mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer was not removed from OB\"\n    );\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr);\n    P.OfferDetail.t detail = mgv.offerDetails($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr0, \"Invalid prev\");\n    assertEq(offer.next(), ofr1, \"Invalid next\");\n    assertEq(offer.gives(), 0, \"offer gives was not set to 0\");\n    assertEq(detail.gasprice(), 100, \"offer gasprice is incorrect\");\n\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), offer.prev())),\n      \"Invalid OB\"\n    );\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), offer.next())),\n      \"Invalid OB\"\n    );\n    P.Offer.t offer0 = mgv.offers($(base), $(quote), offer.prev());\n    P.Offer.t offer1 = mgv.offers($(base), $(quote), offer.next());\n\n    assertEq(offer1.prev(), ofr0, \"Invalid snitching for ofr1\");\n    assertEq(offer0.next(), ofr1, \"Invalid snitching for ofr0\");\n  }\n\n  function test_retract_best_offer_leaves_a_valid_book() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 2300, 100);\n    mkr.retractOffer(ofr);\n    assertTrue(\n      !mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer was not removed from OB\"\n    );\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr);\n    P.OfferDetail.t detail = mgv.offerDetails($(base), $(quote), ofr);\n    assertEq(offer.prev(), 0, \"Invalid prev\");\n    assertEq(offer.next(), ofr1, \"Invalid next\");\n    assertEq(offer.gives(), 0, \"offer gives was not set to 0\");\n    assertEq(detail.gasprice(), 100, \"offer gasprice is incorrect\");\n\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), offer.next())),\n      \"Invalid OB\"\n    );\n    P.Offer.t offer1 = mgv.offers($(base), $(quote), offer.next());\n    assertEq(offer1.prev(), 0, \"Invalid snitching for ofr1\");\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(cfg.best(), ofr1, \"Invalid best after retract\");\n  }\n\n  function test_retract_worst_offer_leaves_a_valid_book() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr0 = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer was not removed from OB\"\n    );\n    mkr.retractOffer(ofr);\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr);\n    P.OfferDetail.t detail = mgv.offerDetails($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr0, \"Invalid prev\");\n    assertEq(offer.next(), 0, \"Invalid next\");\n    assertEq(offer.gives(), 0, \"offer gives was not set to 0\");\n    assertEq(detail.gasprice(), 100, \"offer gasprice is incorrect\");\n\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), offer.prev())),\n      \"Invalid OB\"\n    );\n    P.Offer.t offer0 = mgv.offers($(base), $(quote), offer.prev());\n    assertEq(offer0.next(), 0, \"Invalid snitching for ofr0\");\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(cfg.best(), ofr0, \"Invalid best after retract\");\n  }\n\n  function test_delete_wrong_offer_fails() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    vm.expectRevert(\"mgv/retractOffer/unauthorized\");\n    mkr2.retractOfferWithDeprovision(ofr);\n  }\n\n  function test_retract_wrong_offer_fails() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    vm.expectRevert(\"mgv/retractOffer/unauthorized\");\n    mkr2.retractOffer(ofr);\n  }\n\n  function test_gasreq_max_with_newOffer_ok() public {\n    mkr.provisionMgv(1 ether);\n    uint gasmax = 750000;\n    mgv.setGasmax(gasmax);\n    mkr.newOffer(1 ether, 1 ether, gasmax, 0);\n  }\n\n  function test_gasreq_too_high_fails_newOffer() public {\n    uint gasmax = 12;\n    mgv.setGasmax(gasmax);\n    vm.expectRevert(\"mgv/writeOffer/gasreq/tooHigh\");\n    mkr.newOffer(1 ether, 1 ether, gasmax + 1, 0);\n  }\n\n  function test_min_density_with_newOffer_ok() public {\n    mkr.provisionMgv(1 ether);\n    uint density = 10**7;\n    mgv.setGasbase($(base), $(quote), 1);\n    mgv.setDensity($(base), $(quote), density);\n    mkr.newOffer(1 ether, density, 0, 0);\n  }\n\n  function test_low_density_fails_newOffer() public {\n    uint density = 10**7;\n    mgv.setGasbase($(base), $(quote), 1);\n    mgv.setDensity($(base), $(quote), density);\n    vm.expectRevert(\"mgv/writeOffer/density/tooLow\");\n    mkr.newOffer(1 ether, density - 1, 0, 0);\n  }\n\n  function test_maker_gets_no_mgv_balance_on_partial_fill() public {\n    mkr.provisionMgv(1 ether);\n    deal($(base), address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldBalance = mgv.balanceOf(address(mkr));\n    bool success = tkr.take(ofr, 0.1 ether);\n    assertTrue(success, \"take must succeed\");\n    assertEq(\n      mgv.balanceOf(address(mkr)),\n      oldBalance,\n      \"mkr balance must not change\"\n    );\n  }\n\n  function test_maker_gets_no_mgv_balance_on_full_fill() public {\n    mkr.provisionMgv(1 ether);\n    deal($(base), address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldBalance = mgv.balanceOf(address(mkr));\n    bool success = tkr.take(ofr, 1 ether);\n    assertTrue(success, \"take must succeed\");\n    assertEq(\n      mgv.balanceOf(address(mkr)),\n      oldBalance,\n      \"mkr balance must not change\"\n    );\n  }\n\n  function test_insertions_are_correctly_ordered() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    uint ofr01 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t loc_cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, loc_cfg.best(), \"Wrong best offer\");\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr0)),\n      \"Oldest equivalent offer should be first\"\n    );\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr0);\n    uint _ofr01 = offer.next();\n    assertEq(_ofr01, ofr01, \"Wrong 2nd offer\");\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), _ofr01)),\n      \"Oldest equivalent offer should be first\"\n    );\n    offer = mgv.offers($(base), $(quote), _ofr01);\n    uint _ofr1 = offer.next();\n    assertEq(_ofr1, ofr1, \"Wrong 3rd offer\");\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), _ofr1)),\n      \"Oldest equivalent offer should be first\"\n    );\n    offer = mgv.offers($(base), $(quote), _ofr1);\n    uint _ofr2 = offer.next();\n    assertEq(_ofr2, ofr2, \"Wrong 4th offer\");\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), _ofr2)),\n      \"Oldest equivalent offer should be first\"\n    );\n    offer = mgv.offers($(base), $(quote), _ofr2);\n    assertEq(offer.next(), 0, \"Invalid OB\");\n  }\n\n  // insertTest price, density (gives/gasreq) vs (gives'/gasreq'), age\n  // nolongerBest\n  // idemPrice\n  // idemBest\n  // A.BCD --> ABC.D\n\n  function test_update_offer_resets_age_and_updates_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr1, cfg.best(), \"Best offer should have changed\");\n  }\n\n  function test_update_offer_price_nolonger_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether + 1, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr1, cfg.best(), \"Best offer should have changed\");\n  }\n\n  function test_update_offer_density_nolonger_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr0);\n    (, cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr1, cfg.best(), \"Best offer should have changed\");\n  }\n\n  function test_update_offer_price_with_self_as_pivot_becomes_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether + 1, 100_000, ofr1, ofr1);\n    (, cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr1, cfg.best(), \"Best offer should have changed\");\n  }\n\n  function test_update_offer_density_with_self_as_pivot_becomes_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 99_999, ofr1, ofr1);\n    (, cfg) = mgv.config($(base), $(quote));\n    logOfferBook($(base), $(quote), 2);\n    assertEq(cfg.best(), ofr1, \"Best offer should have changed\");\n  }\n\n  function test_update_offer_price_with_best_as_pivot_becomes_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether + 1, 100_000, ofr0, ofr1);\n    (, cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr1, cfg.best(), \"Best offer should have changed\");\n  }\n\n  function test_update_offer_density_with_best_as_pivot_becomes_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 99_999, ofr0, ofr1);\n    (, cfg) = mgv.config($(base), $(quote));\n    logOfferBook($(base), $(quote), 2);\n    assertEq(cfg.best(), ofr1, \"Best offer should have changed\");\n  }\n\n  function test_update_offer_price_with_best_as_pivot_changes_prevnext()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr3 = mkr.newOffer(1.2 ether, 1 ether, 100_000, 0);\n\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Insertion error\"\n    );\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr0, \"Wrong prev offer\");\n    assertEq(offer.next(), ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.1 ether, 1.0 ether, 100_000, ofr0, ofr);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Insertion error\"\n    );\n    offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr2, \"Wrong prev offer after update\");\n    assertEq(offer.next(), ofr3, \"Wrong next offer after update\");\n  }\n\n  function test_update_offer_price_with_self_as_pivot_changes_prevnext()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr3 = mkr.newOffer(1.2 ether, 1 ether, 100_000, 0);\n\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Insertion error\"\n    );\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr0, \"Wrong prev offer\");\n    assertEq(offer.next(), ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.1 ether, 1.0 ether, 100_000, ofr, ofr);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Insertion error\"\n    );\n    offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr2, \"Wrong prev offer after update\");\n    assertEq(offer.next(), ofr3, \"Wrong next offer after update\");\n  }\n\n  function test_update_offer_density_with_best_as_pivot_changes_prevnext()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.0 ether, 1 ether, 100_001, 0);\n    uint ofr3 = mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Insertion error\"\n    );\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr0, \"Wrong prev offer\");\n    assertEq(offer.next(), ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr);\n    assertTrue(mgv.isLive(mgv.offers($(base), $(quote), ofr)), \"Update error\");\n    offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr2, \"Wrong prev offer after update\");\n    assertEq(offer.next(), ofr3, \"Wrong next offer after update\");\n  }\n\n  function test_update_offer_density_with_self_as_pivot_changes_prevnext()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.0 ether, 1 ether, 100_001, 0);\n    uint ofr3 = mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Insertion error\"\n    );\n    P.Offer.t offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr0, \"Wrong prev offer\");\n    assertEq(offer.next(), ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr, ofr);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Insertion error\"\n    );\n    offer = mgv.offers($(base), $(quote), ofr);\n    assertEq(offer.prev(), ofr2, \"Wrong prev offer after update\");\n    assertEq(offer.next(), ofr3, \"Wrong next offer after update\");\n  }\n\n  function test_update_offer_after_higher_gasprice_change_fails() public {\n    uint provision = getProvision($(base), $(quote), 100_000);\n    mkr.provisionMgv(provision);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (P.Global.t cfg, ) = mgv.config($(base), $(quote));\n    mgv.setGasprice(cfg.gasprice() + 1); //gasprice goes up\n    vm.expectRevert(\"mgv/insufficientProvision\");\n    mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0);\n  }\n\n  function test_update_offer_after_higher_gasprice_change_succeeds_when_over_provisioned()\n    public\n  {\n    (P.Global.t cfg, ) = mgv.config($(base), $(quote));\n    uint gasprice = cfg.gasprice();\n    uint provision = getProvision($(base), $(quote), 100_000, gasprice);\n    expectFrom($(mgv));\n    emit Credit(address(mkr), provision * 2);\n    mkr.provisionMgv(provision * 2); // provisionning twice the required amount\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      address(mkr),\n      1.0 ether,\n      1.0 ether,\n      gasprice, // offer at old gasprice\n      100_000,\n      1,\n      0\n    );\n    expectFrom($(mgv));\n    emit Debit(address(mkr), provision); // transfering missing provision into offer bounty\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0); // locking exact bounty\n    mgv.setGasprice(gasprice + 1); //gasprice goes up\n    uint provision_ = getProvision($(base), $(quote), 100_000, gasprice + 1); // new theoretical provision\n    (cfg, ) = mgv.config($(base), $(quote));\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      address(mkr),\n      1.0 ether + 2,\n      1.0 ether,\n      cfg.gasprice(), // offer gasprice should be the new gasprice\n      100_000,\n      ofr0,\n      0\n    );\n    expectFrom($(mgv));\n    emit Debit(address(mkr), provision_ - provision); // transfering missing provision into offer bounty\n    mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0);\n  }\n\n  function test_update_offer_after_lower_gasprice_change_succeeds() public {\n    uint provision = getProvision($(base), $(quote), 100_000);\n    mkr.provisionMgv(provision);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (P.Global.t cfg, ) = mgv.config($(base), $(quote));\n    mgv.setGasprice(cfg.gasprice() - 1); //gasprice goes down\n    uint _provision = getProvision($(base), $(quote), 100_000);\n    expectFrom($(mgv));\n    emit Credit(address(mkr), provision - _provision);\n    mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0);\n    assertEq(\n      mgv.balanceOf(address(mkr)),\n      provision - _provision,\n      \"Maker balance is incorrect\"\n    );\n  }\n\n  function test_update_offer_next_to_itself_does_not_break_ob() public {\n    mkr.provisionMgv(1 ether);\n    uint left = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint right = mkr.newOffer(1 ether + 3, 1 ether, 100_000, 0);\n    uint center = mkr.newOffer(1 ether + 1, 1 ether, 100_000, 0);\n    mkr.updateOffer(1 ether + 2, 1 ether, 100_000, center, center);\n    P.Offer.t ofr = mgv.offers($(base), $(quote), center);\n    assertEq(ofr.prev(), left, \"ofr.prev should be unchanged\");\n    assertEq(ofr.next(), right, \"ofr.next should be unchanged\");\n  }\n\n  function test_update_on_retracted_offer() public {\n    uint provision = getProvision($(base), $(quote), 100_000);\n    mkr.provisionMgv(provision);\n    uint offerId = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.retractOfferWithDeprovision(offerId);\n    mkr.withdrawMgv(provision);\n    assertEq(\n      mgv.balanceOf(address(mkr)),\n      0,\n      \"Maker should have no more provision on Mangrove\"\n    );\n    P.Offer.t ofr = mgv.offers($(base), $(quote), offerId);\n    P.OfferDetail.t dtl = mgv.offerDetails($(base), $(quote), offerId);\n    assertEq(ofr.gives(), 0, \"Retracted offer should have 0 gives\");\n    assertEq(dtl.gasprice(), 0, \"Deprovisioned offer should have 0 gasprice\");\n    vm.expectRevert(\"mgv/insufficientProvision\");\n    mkr.updateOffer(1 ether + 2, 1 ether, 100_000, offerId, offerId);\n    mkr.provisionMgv(provision);\n    mkr.updateOffer(1 ether + 2, 1 ether, 100_000, offerId, offerId);\n    ofr = mgv.offers($(base), $(quote), offerId);\n    assertEq(ofr.gives(), 1 ether, \"Offer not correctly updated\");\n  }\n\n  function testOBBest(uint id) internal {\n    P.Offer.t ofr = mgv.offers($(base), $(quote), id);\n    assertEq(mgv.best($(base), $(quote)), id, \"testOBBest: not best\");\n    assertEq(ofr.prev(), 0, \"testOBBest: prev not 0\");\n  }\n\n  function testOBWorst(uint id) internal {\n    P.Offer.t ofr = mgv.offers($(base), $(quote), id);\n    assertEq(ofr.next(), 0, \"testOBWorst fail\");\n  }\n\n  function testOBLink(uint left, uint right) internal {\n    P.Offer.t ofr = mgv.offers($(base), $(quote), left);\n    assertEq(ofr.next(), right, \"testOBLink: wrong ofr.next\");\n    ofr = mgv.offers($(base), $(quote), right);\n    assertEq(ofr.prev(), left, \"testOBLink: wrong ofr.prev\");\n  }\n\n  function testOBOrder(uint[1] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBWorst(ids[0]);\n  }\n\n  function testOBOrder(uint[2] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBLink(ids[0], ids[1]);\n    testOBWorst(ids[1]);\n  }\n\n  function testOBOrder(uint[3] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBLink(ids[0], ids[1]);\n    testOBLink(ids[1], ids[2]);\n    testOBWorst(ids[2]);\n  }\n\n  function test_complex_offer_update_left_1_1() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function test_complex_offer_update_right_1() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, two, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function test_complex_offer_update_left_1_2() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 5, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function test_complex_offer_update_right_1_2() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 5, x, g, two, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function test_complex_offer_update_left_2() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    uint three = mkr.newOffer(x + 5, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, 0, three);\n\n    testOBOrder([one, three, two]);\n  }\n\n  function test_complex_offer_update_right_2() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    uint three = mkr.newOffer(x + 5, x, g, 0);\n    mkr.updateOffer(x + 4, x, g, three, one);\n\n    testOBOrder([two, one, three]);\n  }\n\n  function test_complex_offer_update_left_3() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.retractOffer(two);\n    mkr.updateOffer(x + 3, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function test_complex_offer_update_right_3() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.retractOffer(one);\n    mkr.updateOffer(x, x, g, 0, one);\n\n    testOBOrder([one, two]);\n  }\n\n  function test_update_offer_prev_to_itself_does_not_break_ob() public {\n    mkr.provisionMgv(1 ether);\n    uint left = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint right = mkr.newOffer(1 ether + 3, 1 ether, 100_000, 0);\n    uint center = mkr.newOffer(1 ether + 2, 1 ether, 100_000, 0);\n    mkr.updateOffer(1 ether + 1, 1 ether, 100_000, center, center);\n    P.Offer.t ofr = mgv.offers($(base), $(quote), center);\n    assertEq(ofr.prev(), left, \"ofr.prev should be unchanged\");\n    assertEq(ofr.next(), right, \"ofr.next should be unchanged\");\n  }\n\n  function test_update_offer_price_stays_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1.0 ether + 2, 1 ether, 100_000, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether + 1, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Best offer should not have changed\");\n  }\n\n  function test_update_offer_density_stays_best() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr0);\n    (, cfg) = mgv.config($(base), $(quote));\n    assertEq(ofr0, cfg.best(), \"Best offer should not have changed\");\n  }\n\n  function test_gasbase_is_deducted_1() public {\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mgv.setGasbase($(base), $(quote), offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity($(base), $(quote), 0);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 0, 0);\n    tkr.take(ofr, 0.1 ether);\n    assertEq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - offer_gasbase * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  function test_gasbase_is_deducted_2() public {\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mgv.setGasbase($(base), $(quote), offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity($(base), $(quote), 0);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 0, 0);\n    tkr.take(ofr, 0.1 ether);\n    assertEq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - offer_gasbase * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  function test_penalty_gasprice_is_mgv_gasprice() public {\n    mgv.setGasprice(10);\n    mkr.shouldFail(true);\n    mkr.provisionMgv(1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldProvision = mgv.balanceOf(address(mkr));\n    mgv.setGasprice(10000);\n    (uint gave, uint got) = tkr.marketOrder(1 ether, 1 ether);\n    assertTrue(gave == got && got == 0, \"market Order should be noop\");\n    uint gotBack = mgv.balanceOf(address(mkr)) - oldProvision;\n    assertEq(gotBack, 0, \"Should not have gotten any provision back\");\n  }\n}\n"
    },
    "contracts/test/core/InvertedTakerOperations.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\n/* The following constructs an ERC20 with a transferFrom callback method,\n   and a TestTaker which throws away any funds received upon getting\n   a callback.\n*/\ncontract InvertedTakerOperationsTest is ITaker, MangroveTest {\n  TestMaker mkr;\n  uint baseBalance;\n  uint quoteBalance;\n\n  function setUp() public override {\n    options.invertedMangrove = true;\n    super.setUp();\n\n    deal($(quote), $(this), 10 ether);\n\n    mkr = setupMaker($(base), $(quote), \"maker\");\n\n    deal($(base), address(mkr), 5 ether);\n    mkr.provisionMgv(1 ether);\n    mkr.approveMgv(base, 10 ether);\n\n    baseBalance = base.balanceOf($(this));\n    quoteBalance = quote.balanceOf($(this));\n  }\n\n  uint toPay;\n\n  function checkPay(\n    address,\n    address,\n    uint totalGives\n  ) internal {\n    assertEq(\n      toPay,\n      totalGives,\n      \"totalGives should be the sum of taker flashborrows\"\n    );\n  }\n\n  bool skipCheck;\n\n  function(address, address, uint) internal _takerTrade; // stored function pointer\n\n  function takerTrade(\n    address _$base,\n    address _$quote,\n    uint totalGot,\n    uint totalGives\n  ) public override {\n    require(msg.sender == $(mgv));\n    if (!skipCheck) {\n      assertEq(\n        baseBalance + totalGot,\n        base.balanceOf($(this)),\n        \"totalGot should be sum of maker flashloans\"\n      );\n    }\n    _takerTrade(_$base, _$quote, totalGives);\n    // require(false);\n  }\n\n  function test_taker_gets_sum_of_borrows_in_execute() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    _takerTrade = checkPay;\n    toPay = 0.2 ether;\n    (, uint gave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      0.2 ether,\n      0.2 ether,\n      true\n    );\n    assertEq(\n      quoteBalance - gave,\n      quote.balanceOf($(this)),\n      \"totalGave should be sum of taker flashborrows\"\n    );\n  }\n\n  string constant REVERT_TRADE_REASON = \"InvertedTakerOperationsTest/TradeFail\";\n\n  function revertTrade(\n    address,\n    address,\n    uint\n  ) internal pure {\n    revert(REVERT_TRADE_REASON);\n  }\n\n  function test_taker_reverts_during_trade() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint _ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    _takerTrade = revertTrade;\n    skipCheck = true;\n    try mgv.marketOrder($(base), $(quote), 0.2 ether, 0.2 ether, true) {\n      fail(\"Market order should have reverted\");\n    } catch Error(string memory reason) {\n      assertEq(REVERT_TRADE_REASON, reason, \"Unexpected throw\");\n      assertTrue(\n        mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n        \"Offer 1 should be present\"\n      );\n      assertTrue(\n        mgv.isLive(mgv.offers($(base), $(quote), _ofr)),\n        \"Offer 2 should be present\"\n      );\n    }\n  }\n\n  function refuseFeeTrade(\n    address _base,\n    address,\n    uint\n  ) external {\n    IERC20(_base).approve($(mgv), 0);\n  }\n\n  function refusePayTrade(\n    address,\n    address _quote,\n    uint\n  ) internal {\n    IERC20(_quote).approve($(mgv), 0);\n  }\n\n  function test_taker_refuses_to_deliver_during_trade() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    _takerTrade = refusePayTrade;\n    try mgv.marketOrder($(base), $(quote), 0.2 ether, 0.2 ether, true) {\n      fail(\"Market order should have reverted\");\n    } catch Error(string memory reason) {\n      assertEq(reason, \"mgv/takerFailToPayTotal\", \"Unexpected throw message\");\n    }\n  }\n\n  function test_vault_receives_quote_tokens_if_maker_is_blacklisted_for_quote()\n    public\n  {\n    _takerTrade = noop;\n    quote.blacklists(address(mkr));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    address vault = address(1);\n    mgv.setVault(vault);\n    uint vaultBal = quote.balanceOf(vault);\n\n    (uint successes, , , , ) = mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 50_000]),\n      true\n    );\n    assertTrue(successes == 1, \"Trade should succeed\");\n    assertEq(\n      quote.balanceOf(vault) - vaultBal,\n      1 ether,\n      \"Vault balance should have increased\"\n    );\n  }\n\n  function noop(\n    address,\n    address,\n    uint\n  ) internal {}\n\n  function reenter(\n    address _base,\n    address _quote,\n    uint\n  ) internal {\n    _takerTrade = noop;\n    skipCheck = true;\n    (uint successes, uint totalGot, uint totalGave, , ) = mgv.snipes(\n      _base,\n      _quote,\n      wrap_dynamic([uint(2), 0.1 ether, 0.1 ether, 100_000]),\n      true\n    );\n    assertTrue(successes == 1, \"Snipe on reentrancy should succeed\");\n    assertEq(totalGot, 0.1 ether, \"Incorrect totalGot\");\n    assertEq(totalGave, 0.1 ether, \"Incorrect totalGave\");\n  }\n\n  function test_taker_snipe_mgv_during_trade() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    _takerTrade = reenter;\n    expectFrom($(mgv));\n    emit OfferSuccess($(base), $(quote), 1, $(this), 0.1 ether, 0.1 ether);\n    expectFrom($(mgv));\n    emit OfferSuccess($(base), $(quote), 2, $(this), 0.1 ether, 0.1 ether);\n    (uint got, uint gave, , ) = mgv.marketOrder(\n      $(base),\n      $(quote),\n      0.1 ether,\n      0.1 ether,\n      true\n    );\n    assertEq(\n      quoteBalance - gave - 0.1 ether,\n      quote.balanceOf($(this)),\n      \"Incorrect transfer (gave) during reentrancy\"\n    );\n    assertEq(\n      baseBalance + got + 0.1 ether,\n      base.balanceOf($(this)),\n      \"Incorrect transfer (got) during reentrancy\"\n    );\n  }\n\n  function test_taker_pays_back_correct_amount_1() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint bal = quote.balanceOf($(this));\n    _takerTrade = noop;\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0.05 ether, 0.05 ether, 100_000]),\n      true\n    );\n    assertEq(quote.balanceOf($(this)), bal - 0.05 ether, \"wrong taker balance\");\n  }\n\n  function test_taker_pays_back_correct_amount_2() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint bal = quote.balanceOf($(this));\n    _takerTrade = noop;\n    mgv.snipes(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 0.02 ether, 0.02 ether, 100_000]),\n      true\n    );\n    assertEq(quote.balanceOf($(this)), bal - 0.02 ether, \"wrong taker balance\");\n  }\n}\n"
    },
    "contracts/test/core/Gatekeeping.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract GatekeepingTest is IMaker, MangroveTest {\n  receive() external payable {}\n\n  TestTaker tkr;\n  TestMaker mkr;\n  TestMaker dual_mkr;\n  address notAdmin;\n\n  function setUp() public override {\n    super.setUp();\n    deal($(base), $(this), 10 ether);\n\n    tkr = setupTaker($(base), $(quote), \"taker[$(A),$(B)]\");\n    mkr = setupMaker($(base), $(quote), \"maker[$(A),$(B)]\");\n    dual_mkr = setupMaker($(quote), $(base), \"maker[$(B),$(A)]\");\n\n    mkr.provisionMgv(5 ether);\n    dual_mkr.provisionMgv(5 ether);\n\n    deal($(quote), address(tkr), 1 ether);\n    deal($(quote), address(mkr), 1 ether);\n    deal($(base), address(dual_mkr), 1 ether);\n\n    tkr.approveMgv(quote, 1 ether);\n\n    notAdmin = freshAddress();\n  }\n\n  /* # Test Config */\n\n  function test_gov_is_not_sender() public {\n    mgv = new Mangrove({governance: notAdmin, gasprice: 0, gasmax: 0});\n    assertEq(mgv.governance(), notAdmin, \"governance should not be msg.sender\");\n  }\n\n  function test_gov_cant_be_zero() public {\n    vm.expectRevert(\"mgv/config/gov/not0\");\n    mgv.setGovernance(address(0));\n  }\n\n  function test_gov_can_transfer_rights() public {\n    expectFrom($(mgv));\n    emit SetGovernance(notAdmin);\n    mgv.setGovernance(notAdmin);\n\n    vm.expectRevert(\"mgv/unauthorized\");\n    mgv.setFee($(base), $(quote), 0);\n\n    expectFrom($(mgv));\n    emit SetFee($(base), $(quote), 1);\n    vm.prank(notAdmin);\n    mgv.setFee($(base), $(quote), 1);\n  }\n\n  function test_only_gov_can_set_fee() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.setFee($(base), $(quote), 0);\n  }\n\n  function test_only_gov_can_set_density() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.setDensity($(base), $(quote), 0);\n  }\n\n  function test_set_zero_density() public {\n    expectFrom($(mgv));\n    emit SetDensity($(base), $(quote), 0);\n    mgv.setDensity($(base), $(quote), 0);\n  }\n\n  function test_only_gov_can_kill() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.kill();\n  }\n\n  function test_killing_updates_config() public {\n    (P.Global.t global, ) = mgv.config(address(0), address(0));\n    assertTrue(!global.dead(), \"mgv should not be dead \");\n    expectFrom($(mgv));\n    emit Kill();\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    assertTrue(global.dead(), \"mgv should be dead \");\n  }\n\n  function test_kill_is_idempotent() public {\n    (P.Global.t global, ) = mgv.config(address(0), address(0));\n    assertTrue(!global.dead(), \"mgv should not be dead \");\n    expectFrom($(mgv));\n    emit Kill();\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    assertTrue(global.dead(), \"mgv should be dead\");\n    expectFrom($(mgv));\n    emit Kill();\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    assertTrue(global.dead(), \"mgv should still be dead\");\n  }\n\n  function test_only_gov_can_set_vault() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.setVault($(this));\n  }\n\n  function test_only_gov_can_set_monitor() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.setMonitor($(this));\n  }\n\n  function test_only_gov_can_set_active() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.activate($(quote), $(base), 0, 100, 0);\n  }\n\n  function test_only_gov_can_set_gasprice() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.setGasprice(0);\n  }\n\n  function test_only_gov_can_set_gasmax() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.setGasmax(0);\n  }\n\n  function test_only_gov_can_set_gasbase() public {\n    vm.expectRevert(\"mgv/unauthorized\");\n    vm.prank(notAdmin);\n    mgv.setGasbase($(base), $(quote), 0);\n  }\n\n  function test_empty_mgv_ok() public {\n    tkr.marketOrder(0, 0);\n  }\n\n  function test_set_fee_ceiling() public {\n    vm.expectRevert(\"mgv/config/fee/<=500\");\n    mgv.setFee($(base), $(quote), 501);\n  }\n\n  function test_set_density_ceiling() public {\n    vm.expectRevert(\"mgv/config/density/112bits\");\n    mgv.setDensity($(base), $(quote), uint(type(uint112).max) + 1);\n  }\n\n  function test_set_gasprice_ceiling() public {\n    vm.expectRevert(\"mgv/config/gasprice/16bits\");\n    mgv.setGasprice(uint(type(uint16).max) + 1);\n  }\n\n  function test_set_zero_gasbase() public {\n    mgv.setGasbase($(base), $(quote), 0);\n  }\n\n  function test_set_gasbase_ceiling() public {\n    vm.expectRevert(\"mgv/config/offer_gasbase/24bits\");\n    mgv.setGasbase($(base), $(quote), uint(type(uint24).max) + 1);\n  }\n\n  function test_set_gasmax_ceiling() public {\n    vm.expectRevert(\"mgv/config/gasmax/24bits\");\n    mgv.setGasmax(uint(type(uint24).max) + 1);\n  }\n\n  function test_makerWants_wider_than_96_bits_fails_newOffer() public {\n    vm.expectRevert(\"mgv/writeOffer/wants/96bits\");\n    mkr.newOffer(2**96, 1 ether, 10_000, 0);\n  }\n\n  function test_retractOffer_wrong_owner_fails() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n    vm.expectRevert(\"mgv/retractOffer/unauthorized\");\n    mgv.retractOffer($(base), $(quote), ofr, false);\n  }\n\n  function test_makerGives_wider_than_96_bits_fails_newOffer() public {\n    vm.expectRevert(\"mgv/writeOffer/gives/96bits\");\n    mkr.newOffer(1, 2**96, 10_000, 0);\n  }\n\n  function test_makerGasreq_wider_than_24_bits_fails_newOffer() public {\n    vm.expectRevert(\"mgv/writeOffer/gasreq/tooHigh\");\n    mkr.newOffer(1, 1, 2**24, 0);\n  }\n\n  function test_makerGasreq_bigger_than_gasmax_fails_newOffer() public {\n    (P.Global.t cfg, ) = mgv.config($(base), $(quote));\n    vm.expectRevert(\"mgv/writeOffer/gasreq/tooHigh\");\n    mkr.newOffer(1, 1, cfg.gasmax() + 1, 0);\n  }\n\n  function test_makerGasreq_at_gasmax_succeeds_newOffer() public {\n    (P.Global.t cfg, ) = mgv.config($(base), $(quote));\n    // Logging tests\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      address(mkr),\n      1 ether, //base\n      1 ether, //quote\n      cfg.gasprice(), //gasprice\n      cfg.gasmax(), //gasreq\n      1, //ofrId\n      0 // prev\n    );\n    expectFrom($(mgv));\n    emit Debit(address(mkr), getProvision($(base), $(quote), cfg.gasmax(), 0));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, cfg.gasmax(), 0);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should have been inserted\"\n    );\n  }\n\n  function test_makerGasreq_lower_than_density_fails_newOffer() public {\n    mgv.setDensity($(base), $(quote), 100);\n    (, P.Local.t cfg) = mgv.config($(base), $(quote));\n    uint amount = (1 + cfg.offer_gasbase()) * cfg.density();\n    vm.expectRevert(\"mgv/writeOffer/density/tooLow\");\n    mkr.newOffer(amount - 1, amount - 1, 1, 0);\n  }\n\n  function test_makerGasreq_at_density_suceeds() public {\n    mgv.setDensity($(base), $(quote), 100);\n    (P.Global.t glob, P.Local.t cfg) = mgv.config($(base), $(quote));\n    uint amount = (1 + cfg.offer_gasbase()) * cfg.density();\n    // Logging tests\n    expectFrom($(mgv));\n    emit OfferWrite(\n      $(base),\n      $(quote),\n      address(mkr),\n      amount, //base\n      amount, //quote\n      glob.gasprice(), //gasprice\n      1, //gasreq\n      1, //ofrId\n      0 // prev\n    );\n    expectFrom($(mgv));\n    emit Debit(address(mkr), getProvision($(base), $(quote), 1, 0));\n    uint ofr = mkr.newOffer(amount, amount, 1, 0);\n    assertTrue(\n      mgv.isLive(mgv.offers($(base), $(quote), ofr)),\n      \"Offer should have been inserted\"\n    );\n  }\n\n  function test_makerGasprice_wider_than_16_bits_fails_newOffer() public {\n    vm.expectRevert(\"mgv/writeOffer/gasprice/16bits\");\n    mkr.newOffer(1, 1, 1, 2**16, 0);\n  }\n\n  function test_takerWants_wider_than_160_bits_fails_marketOrder() public {\n    vm.expectRevert(\"mgv/mOrder/takerWants/160bits\");\n    tkr.marketOrder(2**160, 0);\n  }\n\n  function test_takerWants_above_96bits_fails_snipes() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint[4][] memory targets = wrap_dynamic(\n      [ofr, uint(type(uint96).max) + 1, type(uint96).max, type(uint).max]\n    );\n    vm.expectRevert(\"mgv/snipes/takerWants/96bits\");\n    mgv.snipes($(base), $(quote), targets, true);\n  }\n\n  function test_takerGives_above_96bits_fails_snipes() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint[4][] memory targets = wrap_dynamic(\n      [ofr, type(uint96).max, uint(type(uint96).max) + 1, type(uint).max]\n    );\n    vm.expectRevert(\"mgv/snipes/takerGives/96bits\");\n    mgv.snipes($(base), $(quote), targets, true);\n  }\n\n  function test_initial_allowance_is_zero() public {\n    assertEq(\n      mgv.allowances($(base), $(quote), address(tkr), $(this)),\n      0,\n      \"initial allowance should be 0\"\n    );\n  }\n\n  function test_cannot_snipesFor_for_without_allowance() public {\n    deal($(base), address(mkr), 1 ether);\n    mkr.approveMgv(base, 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    vm.expectRevert(\"mgv/lowAllowance\");\n    mgv.snipesFor(\n      $(base),\n      $(quote),\n      wrap_dynamic([ofr, 1 ether, 1 ether, 300_000]),\n      true,\n      address(tkr)\n    );\n  }\n\n  function test_cannot_marketOrderFor_for_without_allowance() public {\n    deal($(base), address(mkr), 1 ether);\n    mkr.approveMgv(base, 1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    vm.expectRevert(\"mgv/lowAllowance\");\n    mgv.marketOrderFor($(base), $(quote), 1 ether, 1 ether, true, address(tkr));\n  }\n\n  function test_can_marketOrderFor_for_with_allowance() public {\n    deal($(base), address(mkr), 1 ether);\n    mkr.approveMgv(base, 1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    tkr.approveSpender($(this), 1.2 ether);\n    uint takerGot;\n    (takerGot, , , ) = mgv.marketOrderFor(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      true,\n      address(tkr)\n    );\n    assertEq(\n      mgv.allowances($(base), $(quote), address(tkr), $(this)),\n      0.2 ether,\n      \"allowance should have correctly reduced\"\n    );\n  }\n\n  /* # Internal IMaker setup */\n\n  bytes trade_cb;\n  bytes posthook_cb;\n\n  // maker's trade fn for the mgv\n  function makerExecute(MgvLib.SingleOrder calldata)\n    external\n    override\n    returns (bytes32 ret)\n  {\n    ret; // silence unused function parameter\n    bool success;\n    if (trade_cb.length > 0) {\n      (success, ) = $(this).call(trade_cb);\n      assertTrue(success, \"makerExecute callback must work\");\n    }\n    return \"\";\n  }\n\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external override {\n    bool success;\n    order; // silence compiler warning\n    if (posthook_cb.length > 0) {\n      (success, ) = $(this).call(posthook_cb);\n      bool tradeResult = (result.mgvData == \"mgv/tradeSuccess\");\n      assertTrue(success == tradeResult, \"makerPosthook callback must work\");\n    }\n  }\n\n  /* # Reentrancy */\n\n  /* New Offer failure */\n\n  function newOfferKO() external {\n    vm.expectRevert(\"mgv/reentrancyLocked\");\n    mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 30_000, 0, 0);\n  }\n\n  function test_newOffer_on_reentrancy_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeCall(this.newOfferKO, ());\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* New Offer success */\n\n  // ! may be called with inverted _base and _quote\n  function newOfferOK(address _base, address _quote) external {\n    mgv.newOffer(_base, _quote, 1 ether, 1 ether, 30_000, 0, 0);\n  }\n\n  function test_newOffer_on_reentrancy_succeeds() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 200_000, 0, 0);\n    trade_cb = abi.encodeCall(this.newOfferOK, ($(quote), $(base)));\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.best($(quote), $(base)) == 1,\n      \"newOffer on swapped pair must work\"\n    );\n  }\n\n  function test_newOffer_on_posthook_succeeds() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 200_000, 0, 0);\n    posthook_cb = abi.encodeCall(this.newOfferOK, ($(base), $(quote)));\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.best($(base), $(quote)) == 2,\n      \"newOffer on posthook must work\"\n    );\n  }\n\n  /* Update offer failure */\n\n  function updateOfferKO(uint ofr) external {\n    vm.expectRevert(\"mgv/reentrancyLocked\");\n    mgv.updateOffer($(base), $(quote), 1 ether, 2 ether, 35_000, 0, 0, ofr);\n  }\n\n  function test_updateOffer_on_reentrancy_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeCall(this.updateOfferKO, (ofr));\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Update offer success */\n\n  // ! may be called with inverted _base and _quote\n  function updateOfferOK(\n    address _base,\n    address _quote,\n    uint ofr\n  ) external {\n    mgv.updateOffer(_base, _quote, 1 ether, 2 ether, 35_000, 0, 0, ofr);\n  }\n\n  function test_updateOffer_on_reentrancy_succeeds() public {\n    uint other_ofr = mgv.newOffer(\n      $(quote),\n      $(base),\n      1 ether,\n      1 ether,\n      100_000,\n      0,\n      0\n    );\n\n    trade_cb = abi.encodeCall(\n      this.updateOfferOK,\n      ($(quote), $(base), other_ofr)\n    );\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 400_000, 0, 0);\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.offerDetails($(quote), $(base), other_ofr).gasreq() == 35_000,\n      \"updateOffer on swapped pair must work\"\n    );\n  }\n\n  function test_updateOffer_on_posthook_succeeds() public {\n    uint other_ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      100_000,\n      0,\n      0\n    );\n    posthook_cb = abi.encodeCall(\n      this.updateOfferOK,\n      ($(base), $(quote), other_ofr)\n    );\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 300_000, 0, 0);\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.offerDetails($(base), $(quote), other_ofr).gasreq() == 35_000,\n      \"updateOffer on posthook must work\"\n    );\n  }\n\n  /* Cancel Offer failure */\n\n  function retractOfferKO(uint id) external {\n    vm.expectRevert(\"mgv/reentrancyLocked\");\n    mgv.retractOffer($(base), $(quote), id, false);\n  }\n\n  function test_retractOffer_on_reentrancy_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeCall(this.retractOfferKO, (ofr));\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Cancel Offer success */\n\n  function retractOfferOK(\n    address _base,\n    address _quote,\n    uint id\n  ) external {\n    uint collected = mgv.retractOffer(_base, _quote, id, false);\n    assertEq(\n      collected,\n      0,\n      \"Unexpected collected provision after retract w/o deprovision\"\n    );\n  }\n\n  function test_retractOffer_on_reentrancy_succeeds() public {\n    uint other_ofr = mgv.newOffer(\n      $(quote),\n      $(base),\n      1 ether,\n      1 ether,\n      90_000,\n      0,\n      0\n    );\n    trade_cb = abi.encodeCall(\n      this.retractOfferOK,\n      ($(quote), $(base), other_ofr)\n    );\n\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 90_000, 0, 0);\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.best($(quote), $(base)) == 0,\n      \"retractOffer on swapped pair must work\"\n    );\n  }\n\n  function test_retractOffer_on_posthook_succeeds() public {\n    uint other_ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      1 ether,\n      1 ether,\n      190_000,\n      0,\n      0\n    );\n    posthook_cb = abi.encodeCall(\n      this.retractOfferOK,\n      ($(base), $(quote), other_ofr)\n    );\n\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 90_000, 0, 0);\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.best($(base), $(quote)) == 0,\n      \"retractOffer on posthook must work\"\n    );\n  }\n\n  /* Market Order failure */\n\n  function marketOrderKO() external {\n    vm.expectRevert(\"mgv/reentrancyLocked\");\n    mgv.marketOrder($(base), $(quote), 0.2 ether, 0.2 ether, true);\n  }\n\n  function test_marketOrder_on_reentrancy_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeCall(this.marketOrderKO, ());\n    assertTrue(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Market Order Success */\n\n  function marketOrderOK(address _base, address _quote) external {\n    mgv.marketOrder(_base, _quote, 0.5 ether, 0.5 ether, true);\n  }\n\n  function test_marketOrder_on_reentrancy_succeeds() public {\n    dual_mkr.newOffer(0.5 ether, 0.5 ether, 30_000, 0);\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 392_000, 0, 0);\n    trade_cb = abi.encodeCall(this.marketOrderOK, ($(quote), $(base)));\n    assertTrue(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.best($(quote), $(base)) == 0,\n      \"2nd market order must have emptied mgv\"\n    );\n  }\n\n  function test_marketOrder_on_posthook_succeeds() public {\n    uint ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      0.5 ether,\n      0.5 ether,\n      500_000,\n      0,\n      0\n    );\n    mgv.newOffer($(base), $(quote), 0.5 ether, 0.5 ether, 200_000, 0, 0);\n    posthook_cb = abi.encodeCall(this.marketOrderOK, ($(base), $(quote)));\n    assertTrue(tkr.take(ofr, 0.6 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.best($(base), $(quote)) == 0,\n      \"2nd market order must have emptied mgv\"\n    );\n  }\n\n  /* Snipe failure */\n\n  function snipesKO(uint id) external {\n    uint[4][] memory targets = wrap_dynamic(\n      [id, 1 ether, type(uint96).max, type(uint48).max]\n    );\n    vm.expectRevert(\"mgv/reentrancyLocked\");\n    mgv.snipes($(base), $(quote), targets, true);\n  }\n\n  function test_snipe_on_reentrancy_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 60_000, 0, 0);\n    trade_cb = abi.encodeCall(this.snipesKO, (ofr));\n    assertTrue(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Snipe success */\n\n  function snipesOK(\n    address _base,\n    address _quote,\n    uint id\n  ) external {\n    uint[4][] memory targets = wrap_dynamic(\n      [id, 1 ether, type(uint96).max, type(uint48).max]\n    );\n    mgv.snipes(_base, _quote, targets, true);\n  }\n\n  function test_snipes_on_reentrancy_succeeds() public {\n    uint other_ofr = dual_mkr.newOffer(1 ether, 1 ether, 30_000, 0);\n    trade_cb = abi.encodeCall(this.snipesOK, ($(quote), $(base), other_ofr));\n\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 190_000, 0, 0);\n    assertTrue(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n    assertTrue(\n      mgv.best($(quote), $(base)) == 0,\n      \"snipe in swapped pair must work\"\n    );\n  }\n\n  function test_snipes_on_posthook_succeeds() public {\n    uint other_ofr = mkr.newOffer(1 ether, 1 ether, 30_000, 0);\n    posthook_cb = abi.encodeCall(this.snipesOK, ($(base), $(quote), other_ofr));\n\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 190_000, 0, 0);\n    assertTrue(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    assertTrue(mgv.best($(base), $(quote)) == 0, \"snipe in posthook must work\");\n  }\n\n  function test_newOffer_on_closed_fails() public {\n    mgv.kill();\n    vm.expectRevert(\"mgv/dead\");\n    mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0);\n  }\n\n  /* # Mangrove closed/inactive */\n\n  function test_take_on_closed_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0);\n\n    mgv.kill();\n    vm.expectRevert(\"mgv/dead\");\n    tkr.take(ofr, 1 ether);\n  }\n\n  function test_newOffer_on_inactive_fails() public {\n    mgv.deactivate($(base), $(quote));\n    vm.expectRevert(\"mgv/inactive\");\n    mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0);\n  }\n\n  function test_receive_on_closed_fails() public {\n    mgv.kill();\n\n    (bool success, bytes memory retdata) = $(mgv).call{value: 10 ether}(\"\");\n    if (success) {\n      fail(\"receive() should fail on closed market\");\n    } else {\n      string memory r = getReason(retdata);\n      revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function test_marketOrder_on_closed_fails() public {\n    mgv.kill();\n    vm.expectRevert(\"mgv/dead\");\n    tkr.marketOrder(1 ether, 1 ether);\n  }\n\n  function test_snipe_on_closed_fails() public {\n    mgv.kill();\n    vm.expectRevert(\"mgv/dead\");\n    tkr.take(0, 1 ether);\n  }\n\n  function test_withdraw_on_closed_ok() public {\n    mgv.kill();\n    mgv.withdraw(0.1 ether);\n  }\n\n  function test_retractOffer_on_closed_ok() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0);\n    mgv.kill();\n    mgv.retractOffer($(base), $(quote), ofr, false);\n  }\n\n  function test_updateOffer_on_closed_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0);\n    mgv.kill();\n    vm.expectRevert(\"mgv/dead\");\n    mgv.updateOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0, ofr);\n  }\n\n  function test_activation_emits_events_in_order() public {\n    expectFrom($(mgv));\n    emit SetActive($(quote), $(base), true);\n    expectFrom($(mgv));\n    emit SetFee($(quote), $(base), 7);\n    expectFrom($(mgv));\n    emit SetDensity($(quote), $(base), 0);\n    expectFrom($(mgv));\n    emit SetGasbase($(quote), $(base), 3);\n    mgv.activate($(quote), $(base), 7, 0, 3);\n  }\n\n  function test_updateOffer_on_inactive_fails() public {\n    uint ofr = mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0);\n    expectFrom($(mgv));\n    emit SetActive($(base), $(quote), false);\n    mgv.deactivate($(base), $(quote));\n    vm.expectRevert(\"mgv/inactive\");\n    mgv.updateOffer($(base), $(quote), 1 ether, 1 ether, 0, 0, 0, ofr);\n  }\n}\n"
    },
    "contracts/test/core/Gas.t.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\npragma solidity ^0.8.10;\n\nimport \"contracts/test/lib/MangroveTest.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract GasTest is MangroveTest, IMaker {\n  TestTaker _tkr;\n\n  function setUp() public override {\n    super.setUp();\n\n    mgv.newOffer($(base), $(quote), 1 ether, 1 ether, 100_000, 0, 0);\n\n    _tkr = setupTaker($(base), $(quote), \"Taker\");\n    deal($(quote), address(_tkr), 2 ether);\n    _tkr.approveMgv(quote, 2 ether);\n\n    deal($(base), $(this), 100 ether);\n\n    /* set lock to 1 to avoid spurious 15k gas cost */\n    uint ofr = mgv.newOffer(\n      $(base),\n      $(quote),\n      0.1 ether,\n      0.1 ether,\n      100_000,\n      0,\n      0\n    );\n    _tkr.take(ofr, 0.1 ether);\n  }\n\n  // preload stored vars for better gas estimate\n  function getStored()\n    internal\n    view\n    returns (\n      AbstractMangrove,\n      TestTaker,\n      address,\n      address\n    )\n  {\n    return (mgv, _tkr, $(base), $(quote));\n  }\n\n  function makerExecute(MgvLib.SingleOrder calldata)\n    external\n    pure\n    returns (bytes32)\n  {\n    return \"\"; // silence unused function parameter\n  }\n\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external {}\n\n  function test_update_min_move_0_offer() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    // uint g = gasleft();\n    _gas();\n    mgv.updateOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 1, 1);\n    gas_();\n    // console.log(\"Gas used\", g - gasleft());\n  }\n\n  function test_update_full_offer() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    _gas();\n    mgv.updateOffer(base, quote, 0.5 ether, 1 ether, 100_001, 0, 1, 1);\n    gas_();\n  }\n\n  function update_min_move_3_offer_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    _gas();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    gas_();\n  }\n\n  function test_update_min_move_3_offer() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    _gas();\n    mgv.updateOffer(base, quote, 1.0 ether, 0.1 ether, 100_00, 0, 1, 1);\n    gas_();\n  }\n\n  function update_min_move_6_offer_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    _gas();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    gas_();\n  }\n\n  function test_update_min_move_6_offer() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    _gas();\n    mgv.updateOffer(base, quote, 1.0 ether, 0.1 ether, 100_00, 0, 1, 1);\n    gas_();\n  }\n\n  function test_new_offer() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    _gas();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 1);\n    gas_();\n  }\n\n  function test_take_offer() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    _gas();\n    tkr.snipe(mgv, base, quote, 1, 1 ether, 1 ether, 100_000);\n    gas_();\n  }\n\n  function test_partial_take_offer() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    _gas();\n    tkr.snipe(mgv, base, quote, 1, 0.5 ether, 0.5 ether, 100_000);\n    gas_();\n  }\n\n  function test_market_order_1() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    _gas();\n    tkr.marketOrder(mgv, base, quote, 1 ether, 1 ether);\n    gas_();\n  }\n\n  function market_order_8_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    _gas();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    gas_();\n  }\n\n  function test_market_order_8() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    _gas();\n    tkr.marketOrder(mgv, base, quote, 2 ether, 2 ether);\n    gas_();\n  }\n}\n"
    },
    "contracts/periphery/MgvOracle.sol": {
      "content": "// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOracle.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity ^0.8.10;\npragma abicoder v2;\nimport \"../MgvLib.sol\";\n\n/* The purpose of the Oracle contract is to act as a gas price and density\n * oracle for the Mangrove. It bridges to an external oracle, and allows\n * a given sender to update the gas price and density which the oracle\n * reports to Mangrove. */\ncontract MgvOracle is IMgvMonitor {\n  event SetGasprice(uint gasPrice);\n  event SetDensity(uint density);\n\n  address governance;\n  address mutator;\n\n  uint lastReceivedGasPrice;\n  uint lastReceivedDensity;\n\n  constructor(address _governance, address _initialMutator) {\n    governance = _governance;\n    mutator = _initialMutator;\n\n    /* Set initial density from the MgvOracle to let Mangrove use its internal density by default.\n\n      Mangrove will reject densities from the Monitor that don't fit in 32 bits and use its internal density instead, so setting this contract's density to `type(uint).max` is a way to let Mangrove deal with density on its own. */\n    lastReceivedDensity = type(uint).max;\n  }\n\n  /* ## `authOnly` check */\n  // NOTE: Should use standard auth method, instead of this copy from MgvGovernable\n\n  function authOnly() internal view {\n    require(\n      msg.sender == governance ||\n        msg.sender == address(this) ||\n        governance == address(0),\n      \"MgvOracle/unauthorized\"\n    );\n  }\n\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    // Do nothing\n  }\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    // Do nothing\n  }\n\n  function setMutator(address _mutator) external {\n    authOnly();\n\n    mutator = _mutator;\n  }\n\n  function setGasPrice(uint gasPrice) external {\n    // governance or mutator are allowed to update the gasprice\n    require(\n      msg.sender == governance || msg.sender == mutator,\n      \"MgvOracle/unauthorized\"\n    );\n\n    lastReceivedGasPrice = gasPrice;\n    emit SetGasprice(gasPrice);\n  }\n\n  function setDensity(uint density) external {\n    // governance or mutator are allowed to update the density\n    require(\n      msg.sender == governance || msg.sender == mutator,\n      \"MgvOracle/unauthorized\"\n    );\n\n    lastReceivedDensity = density;\n    emit SetDensity(density);\n  }\n\n  function read(\n    address, /*outbound_tkn*/\n    address /*inbound_tkn*/\n  ) external view override returns (uint gasprice, uint density) {\n    return (lastReceivedGasPrice, lastReceivedDensity);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d00063eb37d91b136ef29131f57e851a"
      }
    }
  }
}
